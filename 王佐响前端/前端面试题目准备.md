# 前端面试题目准备

## 1  前端性能优化的七大手段

> **减少请求数量、减小资源大小、优化网络连接、优化资源加载、减少重绘回流、使用性能更好的API和构建优化**

#### **「1.  减少请求数量」**

**【合并】**

　　如果不进行文件合并，有如下3个隐患

　　1、文件与文件之间有插入的上行请求，增加了N-1个网络延迟

　　2、受丢包问题影响更严重

　　3、经过代理服务器时可能会被断开

　　但是，文件合并本身也有自己的问题

　　1、首屏渲染问题

　　2、缓存失效问题

　　所以，对于文件合并，有如下改进建议

　　1、公共库合并

　　2、不同页面单独合并

**【图片处理】**

**1、雪碧图**

　　CSS雪碧图是以前非常流行的技术，把网站上的一些图片整合到一张单独的图片中，可以减少网站的HTTP请求数量，但是当整合图片比较大时，一次加载比较慢。随着字体图片、SVG图片的流行，该技术渐渐退出了历史舞台

**2、Base64**

　　将图片的内容以Base64格式内嵌到HTML中，可以减少HTTP请求数量。但是，由于Base64编码用8位字符表示信息中的6个位，所以编码后大小大约比原始值扩大了 33%

**3、使用字体图标来代替图片**

**【减少重定向】**

　　尽量避免使用重定向，当页面发生了重定向，就会延迟整个HTML文档的传输。在HTML文档到达之前，页面中不会呈现任何东西，也没有任何组件会被下载，降低了用户体验

　　如果一定要使用重定向，如http重定向到https，要使用301永久重定向，而不是302临时重定向。因为，如果使用302，则每一次访问http，都会被重定向到https的页面。而永久重定向，在第一次从http重定向到https之后 ，每次访问http，会直接返回https的页面

**【使用缓存】**

　　使用catch-control或expires这类强缓存时，缓存不过期的情况下，不向服务器发送请求。强缓存过期时，会使用last-modified或etag这类协商缓存，向服务器发送请求，如果资源没有变化，则服务器返回304响应，浏览器继续从本地缓存加载资源；如果资源更新了，则服务器将更新后的资源发送到浏览器，并返回200响应

**【不使用CSS @import】**

　　CSS的@import会造成额外的请求

**【避免使用空的src和href】**

　　a标签设置空的href，会重定向到当前的页面地址

　　form设置空的method，会提交表单到当前的页面地址



#### **「2.  减小资源大小」**

**【压缩】**

　　1、HTML压缩

　　HTML代码压缩就是压缩在文本文件中有意义，但是在HTML中不显示的字符，包括空格，制表符，换行符等

　　2、CSS压缩

　　CSS压缩包括无效代码删除与CSS语义合并

　　3、JS压缩与混乱

　　JS压缩与混乱包括无效字符及注释的删除、代码语义的缩减和优化、降低代码可读性，实现代码保护

　　4、图片压缩

　　针对真实图片情况，舍弃一些相对无关紧要的色彩信息

**【webp】**

　　在安卓下可以使用webp格式的图片，它具有更优的图像数据压缩算法，能带来更小的图片体积，同等画面质量下，体积比jpg、png少了25%以上，而且同时具备了无损和有损的压缩模式、Alpha 透明以及动画的特性

**【开启gzip】**

　　HTTP协议上的GZIP编码是一种用来改进WEB应用程序性能的技术。大流量的WEB站点常常使用GZIP压缩技术来让用户感受更快的速度。这一般是指WWW服务器中安装的一个功能，当有人来访问这个服务器中的网站时，服务器中的这个功能就将网页内容压缩后传输到来访的电脑浏览器中显示出来。一般对纯文本内容可压缩到原大小的40%



#### **「3.  优化网络连接」**

**【使用CDN】**

　　CDN全称是Content Delivery Network，即内容分发网络，它能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。其目的是使用户可就近取得所需内容，解决 Internet网络拥挤的状况，提高用户访问网站的响应速度

**【使用DNS预解析】**

　　当浏览器访问一个域名的时候，需要解析一次DNS，获得对应域名的ip地址。在解析过程中，按照`浏览器缓存`、`系统缓存`、`路由器缓存`、`ISP(运营商)DNS缓存`、`根域名服务器`、`顶级域名服务器`、`主域名服务器`的顺序，逐步读取缓存，直到拿到IP地址

　　DNS Prefetch，即DNS预解析就是根据浏览器定义的规则，提前解析之后可能会用到的域名，使解析结果缓存到`系统缓存`中，缩短DNS解析时间，来提高网站的访问速度

　　方法是在 head 标签里面写上几个 link 标签

```
<link rel="dns-prefecth" href="https://www.google.com">
<link rel="dns-prefecth" href="https://www.google-analytics.com">
```

　　对以上几个网站提前解析 DNS，由于它是并行的，不会堵塞页面渲染，这样可以缩短资源加载的时间

**【并行连接】**

　　由于在HTTP1.1协议下，chrome每个域名的最大并发数是6个。使用多个域名，可以增加并发数

**【持久连接】**

　　使用keep-alive或presistent来建立持久连接，持久连接降低了时延和连接建立的开销，将连接保持在已调谐状态，而且减少了打开连接的潜在数量

**【管道化连接】**

　　在HTTP2协议中，可以开启管道化连接，即单条连接的多路复用，每条连接中并发传输多个资源，这里就不需要添加域名来增加并发数了



#### **「4.  优化资源加载」**

**【资源加载位置】**

　　通过优化资源加载位置，更改资源加载时机，使尽可能快地展示出页面内容，尽可能快地使功能可用

　　1、CSS文件放在head中，先外链，后本页

　　2、JS文件放在body底部，先外链，后本页

　　3、处理页面、处理页面布局的JS文件放在head中，如babel-polyfill.js文件、flexible.js文件

　　4、body中间尽量不写style标签和script标签

**【资源加载时机】**

**1、异步script标签**

　　defer: 异步加载，在HTML解析完成后执行。defer的实际效果与将代码放在body底部类似

　　async: 异步加载，加载完成后立即执行

**2、模块按需加载**

　　在SPA等业务逻辑比较复杂的系统中，需要根据路由来加载当前页面需要的业务模块

　　按需加载，是一种很好的优化网页或应用的方式。这种方式实际上是先把代码在一些逻辑断点处分离开，然后在一些代码块中完成某些操作后，立即引用或即将引用另外一些新的代码块。这样加快了应用的初始加载速度，减轻了它的总体体积，因为某些代码块可能永远不会被加载

　　webpack 提供了两个类似的技术，优先选择的方式是使用符合 ECMAScript 提案 的 import() 语法。第二种则是使用 webpack 特定的 require.ensure

**3、使用资源预加载preload和资源预读取prefetch**

　　preload让浏览器提前加载指定资源，需要执行时再执行，可以加速本页面的加载速度

　　prefetch告诉浏览器加载下一页面可能会用到的资源，可以加速下一个页面的加载速度

**4、资源懒加载与资源预加载**

　　资源延迟加载也称为懒加载，延迟加载资源或符合某些条件时才加载某些资源

　　资源预加载是提前加载用户所需的资源，保证良好的用户体验

　　资源懒加载和资源预加载都是一种错峰操作，在浏览器忙碌的时候不做操作，浏览器空间时，再加载资源，优化了网络性能



#### **「5.  减少重绘回流」**

**【样式设置】**

　　1、避免使用**层级较深**的选择器，或其他一些复杂的选择器，以提高CSS渲染效率

　　2、避免使用CSS表达式，CSS表达式是动态设置CSS属性的强大但危险方法，它的问题就在于计算频率很快。不仅仅是在页面显示和缩放时，就是在页面滚动、乃至移动鼠标时都会要重新计算一次

　　3、元素适当地定义高度或最小高度，否则元素的动态内容载入时，会出现页面元素的晃动或位置，造成回流

　　4、给图片设置尺寸。如果图片不设置尺寸，首次载入时，占据空间会从0到完全出现，上下左右都可能位移，发生回流

　　5、不要使用table布局，因为一个小改动可能会造成整个table重新布局。而且table渲染通常要3倍于同等元素时间

　　6、能够使用CSS实现的效果，尽量使用CSS而不使用JS实现

**【渲染层】**

　　1、此外，将需要多次重绘的元素独立为render layer渲染层，如设置absolute，可以减少重绘范围

　　2、对于一些进行动画的元素，使用硬件渲染，从而避免重绘和回流

**【DOM优化】**

**1、缓存DOM**

```
const div = document.getElementById('div')
```

　　由于查询DOM比较耗时，在同一个节点无需多次查询的情况下，可以缓存DOM

**2、减少DOM深度及DOM数量**

　　HTML 中标签元素越多，标签的层级越深，浏览器解析DOM并绘制到浏览器中所花的时间就越长，所以应尽可能保持 DOM 元素简洁和层级较少。

**3、批量操作DOM**

　　由于DOM操作比较耗时，且可能会造成回流，因此要避免频繁操作DOM，可以批量操作DOM，先用字符串拼接完毕，再用innerHTML更新DOM

**4、批量操作CSS样式**

　　通过切换class或者使用元素的style.csstext属性去批量操作元素样式

**5、在内存中操作DOM**

　　使用DocumentFragment对象，让DOM操作发生在内存中，而不是页面上

**6、DOM元素离线更新**

　　对DOM进行相关操作时，例、appendChild等都可以使用Document Fragment对象进行离线操作，带元素“组装”完成后再一次插入页面，或者使用display:none 对元素隐藏，在元素“消失”后进行相关操作

**7、DOM读写分离**

　　浏览器具有惰性渲染机制，连接多次修改DOM可能只触发浏览器的一次渲染。而如果修改DOM后，立即读取DOM。为了保证读取到正确的DOM值，会触发浏览器的一次渲染。因此，修改DOM的操作要与访问DOM分开进行

**8、事件代理**

　事件代理是指将事件监听器注册在父级元素上，由于子元素的事件会通过事件冒泡的方式向上传播到父节点，因此，可以由父节点的监听函数统一处理多个子元素的事件。

　利用事件代理，可以减少内存使用，提高性能及降低代码复杂度。

**9、防抖和节流**

　使用函数节流（throttle）或函数去抖（debounce），限制某一个方法的频繁触发

**10、及时清理环境**

　及时消除对象引用，清除定时器，清除事件监听器，创建最小作用域变量，可以及时回收内存



#### **「6.  使用性能更好的API」**

**1、用对选择器**

　　选择器的性能排序如下所示，尽量选择性能更好的选择器。

```
id选择器（#myid）
类选择器（.myclassname）
标签选择器（div,h1,p）
相邻选择器（h1+p）
子选择器（ul > li）
后代选择器（li a）
通配符选择器（*）
属性选择器（a[rel="external"]）
伪类选择器（a:hover,li:nth-child）
```

**2、使用requestAnimationFrame来替代setTimeout和setInterval**

　　希望在每一帧刚开始的时候对页面进行更改，目前只有使用 requestAnimationFrame 能够保证这一点。使用 setTimeout 或者 setInterval 来触发更新页面的函数，该函数可能在一帧的中间或者结束的时间点上调用，进而导致该帧后面需要进行的事情没有完成，引发丢帧。

**3、使用IntersectionObserver来实现图片可视区域的懒加载**

　　传统的做法中，需要使用scroll事件，并调用getBoundingClientRect方法，来实现可视区域的判断，即使使用了函数节流，也会造成页面回流。使用IntersectionObserver，则没有上述问题。

**4、使用web worker**

　　客户端javascript一个基本的特性是单线程：比如，浏览器无法同时运行两个事件处理程序，它也无法在一个事件处理程序运行的时候触发一个计时器。Web Worker是HTML5提供的一个javascript多线程解决方案，可以将一些大计算量的代码交由web Worker运行，从而避免阻塞用户界面，在执行复杂计算和数据处理时，这个API非常有用。

　　但是，使用一些新的API的同时，也要注意其浏览器兼容性。



#### **「7.  构建优化」**

**【打包公共代码】**

　　使用CommonsChunkPlugin插件，将公共模块拆出来，最终合成的文件能够在最开始的时候加载一次，便存到缓存中供后续使用。这会带来速度上的提升，因为浏览器会迅速将公共的代码从缓存中取出来，而不是每次访问一个新页面时，再去加载一个更大的文件

　　webpack 4 将移除 CommonsChunkPlugin, 取而代之的是两个新的配置项 optimization.splitChunks 和 optimization.runtimeChunk

　　通过设置 optimization.splitChunks.chunks: "all" 来启动默认的代码分割配置项

**【动态导入和按需加载】**

　　webpack提供了两种技术通过模块的内联函数调用来分离代码，优先选择的方式是，使用符合 ECMAScript 提案 的 import() 语法。第二种，则是使用 webpack 特定的 require.ensure

**【剔除无用代码】**

　　tree shaking 是一个术语，通常用于描述移除 JavaScript 上下文中的未引用代码(dead-code)。它依赖于 ES2015 模块系统中的静态结构特性，例如 import 和 export。这个术语和概念实际上是兴起于 ES2015 模块打包工具 rollup

　　JS的tree shaking主要通过uglifyjs插件来完成，CSS的tree shaking主要通过purify CSS来实现的

**【长缓存优化】**

　　1、将hash替换为chunkhash，这样当chunk不变时，缓存依然有效

　　2、使用Name而不是id

　　每个 module.id 会基于默认的解析顺序(resolve order)进行增量。也就是说，当解析顺序发生变化，ID 也会随之改变

　　下面来使用两个插件解决这个问题。第一个插件是 NamedModulesPlugin，将使用模块的路径，而不是数字标识符。虽然此插件有助于在开发过程中输出结果的可读性，然而执行时间会长一些。第二个选择是使用 HashedModuleIdsPlugin，推荐用于生产环境构建

**【公用代码内联】**

　　使用html-webpack-inline-chunk-plugin插件将mainfest.js内联到html文件中



## 2   深拷贝和浅拷贝的区别及手写

​		浅拷贝只是增加了一个指针指向已存在的内存地址，仅仅是指向被复制的内存地址，如果原地址发生改变，那么浅复制出来的对象也会相应的改变。深拷贝是增加了一个指针并且申请了一个新的内存，使这个增加的指针指向这个新的内存

​		浅拷贝可以使用列表自带的copy()函数（如list.copy()），或者使用copy模块的copy()函数。深拷贝只能使用copy模块的deepcopy(),所以使用前要导入：from copy import deepcopy

​		如果拷贝的对象里的元素只有值，没有引用，那浅拷贝和深拷贝没有差别，都会将原有对象复制一份，产生一个新对象，对新对象里的值进行修改不会影响原有对象，新对象和原对象完全分离开。
如果拷贝的对象里的元素包含引用（像一个列表里储存着另一个列表，存的就是另一个列表的引用），那浅拷贝和深拷贝是不同的，浅拷贝虽然将原有对象复制一份，但是依然保存的是引用，所以对新对象里的引用里的值进行修改，依然会改变原对象里的列表的值，新对象和原对象完全分离开并没有完全分离开。而深拷贝则不同，它会将原对象里的引用也新创建一个，即新建一个列表，然后放的是新列表的引用，这样就可以将新对象和原对象完全分离开。

```javascript
// 浅拷贝 shallowCopy
const isObject = (o) => typeof o === 'object' && o !== null;

const shallowCopy = (obj) => {
  if (!isObject(obj)) return obj;

  const res = Array.isArray(obj) ? [] : {};

  for (const key in obj) {
    if (obj.hasOwnProperty(key)) {
      const element = obj[key];
      res[key] = element;
    }
  }
  return res;
};
```

```javascript
// 深拷贝 deepCopy

const isObject = (o) => typeof o === 'object' && o !== null;

const deepCopy = (obj, weakmap = new WeakMap()) => {
  if (!isObject(obj)) return obj;
  // 解决循环引用， 防止无限遍历
  if (weakmap.get(obj)) return weakmap.get(obj);

  // 创建新对象存入weakmap
  const target = Array.isArray(obj) ? [] : {};
  weakmap.set(obj, target);

  // symbol拷贝
  const symArr = Object.getOwnPropertySymbols(obj);
  symArr.forEach((key) => {
    if (isObject(obj[key])) {
      target[key] = deepCopy(obj[key], weakmap);
    } else target[key] = obj[key];
  });

  // 对象的key
  for (const key in obj) {
    if (obj.hasOwnProperty(key)) {
      if (isObject(obj[key])) {
        target[key] = deepCopy(obj[key], weakmap);
      } else target[key] = obj[key];
    }
  }
  return target;
};
```



## 3   对象解构 ES6 以及箭头函数

​		解构赋值是一种表达式，允许您使用数组或对象，将可迭代对象的值或属性分配给变量。解构赋值能让我们用更简短的语法进行多个变量的赋值，大大的减少了代码量。解构表达式有两种：array和object。

​		对象解构赋值的键名对应很重要，不然会找不到。因为对象是无序的，必须通过键名来识别

#### 		「1. 箭头函数**」**

​		摘要：箭头函数有几个使用注意点。

​	（1）函数体内的`this`对象，就是定义时所在的对象，而不是使用时所在的对象，箭头函数继承而来的this指向永远不变。

​	（2）不可以当作构造函数，也就是说，不可以使用`new`命令，否则会抛出一个错误。

​	（3）不可以使用`arguments`对象，该对象在函数体内不存在。如果要用，可以用Rest参数代替。

​	（4）不可以使用`yield`命令，因此箭头函数不能用作Generator函数。

​	（5） 没有原型prototype

​		箭头函数没有自己的`this`，它会捕获自己在定义时（注意，是定义时，不是调用时）所处的外层执行环境的`this`，并继承这个`this`值。所以，箭头函数中`this`的指向在它被定义的时候就已经确定了，**之后永远不会改变**。

`		.call()`/`.apply()`/`.bind()`方法可以用来**动态修改函数执行时**`this`的指向，但由于箭头函数的`this`定义时就已经确定且永远不会改变。所以使用这些方法**永远也改变不了箭头函数`this`的指向**



#### 「2. 模板字符串」

模板字符串（template string）是增强版的字符串 用 反引号（`）标识，特点：

​	1.   字符串中可以出现换行符

​	2.   可以使用 ${xxx} 形式输出变量   // 注意：当遇到字符串与变量拼接的情况使用模板字符串



#### 「3. this指向问题」

![image.png](https://poetries1.gitee.io/img-repo/2020/07/2.png)

​		**情况1**：如果一个函数中有this，但是它没有被上一级的对象所调用，那么this指向的就是window，这里需要说明的是在js的严格版中this指向的不是window，但是我们这里不探讨严格版的问题，你想了解可以自行上网查找。

​		**情况2**：如果一个函数中有this，这个函数又被上一级的对象所调用，那么this指向的就是`上一级的对象`。

​		**情况3**：如果一个函数中有this，这个函数中**包含多个对象**，尽管这个函数是被最外层的对象所调用，**this指向的也只是它上一级的对象**。

​		this永远指向的是最后`调用它的对象`，也就是看它执行的时候是谁调用的

> **举例：**

```
// 例子1：
var o = {
    a:10,
    b:{
        // a:12,
        fn:function(){
            console.log(this.a); //undefined
        }
    }
}
o.b.fn();
```

```
// 例子2
var o = {
    a:10,
    b:{
        a:12,
        fn:function(){
            console.log(this.a); //undefined
            console.log(this); //window
        }
    }
}
var j = o.b.fn;
j();
```

​		例子2中虽然`函数fn`是被对象b所引用，但是在将`fn`赋值给`变量j`的时候并**没有执行**，所以最终指向的是window，这和例子1是不一样的，例子1是`直接执行了fn`。

> **`JavaScript---this的隐式丢失`**

隐式丢失就是指**隐式绑定的函数**丢失绑定对象，从而默认**绑定到全局或者undefined**（取决于是否使用严格模式）

**1、为函数调用创建别名**

```
function foo(){
  console.log(this.a);
}
var obj={
   a:2,
   foo:foo
}
var bar=obj.foo;
var a="window";
bar()//window
```

虽然bar是obj.foo的一个引用，但是bar引用的是**foo函数的本身**，此时的bar()其实就是一个不带任何修饰的函数调用，所以应用了默认绑定，this为全局

**2、传入回调函数**

```
function foo(){
   console.log(this.a);
}
function doFoo(fn){
   fn();
}
var obj={
   a:2,
   foo:foo
}
var a="window";
doFoo(obj.foo)//window
```

**参数传递其实就是隐式赋值**。相当于var fn=obj.foo，与创建别名的结果一样，应用了默认绑定，应该注意的是，return返回一个函数时，也是应用了默认绑定

**3、传入语言内置的函数**

```
function foo(){
   console.log(this.a);
}
var obj={
   a:2,
   foo:foo
}
var a="window";
setTimeout(obj.foo,100)//window
```

在JavaScript内部，内置函数`setTimeout`函数实现可以看作

```
function setTimeout(fn,delay){
   //等待delay毫秒
   fn();
}
```

同样属于**传参，应用默认绑定**


> **构造函数版`this`**

```
function Fn(){
    this.user = "追梦子";
}
var a = new Fn();
console.log(a.user); //追梦子
```

​		首先`new关键字`会创建一个`空的对象`，然后会自动调用一个函数`apply`方法，将this指向这个空对象，这样的话函数内部的this就会被这个空的对象替代。

​		这里之所以`对象a`可以点出`函数Fn`里面的`user`是因为**`new关键字`可以改变this的指向**，将这个this指向对象a，为什么我说a是对象，因为用了`new关键字`就是`创建一个对象实例`，理解这句话可以想想我们的例子1，我们这里用`变量a`创建了一个`Fn的实例`（相当于复制了一份Fn到对象a里面），此时仅仅**只是创建**，并**没有执行**，而调用这个函数Fn的是对象a，那么this指向的自然是对象a，那么为什么对象a中会有user，因为你已经复制了一份Fn函数到对象a中，用了new关键字就等同于复制了一份。

​		**`补充：`** **如果返回值return是一个对象，那么this指向的就是那个返回的对象，如果返回值不是一个对象那么this还是指向函数的实例。**



> **箭头函数体内的`this`对象**

​	  箭头函数体内的`this`对象，就是定义**该函数时所在的作用域指向的对象**，而不是使用时所在的作用域指向的对象。对于箭头函数，`this` 关键字指向的是它**当前周围作用域**（简单来说是**包含箭头函数**的常规函数，如果**没有常规函数的话就是全局对象**），这个行为和常规函数不同。

```
var name = 'window'; // 其实是window.name = 'window'

var A = {
   name: 'A',
   sayHello: function(){
      console.log(this.name)
   }
}

A.sayHello();// 输出A

var B = {
  name: 'B'
}

A.sayHello.call(B);// 输出B

A.sayHello.call();// 不传参数指向全局window对象，输出window.name也就是window
```



```
var name = 'window'; 

var A = {
   name: 'A',
   sayHello: () => {
      console.log(this.name)
   }
}

A.sayHello();// 还是以为输出A ? 错啦，其实输出的是window
```

​		一开始，我重点标注了“**该函数所在的作用域指向的对象**”，作用域是指函数内部，这里的箭头函数，也就是`sayHello`，所在的作用域其实是最外层的`js`环境，因为**没有其他函数包裹**；然后最外层的`js`环境指向的对象是`winodw对象`，所以这里的this指向的是`window对象`。

```
// 改造成永远指向 A 对象
var name = 'window'; 

var A = {
   name: 'A',
   sayHello: function(){
      var s = () => console.log(this.name)
      return s//返回箭头函数s
   }
}

var sayHello = A.sayHello();
sayHello();// 输出A 

var B = {
   name: 'B';
}

sayHello.call(B); //还是A
sayHello.call(); //还是A
```

1. **该函数所在的作用域：**箭头函数s 所在的作用域是`sayHello`,因为`sayHello`是一个函数。
2. 作用域指向的对象：`A.sayHello`指向的对象是A。

> **箭头函数this补充：**

1. 不可以当作构造函数，也就是说，不可以使用`new`命令，否则会抛出一个错误。
2. 不可以使用`arguments`对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。
3. 不可以使用`yield`命令，因此箭头函数不能用作 Generator 函数。



**改变this指向的方式：apply()、call()与bind()**

 `call` 方法可以指定this 的指向（即函数执行时所在的的作用域），然后再指定的作用域中，执行函数

 `  call` 方法的参数，应该是`对象obj`,如果`参数为空或null,undefind`,则默认传参`全局对象` 

`	call`方法的一个应用是调用对象的原生方法。

 `apply` 和`call` 作用类似，也是改变this 指向，然后调用该函数，唯一区别是apply 接收数组作为函数执行时的参数

`apply`方法的第一个参数也是`this`所要指向的那个对象，如果设为`null`或`undefined`，则等同于指定全局对象。

`bind` 用于将`函数体内的this`绑定到某个对象，然后返回一个新函数,`bind `接收的参数就是所要绑定的对象，如果`bind`方法的第一个参数是`null`或`undefined`，等于将`this`绑定到全局对象，函数运行时`this`指向顶层对象（浏览器为`window`）。

​		



**this指向面试题**

```jsx
//point对象中的x、y没有被改变，并结果中多了两个新的全局变量x,y，值都为1。根本原因是point对象下的moveTo方法中的moveX与moveX方法在调用时都是全局调用，绑定的对象都是window。

var point = { 
    x : 0, 
    y : 0, 
    moveTo : function(x, y) { 
       // 内部函数
       var moveX = function(x) { 
           this.x = x;
       }; 
       // 内部函数
       var moveY = function(y) { 
           this.y = y;
       };
       moveX(x); // 这里是全局调用
       moveY(y); 
    }; 
}; 
point.moveTo(1, 1); 
console.log(point.x); // 0
console.log(point.y); // 0
```



```
// 这种情况下moveX、moveY方法的调用时绑定在moveTo对象上的，因为moveTo对象一开始是没有x、y变量的，所以执行 this.x = x、this.y = y之后，相当于在moveTo对象中新建了两个变量。

var point = { 
         x : 0, 
         y : 0, 
         moveTo : { 
             // 内部函数
             moveX: function(x) {
                console.log(this) // {moveX: ƒ, moveY: ƒ}
                this.x = x;
             },
             // 内部函数
             moveY: function(y) { 
                this.y = y;
             }
         } 
    }; 
    point.moveTo.moveX(1); 
    point.moveTo.moveY(1);
    console.log(point.moveTo);  // {moveX: ƒ, moveY: ƒ, x: 1, y: 1}
    console.log(point.x); // 0
    console.log(point.y); // 0
    console.log(x) // x is not defined
    console.log(y) //
```













## 4  apply()、call()与bind()的概念

#### 「1.  call()方法」

**`call()` **方法使用一个指定的 `this` 值和单独给出的一个或多个参数来调用一个函数。

```
function.call(thisArg, arg1, arg2, ...)
```

`call()`方法的语法和作用与 `apply()` 方法类似，只有一个区别，就是 `call()` 方法接受的是**一个参数列表**，而 `apply()` 方法接受的是**一个包含多个参数的数组**。使用`call`方法，可以更改`this`指向的对象。



#### 「2.  apply()方法」

**`apply()`** 方法调用一个具有给定`this`值的函数，以及以一个数组（或[类数组对象](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Indexed_collections#working_with_array-like_objects)）的形式提供的参数。

```
func.apply(thisArg, [argsArray])
```

> **注意：**call()方法的作用和 apply() 方法类似，区别就是`call()`方法接受的是**参数列表**，而`apply()`方法接受的是**一个参数数组**。

`apply` 与 `call()`非常相似，不同之处在于提供参数的方式。`apply` 使用参数数组而不是一组参数列表。`apply` 可以使用数组字面量（array literal），如 `fun.apply(this, ['eat', 'bananas'])`，或数组对象， 如 `fun.apply(this, new Array('eat', 'bananas'))`。



#### 「3.  bind()方法」

**`bind()`** 方法创建一个新的函数，在 `bind()` 被调用时，这个新函数的 `this` 被指定为 `bind()` 的第一个参数，而其余参数将作为新函数的参数，供调用时使用。

```
function.bind(thisArg[, arg1[, arg2[, ...]]])

let copyfunc = func.bind(module)  // 需要有一个函数接收，因为会返回一个原函数的拷贝
```

**`返回值：`**返回一个原函数的拷贝，并拥有指定的 **`this`** 值和初始参数。



> `call()`和`bind()`的传参方式一样，但是`call()`会**直接调用**，`bind()`会作为一个**返回值**返回一个函数
>
> `call()`和`apply()`都是会调用函数，两者的区别就在于**传参方式不同**



`bind() `方法会创建一个新函数，当这个新函数被调用时，它的` this` 值是传递给` bind() `的第一个参数, 它的参数是 bind() 的其他参数和其原本的参数。

```
function.bind(thisArg[, arg1[, arg2[, ...]]])
```

- thisArg 当绑定函数被调用时，该参数会作为原函数运行时的 this 指向。当使用 new 操作符调用绑定函数时，该参数无效。

- arg1, arg2, … （可选）当绑定函数被调用时，这些参数加上绑定函数本身的参数会按照顺序作为原函数运行时的参数。

  **返回值**：返回一个原函数的拷贝，并拥有指定的 **`this`** 值和初始参数。 call方法调用

https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind

**bind应用：创建绑定函数**

​	`bind()` 最简单的用法是创建一个函数，不论怎么调用，这个函数都有同样的 **`this`** 值。JavaScript新手经常犯的一个错误是将一个方法从对象中拿出来，然后再调用，期望方法中的 `this` 是原来的对象（比如在回调中传入这个方法）。

```
this.x = 9;    // 在浏览器中，this 指向全局的 "window" 对象
var module = {
  x: 81,
  getX: function() { return this.x; }
};

module.getX(); // 81

var retrieveX = module.getX;
retrieveX();
// 返回 9 - 因为函数是在全局作用域中调用的

// 创建一个新函数，把 'this' 绑定到 module 对象
// 新手可能会将全局变量 x 与 module 的属性 x 混淆
var boundGetX = retrieveX.bind(module);
boundGetX(); // 81
```

**偏函数**

`bind()` 的另一个最简单的用法是使一个函数拥有预设的初始参数。只要将这些参数（如果有的话）作为 `bind()` 的参数写在 `this` 后面。当绑定函数被调用时，这些参数会被插入到目标函数的参数列表的开始位置，传递给绑定函数的参数会跟在它们后面。

```
function list() {
  return Array.prototype.slice.call(arguments);
}
function addArguments(arg1, arg2) {
    return arg1 + arg2
}
var list1 = list(1, 2, 3); // [1, 2, 3]
var result1 = addArguments(1, 2); // 3
// 创建一个函数，它拥有预设参数列表。
var leadingThirtysevenList = list.bind(null, 37);

// 创建一个函数，它拥有预设的第一个参数
var addThirtySeven = addArguments.bind(null, 37);
var list2 = leadingThirtysevenList();
// [37]
var list3 = leadingThirtysevenList(1, 2, 3);
// [37, 1, 2, 3]
var result2 = addThirtySeven(5);
// 37 + 5 = 42
var result3 = addThirtySeven(5, 10);
// 37 + 5 = 42 ，第二个参数被忽略
```

​	





## 5   web安全及攻击方式

#### **「跨站请求伪造CSRF(XSRF)」**

​	 （Cross-site request forgery），通常缩写为 **「CSRF」**或者 **「XSRF」**，是一种挟制用户在当前已登录的 Web 应用程序上执行非本意的操作的攻击方法。跨站请求攻击，简单地说，是攻击者通过一些技术手段欺骗用户的浏览器去访问一个**自己曾经认证过的网站**并运行一些操作（如发邮件，发消息，甚至财产操作如转账和购买商品）。由于浏览器曾经认证过，所以被访问的网站会认为是真正的用户操作而去运行。

#### 「CSRF防御措施」

**检查 Referer 字段：**

​	HTTP 头中有一个 Referer 字段，这个字段用以标明请求来源于哪个地址。 **「在处理敏感数据请求时，通常来说，Referer 字段应和请求的地址位于同一域名下」**。

**同步表单 CSRF 校验：**

​	就是在返回页面时将 token 渲染到页面上，在 form 表单提交的时候通过隐藏域或者作为查询参数把 CSRF token 提交到服务器。比如，在同步渲染页面时，在表单请求中增加一个 _csrf 的查询参数，这样当用户在提交这个表单的时候就会将 CSRF token 提交上来：

**双重 Cookie 防御：**

​	就是将 token 设置在 Cookie 中，在提交（POST、PUT、PATCH、DELETE）等请求时提交 Cookie，并通过请求头或请求体带上 Cookie 中已设置的 token，服务端接收到请求后，再进行对比校验。

**axios CSRF 防御：**

​	axios 提供了 xsrfCookieName 和 xsrfHeaderName 两个属性来分别设置 CSRF 的 Cookie 名称和 HTTP 请求头的名称，原来 axios 内部是使用 **「双重 Cookie 防御」**的方案来防御 CSRF 攻击。



#### 「XSS攻击」

**`跨站脚本攻击（Cross-Site Scripting，XSS）`**是指通过存在安全漏洞的Web 网站注册用户的浏览器内运行非法的 HTML 标签或 JavaScript 进行的一种攻击。比如：攻击者在论坛中放一个看似安全的链接，骗取用户点击后，窃取`cookie`中的用户私密信息；或者攻击者在论坛中加一个恶意表单，当用户提交表单的时候，却把信息传送到攻击者的服务器中，而不是用户原本以为的信任站点。

> **攻击方式：反射型和存储型**

**反射型攻击：**发出请求时，XSS代码出现在URL中，作为输入提交到服务器端，服务器解析后响应，XSS代码随响应内容一起传回给浏览器，最后浏览器解析执行XSS代码。这个过程像一次反射，故叫反射型XSS。

**存储型攻击：**存储型XSS和反射型XSS的差别仅在于，提交的代码会存储在服务器端（数据库，内存，文件系统等），下次请求目标页面时不用再提交XSS代码。更加隐蔽。

> **XSS攻击注入点：**

- HTML节点内，通过用户输入动态生成
- HTML属性，属性是由用户输入
- ![img](https://images2018.cnblogs.com/blog/315302/201809/315302-20180913113747224-407021631.png)
- ![img](https://images2018.cnblogs.com/blog/315302/201809/315302-20180913113831154-1437600456.png)
- JavaScript代码

![img](https://images2018.cnblogs.com/blog/315302/201809/315302-20180913114538356-1927804731.png)

- 富文本（一大段HTML，有格式）
  - 　　富文本得保留HTML，HTML有XSS攻击风险

> **xss防御方式**：**`浏览器自带防御、CSP、编码转义(黑白名单)、过滤、HttpOnly Cookie`**

**1、浏览器自带防御**

ctx.set('X-Xss-Protection',0); 反射型参数出现在HTML内容或属性中。

0 禁止XSS过滤。

1 启用XSS过滤（通常浏览器是默认的）。 如果检测到跨站脚本攻击，浏览器将清除页面（删除 不安全的部分）。
1;mode=block 启用XSS过滤。 如果检测到攻击，浏览器将不会清除页面，而是阻止页面加载。

1; report= (Chromium only) 启用XSS过滤。 如果检测到跨站脚本攻击，浏览器将清除页面并使用CSP report-uri 指令的功能 发送违规报告。

ctx.set('X-Xss-Protection',0)在chrome浏览器中已经失效了。可以用CSP。

**2、CSP**

CSP: [Content Security Policy ](https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP)

 内容安全策略 (CSP, Content Security Policy) 是一个附加的安全层，用于帮助检测和缓解某 些类型的攻击，包括跨站脚本 (XSS) 和数据注入等攻击。 这些攻击可用于实现从数据窃取到 网站破坏或作为恶意软件分发版本等用途。

CSP 本质上就是建立白名单，开发者明确告诉浏览器哪些外部资源可以加载和执行。我们只 需要配置规则，**如何拦截是由浏览器自己实现的**。我们可以通过这种方式来尽量减少 XSS 攻 击。

```
// 只允许加载本站资源 Content-Security-Policy: default-src 'self'
// 只允许加载 HTTPS 协议图片 Content-Security-Policy: img-src https://*
// 不允许加载任何来源框架 Content-Security-Policy: child-src 'none'
```



**3、编码转义**

​		**1  黑名单**

用户的输入永远是不可信任的，不能让所有用户输入保持原样。

对用户输入的数据进行HTML Entity编码。最普遍的做法就是转义输入输出的内容，对于引号、尖括号、斜杠 进行转义。

![img](https://images2018.cnblogs.com/blog/315302/201809/315302-20180912091822660-717626938.png)

```
 function escape(str) {    
str = str.replace(/&/g, '&amp;')    
str = str.replace(/</g, '&lt;')    
str = str.replace(/>/g, '&gt;')    
str = str.replace(/"/g, '&quto;')    
str = str.replace(/'/g, '&#39;')    
str = str.replace(/`/g, '&#96;')    
str = str.replace(/\//g, '&#x2F;')    
return str  }
```

用转义字符代替字符。

![img](https://images2018.cnblogs.com/blog/315302/201809/315302-20180913115910821-280661201.png)

转义的时机

- 存储时
- 显示时

ejs转义

```
<% code %>用于执行其中javascript代码； 
<%= code %>会对code进行html转义； 
<%- code %>将不会进行转义
```

黑名单错杀的太多。 

​		**2  白名单**

​		富文本来说，显然不能通过上面的办法来转义所有字符，因为这样会把需要的格式也过滤掉。对 于这种情况，通常采用白名单过滤的办法，当然也可以通过黑名单过滤，但是考虑到需要过滤的 标签和标签属性实在太多，更加推荐使用白名单的方式。

白名单库：xss库

```
const xss = require('xss')  let html = xss('<h1 id="title">XSS Demo</h1><script>alert("xss");</script>')  
// -> <h1>XSS Demo</h1>&lt;script&gt;alert("xss");&lt;/script&gt;  console.log(html)
```

**4、过滤**

编码后显示时候还要解码。解码后显示原样代码前过滤。

过滤掉不合法输入，保证安全。

- 移除用户上传的DOM属性，如onerror等。
- 移除用户上传的Style节点，Script节点，Iframe节点等。 

onerror自动触发xss。 

style:body:display:none.

js对页面有百分比操作权限。

iframe引入其它页面资源。

通过xss注入的方式，引诱用户触发csrf攻击。

**5  HttpOnly Cookie**

这是预防XSS攻击窃取用户cookie最有效的防御手段。Web应用程序在设置cookie时，将其属性设为HttpOnly，就可以避免该网页的cookie被客户端恶意JavaScript窃取，保护用户 cookie信息。

```
response.addHeader("Set-Cookie", "uid=112; Path=/; HttpOnly")
```

​		通过js脚本将无法读取到cookie信息，这样能有效的防止XSS攻击











#### 「其他攻击方式」

**`SQL注入（SQL Injection）`**是指针对 Web 应用使用的数据库，通过运行非法的 SQL 而产生的攻击。

**`OS 命令注入攻击（OS Command Injection）`**是指通过 Web 应用，执行非法的操作系统命令达到攻击的目的。只要在能调用 Shell 函数的地方就有存在被攻击的风险

**`HTTP 首部注入攻击（HTTP Header Injection）`**是指攻击者通过在响应首部字段内插入换行，添加任意响应首部或主体的一种攻击。属于被动攻击模式。

**`邮件首部注入（Mail Header Injection）`**是指 Web 应用中的邮件发送功能，攻击者通过向邮件首部 To 或 Subject 内任意添加非法内容发起的攻击。

**`目录遍历（Directory Traversal）`**攻击是指对本无意公开的文件目录，通过非法截断其目录路径后，达成访问目的的一种攻击。这种攻击有时也称为路径遍历（Path Traversal）攻击。

**`远程文件包含漏洞（Remote File Inclusion）`**是指当部分脚本内容需要从其他文件读入时，攻击者利用指定外部服务器的 URL 充当依赖文件，让脚本读取之后，就可运行任意脚本的一种攻击。









## 6   Vue的相关使用知识

#### 	「Vue的MVVM模型」

​		MVVM 是`Model-View-ViewModel `的缩写，它是一种基于前端开发的架构模式，其核心是提供对`View` 和 `ViewModel` 的双向数据绑定，这使得`ViewModel` 的状态改变可以自动传递给 View，即所谓的数据双向绑定。Model 层代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑；View 代表UI 组件，它负责将数据模型转化成UI 展现出来，`ViewModel `是一个同步View 和 Model的对象。在MVVM架构下，View 和 Model 之间并没有直接的联系，而是通过`ViewModel`进行交互，Model 和 `ViewModel` 之间的交互是双向的， 因此View 数据的变化会同步到Model中，而Model 数据的变化也会立即反应到View 上。

　　Vue.js 是一个提供了 MVVM 风格的双向数据绑定的 Javascript 库，专注于View 层。它的核心是 MVVM 中的 VM，也就是 ViewModel。 ViewModel负责连接 View 和 Model，保证视图和数据的一致性，这种轻量级的架构让前端开发更加高效、便捷。

#### 	「Vue的 mounted组件、methods方法、computed属性」

​		不同的钩子函数

​		`created:html`  加载完成之前，执行。执行顺序:父组件-子组件
​		`mounted:html ` 加载完成后执行。处于发起后端请求，获取数据，配合路由钩子执行操作（DOM渲染完成，组件挂载完成 ）执行顺序:子组件-父组件
​		`methods`:  事件方法执行。
​		`watch`:  去监听一个值的变化，然后执行相对应的函数。
​		`computed`:computed  是计算属性，也就是依赖其它的属性计算所得出最后的值

	export default {
	 name: "draw",
	 data(){      //定义变量source        
	   return {
	     source:new ol.source.Vector({wrapX: false}),
	   }
	 },
	props:{ //接收父组件传递过来的参数
	  map:{
	    //type:String
	  },
	},
	mounted(){   //页面初始化方法，在模板渲染成html后调用，通常是初始化页面完成后，再对html的dom节点进行一些需要的操作
		if (map==map){
		}
		var vector = new ol.layer.Vector({
		  source: this.source
		});
		this.map.addLayer(vector);
	},
	watch: {   //监听值变化:map值
		map:function () {
		  console.log('3333'+this.map);
		  //return this.map
		  console.log('444444'+this.map);
	
		  var vector = new ol.layer.Vector({
			source: this.source
		  });
		  this.map.addLayer(vector);
		}
	},
	//计算过后，如返回值不变则直接返回缓存
	computed: {  //computed 是计算属性，也可以理解为一个方法。其中计算的结果如果不发生改变就不会触发，且必须返回一个值并在DOM中绑定的才能取得值。他可以自动获取数据的改变。
	    reversedMessage() {
	      // `this` 指向 vm 实例
	      return this.xxx
	    }
	  }
	
	methods:{   //监听方法click事件等，执行drawFeatures方法
	   drawFeatures:function(drawType){}
	}
	}
#### 	「Vue的生命周期」

![image-20210828152017744](https://gitee.com/wexia/my_pic_bed/raw/master/pics/20210915114654.png)

​		Vue实例有一个完整的生命周期，也就是从**开始创建、初始化数据、编译模板、挂载Dom、渲染→更新→渲染、销毁**等一系列过程，我们称这是Vue的生命周期。通俗说就是Vue实例从创建到销毁的过程，就是生命周期。总共分为8个阶段如下所示：

​		一、创建前/后：
​		① `beforeCreate`阶段，实例的挂载元素el和数据对象data都为undefined，未初始化。
​		② ` created`阶段，vue实例的数据对象data有了，el为undefined，未初始化。
​		二、载入前/后：
​		③ `beforeMount`阶段，vue实例的$el和data都初始化了，但还是挂载之前为虚拟的dom节点，data.message还未替换。
​		④ `mounted`阶段，vue实例挂载完成，data渲染成功。
​		三、更新前/后：当data变化时，会触发
​		⑤ `beforeUpdate`和⑥ `updated`方法
​		四、销毁前/后：
​		⑦ `beforeDestroy `销毁前
​		⑧ `destroy` 销毁执行后，对data的改变不会再触发周期函数，此时vue实例已经解除了事件监听以及和dom的绑定，但是dom结构依然存在



##### Vue异步请求放在哪个生命周期里调用：

**得看实际情况；**

一般在 **`created`** 里面就可以，如果涉及到需要**页面加载完成之后的操作**话就用` mounted`；

`created `阶段的优势是：请求时间比较早，页面 loading 时间相对较短；

`mounted` 阶段的优势是：页面已经渲染完成，如果想请求之后进行 DOM 操作的话，必须在 mounted 阶段发起请求



#### 「Vuex的相关知识」

​		vuex是一种对vue 应用中多个组件的共享状态进行集中式的管理(读/写)；

> **vuex的工作原理**：

https://segmentfault.com/a/1190000021717329

​	`	vuex 核心概念和API：state、mutations、actions、getters、modules、向外暴露store对象`

![vuex](https://vuex.vuejs.org/vuex.png)

`state`

```
state
1) vuex 管理的状态对象
2) 它应该是唯一的
  const state = {
	xxx: initValue
}
```

`mutations`

```
mutations
1) 包含多个直接更新state 的方法(回调函数)的对象
2) 谁来触发: action 中的commit('mutation 名称')
3) 只能包含同步的代码, 不能写异步代码
	const mutations = {	
		yyy (state, {data1}) {
		// 更新state 的某个属性
		}
	}
```

`actions`

```
actions
1) 包含多个事件回调函数的对象
2) 通过执行: commit()来触发mutation 的调用, 间接更新state
3) 谁来触发: 组件中: $store.dispatch('action 名称', data1) // 'zzz'
4) 可以包含异步代码(定时器, ajax)
	const actions = {
		zzz ({commit, state}, data1) {
			commit('yyy', {data1})
		}
	}
```

`getters`

```
getters
1) 包含多个计算属性(get)的对象
2) 谁来读取: 组件中: $store.getters.xxx
	const getters = {
		mmm (state) {
		return ...
		}
	}
```

```
modules
1) 包含多个module
2) 一个module 是一个store 的配置对象
3) 与一个组件(包含有共享数据)对应
```

**向外暴露store 对象**

```
export default new Vuex.Store({
	state,
	mutations,
	actions,
	getters
})
```

> `在组件中的使用：`

```
import {mapState, mapGetters, mapActions} from 'vuex'
export default {
	computed: {
		...mapState(['xxx']),
		...mapGetters(['mmm']),
	}
	methods: mapActions(['zzz'])
}

{{xxx}} {{mmm}} @click="zzz(data)"
```

```
映射store
import store from './store'
new Vue({
	store
})

store 对象
1) 所有用vuex 管理的组件中都多了一个属性$store, 它就是一个store 对象
2) 属性:
	state: 注册的state 对象
	getters: 注册的getters 对象
3) 方法:
	dispatch(actionName, data): 分发调用action
```

​	![image-20210526142127906](https://gitee.com/wexia/my_pic_bed/raw/master/pics/image-20210526142127906.png)

##### mapMutations:

`mapMutations`是`vuex`的`mutation`的辅助函数，用于在组件中映射`mutation`内的方法，以便在该组件中直接使用`mutation`里的方法

**1.在组件中导入vuex中的mapMutations:**

```javascript
import { mapMutations } from ‘vuex‘
```

**2.在组件中导入mutation里的方法名：**

```javascript
...mapMutations([   //使用es6的拓展运算符
        ‘INCREASE_SHOPCART‘,   
        ‘DECREASE_SHOPCART‘   
      ]) 
//约定将mutation里的方法名为大写，并且导入时要给其加上引号
```

这一步，是将mutation里的函数映射到组件里，在组件里 ：

```javascript
this.INCREASE_SHOPCART === this.$store.commit(‘INCREASE_SHOPCART‘) //true
```

在有参数的情况下，mutation的state默认参数可以省略 ：

```javascript
this.INCREASE_SHOPCART(id) === this.$store.commit(‘INCREASE_SHOPCART‘,id) //true
```

**举例说明：**

```
// mutation-type.js
// 是否登录
export const SET_LOGINSTATU = 'SET_LOGINSTATU'

// 获取用户信息
export const SET_USERINFO = 'SET_USERINFO'
```

```
// mutatios.js
const mutations = {
  // 是否登录
  [types.SET_LOGINSTATU](state, loginStatu) {
    state.loginStatu = loginStatu
  },

  // 获取用户信息
  [types.SET_USERINFO](state, userInfo) {
    state.userInfo = userInfo
  },
```

```
import { mapMutations } from 'vuex'
```

```
this.setUserInfo(res.profile)
this.setLoginStatu(true)
```

```
...mapMutations({
  setUserInfo: 'SET_USERINFO',   // 相当于把 mutation里面的SET_USERINFO 映射成setUserInfo，使得能在该组件中用this.setUserInfo来调用SET_USERINFO
  setLoginStatu: 'SET_LOGINSTATU'
})
```

**mapActions：**

```js
import { mapActions } from 'vuex'

export default {
  // ...
  methods: {
    ...mapActions([
      'increment', // 将 `this.increment()` 映射为 `this.$store.dispatch('increment')`

      // `mapActions` 也支持载荷：
      'incrementBy' // 将 `this.incrementBy(amount)` 映射为 `this.$store.dispatch('incrementBy', amount)`
    ]),
    ...mapActions({
      add: 'increment' // 将 `this.add()` 映射为 `this.$store.dispatch('increment')`
    })
  }
}
```

**mapGetters：**

```js
import { mapGetters } from 'vuex'

export default {
  // ...
  computed: {
  // 使用对象展开运算符将 getter 混入 computed 对象中
    ...mapGetters([
      'doneTodosCount',
      'anotherGetter',
      // ...
    ])
  }
}

//如果你想将一个 getter 属性另取一个名字，使用对象形式：
...mapGetters({
  // 把 `this.doneCount` 映射为 `this.$store.getters.doneTodosCount`
  doneCount: 'doneTodosCount'
})
```

**mapState：**

```js
import { mapState } from 'vuex'

export default {
  // ...
  computed: mapState({
    // 箭头函数可使代码更简练
    count: state => state.count,

    // 传字符串参数 'count' 等同于 `state => state.count`
    countAlias: 'count',

    // 为了能够使用 `this` 获取局部状态，必须使用常规函数
    countPlusLocalState (state) {
      return state.count + this.localCount
    }
  })
}
```





#### 「render函数」

- **类型**：`(createElement: () => VNode) => VNode`

- **详细**：

  **字符串模板的代替方案**，允许你发挥 JavaScript 最大的编程能力。该渲染函数接收一个 `createElement` 方法作为第一个参数用来创建 `VNode`。

  如果组件是一个函数组件，渲染函数还会接收一个额外的 `context` 参数，为没有实例的函数组件提供上下文信息。

#### 「computed、methods、watch，mounted的区别」

​	**computed：是计算属性**。computed是在HTML DOM加载后马上执行的，如赋值；

​	**methods：  是Vue实例对象上绑定的方法**，供当前Vue组件作用域内使用，未调用不会执行。methods必须要有一定的触发条件才能执行，如点击事件。

​	**watch监听： 是一个对象**，键是要观察的数据，值可以是对应的回调函数，也可以是方法名，或者包含选项的对象，在工作中，我一般是用回调，观察某个数据的变化。 对于watched 属性 监听 需要自己手动去写监听的值 会大大的浪费一定性能去做监听这种事情 不像computed是自动的。

​	**mounted： 是生命周期方法之一**，会在对应生命周期时执行。mounted是vue中的一个钩子函数，一般在初始化页面完成后，再对dom节点进行相关操作。

 **created和mounted区别？**

​		created:在模板渲染成html前调用，即通常初始化某些属性值，然后再渲染成视图。

​		mounted:在模板渲染成html后调用，通常是初始化页面完成后，再对html的dom节点进行一些需要的操作。



#### 「 v-for及 key 的作用」

我们可以用 `v-for` 指令基于一个数组来渲染一个列表。`v-for` 指令需要使用 `item in items` 形式的特殊语法，其中 `items` 是源数据数组，而 `item` 则是被迭代的数组元素的**别名**

**示例1：**

```
<ul id="example-1">
  <li v-for="item in items" :key="item.message">
    {{ item.message }}
  </li>
</ul>
```

```
var example1 = new Vue({
  el: '#example-1',
  data: {
    items: [
      { message: 'Foo' },
      { message: 'Bar' }
    ]
  }
})
```

在 `v-for` 块中，我们可以访问所有父作用域的 property。`v-for` 还支持一个可选的第二个参数，即当前项的索引。

为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个**唯一** `key` attribute：

```
<div v-for="item in items" v-bind:key="item.id">
  <!-- 内容 -->
</div>
```

**`v-for` 与 `v-if` 一同使用**

```
<ul v-if="todos.length">
  <li v-for="todo in todos">
    {{ todo }}
  </li>
</ul>
<p v-else>No todos left!</p>
```

**在组件上使用v-for**

2.2.0+ 的版本里，当在组件上使用 `v-for` 时，`key` 现在是必须的。

```
<my-component v-for="item in items" :key="item.id"></my-component>
```

然而，任何数据都**不会被自动传递**到组件里，因为组件有自己独立的作用域。为了把迭代数据传递到组件里，我们要使用 prop：

在el-table强制数据绑定到数据源上之后，在el-table里面利用自定义插槽传输数据

```
<el-table :data="rolesList" style="width: 100%" border stripe>
        <el-table-column type="expand">
          <template v-slot:default ="scope">
            <el-row v-for="(item1 ,i1) in scope.row.children" :key="item1.id" >
```

##### key的作用

**key值大多情况下使用在循环语句中，从本质来讲主要作用大概有以下两点：**

1. 主要用在 Vue 的虚拟 DOM 算法，在新旧 nodes 对比时辨识 VNodes，相当于唯一标识ID。
2. Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染， 因此使用key值可以提高渲染效率，同理，改变某一元素的key值会使该元素重新被渲染。

​		key值是在DOM树进行diff算法时候发挥作用。一个是用来判断新旧Vnode是否为同一个，从而进行下一步的比较以及渲染。另外一个作用就是判断组件是否可以复用，是否需要重新渲染。

**`这里可以深度讲一下vue的 diff 算法的亮点`**



#### 「import 和 require 区别」

##### require的基本语法

​	核心概念：在导出的文件中定义module.export,导出的对象的类型不予限定（可以是任何类型，字符串，变量，对象，方法），在引入的文件中调用require()方法引入对象即可。

​	require的使用非常简单，它相当于module.exports的传送门，module.exports后面的内容是什么，require的结果就是什么，对象、数字、字符串、函数……再把require的结果赋值给某个变量，相当于把require和module.exports进行平行空间的位置重叠

```
//a.js中
module.export = {
    a: function(){
     console.log(666)
  }
}
```

```
//b.js中
var obj = require('../a.js')
obj.a()  //666
```

【注】:本质上是将要导出的对象赋值给module这个的对象的export属性，在其他文件中通过require这个方法访问该属性

```
引入：

require('./a')(); // a模块是一个函数，立即执行a模块函数

var data = require('./a').data; // a模块导出的是一个对象

var a = require('./a')[0]; // a模块导出的是一个数组

在vue的js引入图片，就需要使用require（“路径”）进来
```



##### import的基本语法

核心概念：导出的对象必须与模块中的值一一对应，换一种说法就是**导出的对象与整个模块进行解构赋值**。对的，你没有听错。抓住重点，解构赋值！！！！

```
//a.js中
export default{    //（最常使用的方法,加入default关键字代表在import时可以使用任意变量名并且不需要花括号{}）
     a: function(){
         console.log(666)
   }
} 
export function(){  //导出函数
}
export {newA as a ,b,c}  //  解构赋值语法(as关键字在这里表示将newA作为a的数据接口暴露给外部，外部不能直接访问a)
 
//b.js中
import  a  from  '...'  //import常用语法（需要export中带有default关键字）可以任意指定import的名称
 
import {...} from '...'  // 基本方式，导入的对象需要与export对象进行解构赋值。
 
import a as biubiubiu from '...'  //使用as关键字，这里表示将a代表biubiubiu引入（当变量名称有冲突时可以使用这种方式解决冲突）
 
import {a as biubiubiu,b,c}  //as关键字的其他使用方法
```

**它们之间的区别**

- require 是`赋值过程并且是运行时才执行`， import 是`解构过程并且是编译时执行`。require可以理解为一个全局方法，所以它甚至可以进行下面这样的骚操作，是一个方法就意味着`可以在任何地方执行`。而import必须写在`文件的顶部`。

```
var a = require(a() + '/ab.js')
```

- require的性能相对于import稍低，因为require是在`运行时`才引入模块并且还`赋值给某个变量`，而import只需要依据import中的接口在编译时`引入指定模块`所以性能稍高

- 在commom.js 中module.export 之后 导出的值就不能再变化，但是在es6的export中是可以的。

```
var a = 6
export default {a}
a = 7  //在es6中的export可以
```

```
var a = 6
module.export = a
a = 7   //在common.js中，这样是错误的
```



#### 「router.beforeEach()」

​	router.beforeEach（）一般用来做一些进入页面的限制。比如没有登录，就不能进入某些页面，只有登录了之后才有权限查看某些页面。。。说白了就是**路由拦截**。

**第一步 规定进入路由需不需要权限**

```
 @/router/index.js
 import A from '@/components/a'
{
     path: '/a',
     name: 'a',
     component:	A,
     meta : {                      //加一个自定义obj
   			requireAuth:true      //这个参数 true 代表需要登录才能进入A
     }
   },

```

**第二步 使用vuex整一个userId**

```
@/assets/store.js
//使用vuex三步走
import Vue from 'vue'
import Vuex from 'vuex'
Vue.use(Vuex)
//这个理论来说
const store = new Vuex.Store({
	state:{
		userId : ''
	}
})

export default store

```

**第三步 使用router.beforeEach()**

```
@/main.js
思路：【
	如果（即将进入的这个路由需要权限才能进入）{
	
		如果(能获取到这个老哥的userID){
			就让这个老哥进入这个路由
		}否则{
			就让这个老哥进入b这个页面
		}
		
	} 即将进入的路由不需要权限就能进入 {
	
		就让这个老哥进入这个路由
		
	}】

对应代码：
import store from '@/assets/store'   //把这个userId获取过来
router.beforeEach((to,from,next)=>{
	if(to.meta.requireAuth){
		if(store.state.userId){
			next()
		}else{
			next({path:'/b'})
		}
	}else{
		next()
	}
})

```

**第四步**

```
第三步这个/b路由其实就是登陆页面，
当进入A页面之前，需要请求接口，获取一下是否有登陆过，然后把这个userId存在vuex的state里。
当没有userId时，则在登陆之后，存一个userId到state里。然后就敲完收工
```

`延申：router的beforeEach与afterEach钩子函数`

在路由跳转的时候，我们需要一些权限判断或者其他操作。这个时候就需要使用路由的钩子函数。

两种函数：

​	1、Vue.beforeEach(function(to,form,next){})   /*在跳转之前执行*/

	2.    Vue.afterEach(function(to,form))            /*在跳转之后判断*/



#### 「vue2与vue3的区别」

> **1. vue2和vue3双向数据绑定原理发生了改变**

​		**vue2** 的双向数据绑定是利用ES5 的一个 API `Object.defineProperty()`对数据进行劫持 结合 发布订阅模式的方式来实现的。

​		**vue3** 中使用了 es6 的 `Proxy`API 对数据代理。

> **2.   默认进行懒观察（lazy observation）。**

​		在 2.x 版本里，不管数据多大，都会在一开始就为其创建观察者。当数据很大时，这可能会在页面载入时造成明显的性能压力。3.x 版本，只会对「被用于渲染初始可见部分的数据」创建观察者，而且 3.x 的观察者更高效。

> **3.   更精准的变更通知。**

比例来说：2.x 版本中，使用 Vue.set 来给对象新增一个属性时，这个对象的所有 watcher 都会重新运行；3.x 版本中，只有依赖那个属性的 watcher 才会重新运行。

> **4.  3.0 新加入了 TypeScript 以及 PWA 的支持**

> **5.  vue2和vue3组件发送改变**



#### 「Vue中对SSR的理解」

SSR也就是服务端渲染，也就是将Vue在客户端把标签渲染成HTML的工作放在服务端完成，然后再把html直接返回给客户端

SSR的优势：

- 更好的SEO
- 首屏加载速度更快

SSR的缺点：

- 开发条件会受到限制，服务器端渲染只支持beforeCreate和created两个钩子；
- 当需要一些外部扩展库时需要特殊处理，服务端渲染应用程序也需要处于Node.js的运行环境；
- 更多的服务端负载。



#### 「v-if和v-show的区别」

​	(1)、`v-if`和`v-show`用于**视图层**进行条件判断视图展示

​	(2)、`v-if`的原理是**根据判断条件来动态的进行增删DOM元素**，`v-show`是**根据判断条件来动态的进行显示和隐藏元素**，频繁的进行增删DOM操作会影响页面加载速度和性能，由此我们可以得出结论：

　 当您的项目程序不是很大的时候，`v-if`和`v-show`都可以用来进行判断展示和隐藏（这种场景使用`v-if`只是影响不大，并不是没有影响）；

​		当您的项目程序比较大的时候，不推荐使用`v-if`来进行判断展示和隐藏，推荐使用`v-show`；

​	(3)、**只有`v-if`能和`v-else`连用进行分支判断**，`v-show`是不能和`v-else`连用的，如果出现多种条件场景的情况下，可以使用v-if来进行判断



#### 「vue组件化的理解」

1:组件是独立和可复用的代码组织单元，组件系统是Vue核心特性之一，它使开发者使用小型、独立和通常可复用的组件构建大型应用

2:组件化开发能大幅提高应用开发效率、测试性、复用性

3:组件使用按分类有：页面组件、业务组件、通用组件

4:vue的组件是基于配置的，我们通常编写的组件是组件配置而非组件，框架后续会生成其构造函数，它们基于VueComponent，扩展于Vue

5:vue中常见组件化技术有：属性prop、自定义事件、插槽等、它们主要用于组件通信、扩展等

6:合理的划分组件、有助于提高应用性能

7:组件应该是高内聚、低耦合的

8:遵循单项数据流的原则





#### 「子组件不能直接改变父组件数据---单向数据流」

单向数据流（Unidirectional data flow）方式使用一个上传数据流和一个下传数据流进行双向数据通信，两个数据流之间相互独立。单向数据流指只能从一个方向来修改状态。下图是单向数据流的极简示意：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190601100610799.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2Nzc4OA==,size_16,color_FFFFFF,t_70)

​		与单向数据流对对应的是双向数据流（也叫双向绑定）。在双向数据流中，Model（可以理解为状态的集合） 中可以修改自己或其他Model的状态， 用户的操作（如在输入框中输入内容）也可以修改状态。这使改变一个状态有可能会触发一连串的状态的变化，最后很难预测最终的状态是什么样的。



Vue提倡单向数据流，即父级 props 的更新会流向子组件，但是反过来则不行。这是为了防止意外的改变父组件状态，使得应用的数据流变得难以理解，导致数据流混乱。如果破坏了单向数据流，当应用复杂时，debug 的成本会非常高。

**只能通过 \**`$emit`\** 派发一个自定义事件，父组件接收到后，由父组件修改。**







#### 「vue计算属性computed和侦听属性watch的区别」

> **使用场景区分**

- computed用来监控自己定义的变量，该变量不在data里面声明，直接在computed里面定义，然后就可以在页面上进行双向数据绑定展示出结果或者用作其他处理；
- computed比较适合对多个变量或者对象进行处理后返回一个结果值，也就是说多个变量中的某一个值发生了变化则我们监控的这个值也就会发生变化，举例：购物车里面的商品列表和总金额之间的关系，只要商品列表里面的商品数量发生变化，或减少或增多或删除商品，总金额都应该发生变化。这里的这个总金额使用computed属性来进行计算是最好的选择

- watch主要用于监控vue实例的变化，它监控的变量当然必须在data里面声明才可以，它可以监控一个变量，也可以是一个对象，示例：

- ```
  data(){
  　　return {
  　　　　example0:"",
  　　　　example1:"",
  　　　　example2:{
   　　　　　inner0:1, 　　　　　　　　　
            innner1:2 　　　　　　　　　
             }
  　　　}
  　　},
  watch:{
  　example0(newVal,oldVal){//监控单个变量
             ……
   }，example2(newVal,oldVal){//监控对象
             ……
   }，
  }
  ```

- watch一般用于监控路由、input输入框的值特殊处理等等，它比较适合的场景是一个数据影响多个数据

![image-20211009205735886](https://gitee.com/wexia/my_pic_bed/raw/master/pics/20211009205737.png)



> **computed：通过属性计算而得来的属性**

1、computed内部的函数在调用时不加()。

2、computed是依赖vm中data的属性变化而变化的，当data中的属性发生改变的时候，当前函数才会执行，data中的属性没有改变的时候，当前函数不会执行。

3、computed中的函数**必须用return返回**。

4、在computed中不要对data中的属性进行赋值操作。如果对data中的属性进行赋值操作了，就是data中的属性发生改变，从而触发computed中的函数，形成死循环了。

5、当computed中的函数所依赖的属性没有发生改变，那么调用当前函数的时候会从缓存中读取。**计算属性是基于它们的响应式依赖进行缓存的**。只在相关响应式依赖发生改变时它们才会重新求值

> **watch：属性监听**

1、watch中的函数名称必须要和data中的属性名一致，因为watch是依赖data中的属性，当data中的属性发生改变的时候，watch中的函数就会执行。
2、watch中的函数**有两个参数，前者是newVal，后者是oldVal**。

3、watch中的函数是不需要调用的。

4、watch只会监听数据的值是否发生改变，而不会去监听数据的地址是否发生改变。也就是说，watch想要监听引用类型数据的变化，需要进行深度监听。“obj.name”(){}------如果obj的属性太多，这种方法的效率很低，obj:{handler(newVal){},deep:true}------用handler+deep的方式进行深度监听。

5、特殊情况下，watch无法监听到数组的变化，特殊情况就是说更改数组中的数据时，数组已经更改，但是视图没有更新。更改数组必须要用splice()或者set。

6、immediate:true 页面首次加载的时候做一次监听。

#### 「vue单页面与多页面区分」

![img](https://img-blog.csdnimg.cn/2018111314194278.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RfY2xhdXM=,size_16,color_FFFFFF,t_70)





#### 「为什么vue组件中的data是一个函数而不是一个对象？」

​		JavaScript中的对象是引用类型的数据，当多个实例引用同一个对象时，只要**一个实例对这个对象进行操作，其他实例中的数据也会发生变化**。

​		而在Vue中，我们更多的是想要复用组件，那就需要每个组件都有自己的数据，这样组件之间才不会相互干扰。

​		所以组件的数据不能写成对象的形式，而是要写成函数的形式。数据以`函数返回值的形式`定义，这样当我们每次复用组件的时候，就会`返回一个新的data`，也就是说每个组件都有`自己的私有数据空间`，它们各自维护自己的数据，不会`干扰其他组件`的正常运行。



#### 「Vue.config.js配置文件的内容」

https://www.jianshu.com/p/b358a91bdf2d

**publicPath** ： 部署应用包时的基本 URL、**outputDir**：输出文件目录

**assetsDir**：放置生成的静态资源 (js、css、img、fonts) 的目录

**indexPath**：指定生成的 index.html 的输出路径 (相对于 outputDir)。也可以是一个绝对路径。

**pages**：在 multi-page（多页）模式下构建应用

**Webpack相关配置**：**configureWebpack**、**chainWebpack**

**Css相关配置**：**css.modules**、**css.sourceMap**、**css.loaderOptions**、**devServer**、**pwa**、**pluginOptions**





#### 「vue-router的两种模式及不同」

> vue-router有两种模式，`hash模式`和`history模式`

**`hash模式：`**

![image-20211005200451906](https://gitee.com/wexia/my_pic_bed/raw/master/pics/20211006112108.png)

hash模式背后的原理是`onhashchange`事件,可以在`window`对象上监听这个事件:

​		因为hash发生变化的url都会被浏览器记录下来，从而你会发现浏览器的前进后退都可以用了，同时点击后退时，页面字体颜色也会发生变化。这样一来，尽管浏览器没有请求服务器，但是页面状态和url一一关联起来，后来人们给它起了一个霸气的名字叫前端路由，成为了单页应用标配。

这个我们应该不陌生，比如在用超链接制作锚点跳转的时候，就会发现，url后面跟了"#id"，hash值就是url中从"#"号开始到结束的部分//纷享销客系统采取的就是hash模式

https://www.fxiaoke.com/XV/Home/Index#plan

hash值变化浏览器不会重新发起请求，但是会触发`window.onhashChange`事件，假如我们在`onhashChange`事件中获取当前的hash值，并根据hash值来修改页面内容，则达到了前端路由的目的。

**`history路由`**

![image-20211005200500553](https://gitee.com/wexia/my_pic_bed/raw/master/pics/20211006112059.png)

​		hash模式看起来是比较丑的，都带个"#"号，我们也可以采取history模式，history就是我们平时看到的正常的连接形式`https://www.fxiaoke.com#plan/index //hash模式路由`

​		`https://www.fxiaoke.com/plan/index //history模式路由	`	

​		随着history api的到来，前端路由开始进化了, 前面的hashchange，你只能改变#后面的url片段，而history api则给了前端完全的自由，history api可以分为两大部分，**`切换和修改 历史状态`**

![image-20211005200508875](https://gitee.com/wexia/my_pic_bed/raw/master/pics/20211006112124.png)

##### **hash路由和history路由的区别**

> ###### 1.hash路由在地址栏URL上有#，用 window.location.hash 读取。而history路由没有会好看一点

> ###### 2.我们进行回车刷新操作，hash路由会加载到地址栏对应的页面，而history路由一般就404报错了（刷新是网络请求，没有后端准备时会报错）。

> ###### 3.hash路由支持低版本的浏览器，而history路由是HTML5新增的API。

> ###### 4.hash的特点在于它虽然出现在了URL中，但是不包括在http请求中，所以对于后端是没有一点影响的，所以改变hash不会重新加载页面，所以这也是单页面应用的必备。

> ###### 5.history运用了浏览器的历史记录栈，之前有back,forward,go方法，之后在HTML5中新增了pushState（）和replaceState（）方法，它们提供了对历史记录进行修改的功能，不过在进行修改时，虽然改变了当前的URL，但是浏览器不会马上向后端发送请求。

> ###### 6.history的这种模式需要后台配置支持。比如：当我们进行项目的主页的时候，一切正常，可以访问，但是当我们刷新页面或者直接访问路径的时候就会返回404，那是因为在history模式下，只是动态的通过js操作window.history来改变浏览器地址栏里的路径，并没有发起http请求，但是当我直接在浏览器里输入这个地址的时候，就一定要对服务器发起http请求，但是这个目标在服务器上又不存在，所以会返回404



配置好history模式的路由以后，刷新浏览器出现404

​		因为我们的应用是单页客户端应用，当使用 history 模式时，URL 就像正常的 url，可以直接访问http://www.xxx.com/user/id，但是因为vue-router设置的路径不是真实存在的路径，所以刷新就会返回404错误。

​		想要history模式正常访问，还需要后台配置支持。要在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面。

​		也就是在服务端修改404错误页面的配置路径，让其指向到index.html。

```
const devServer = {
    port: 8000,
    host: '0.0.0.0',
    historyApiFallback:{
      index:'/index.html'
    },
    overlay: {
        errors: true,
    },
    hot: true
}
```



##### vue-router原理

https://blog.csdn.net/weixin_44667072/article/details/101014290

​		通常构建一个Vue应用的时候, 我们会使用Vue.use以插件的形式安装VueRouter。同时会在Vue的实例上挂载router的实例。在vueRouter这个插件中有一个公共的方法install，这个方法的第一个参数是Vue构造器，第二个参数是一个可选的参数对象，其中在install文件中，并且混入了mixin,给每一个组件创建beforeCreate钩子,在Vue的实例上初始化了一些私有属性，其中_router指向了VueRouter的实例，_root指向了Vue的实例。

​		在Vue中利用数据劫持defineProperty在原型prototype上初始化了一些getter,分别是router代表当前Router 的 实 例 、 router 代表当前Router的实例、router代表当前Router的实例、route 代表当前Router的信息。在install中也全局注册了router-view,router-link,其中的Vue.util.defineReactive, 这是Vue里面观察者劫持数据的方法，劫持 route，当 route 触发setter方法的时候，则会通知到依赖的组件。

​		接下来在init中，会挂载判断是路由的模式，是history或者是hash,点击行为按钮，调用hashchange或者popstate的同时更新_route,_route的更新会触发route-view的重新渲染。






#### 「Vue的keep-alive」

​		**概念：**keep-alive 是 Vue 的内置组件，当它包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。和 transition 相似，keep-alive 是一个抽象组件：它自身不会渲染成一个 DOM 元素，也不会出现在父组件链中。

​		**作用：**在组件切换过程中将状态保留在内存中，防止重复渲染DOM，减少加载时间及性能消耗，提高用户体验性

​		**原理：**在 created 函数调用时将需要缓存的 VNode 节点保存在 this.cache 中／在 render（页面渲染） 时，如果 VNode 的 name 符合缓存条件（可以用 include 以及 exclude 控制），则会从 this.cache 中取出之前缓存的 VNode 实例进行渲染。

​		**Props**：

- include - 字符串或正则表达式。只有名称匹配的组件会被缓存。
- exclude - 字符串或正则表达式。任何名称匹配的组件都不会被缓存。
- max - 数字。最多可以缓存多少组件实例。



**常见用法**：

```
// 组件
export default {
  name: 'test-keep-alive',
  data () {
    return {
        includedComponents: "test-keep-alive"
    }
  }
}
```

```
<keep-alive include="test-keep-alive">
  <!-- 将缓存name为test-keep-alive的组件 -->
  <component></component>
</keep-alive>
 
<keep-alive include="a,b">
  <!-- 将缓存name为a或者b的组件，结合动态组件使用 -->
  <component :is="view"></component>
</keep-alive>
 
<!-- 使用正则表达式，需使用v-bind -->
<keep-alive :include="/a|b/">
  <component :is="view"></component>
</keep-alive>
 
<!-- 动态判断 -->
<keep-alive :include="includedComponents">
  <router-view></router-view>
</keep-alive>
 
<keep-alive exclude="test-keep-alive">
  <!-- 将不缓存name为test-keep-alive的组件 -->
  <component></component>
</keep-alive>
```





#### 「vue组件间通信六种方式」

https://segmentfault.com/a/1190000019208626?utm_source=tag-newest

> 方法一：`props`/`$emit`

**父组件向子组件传值**

父组件通过`props`向下传递数据给子组件。注：组件中的数据共有三种形式：data、props、computed

**子组件向父组件传值（通过事件形式）**

子组件通过`events`给父组件发送消息，实际上就是子组件把自己的数据发送到父组件。



> 方法二、`$emit`/`$on`

**这种方法通过一个空的Vue实例作为中央事件总线（事件中心），用它来触发事件和监听事件,巧妙而轻量地实现了任何组件间的通信，包括父子、兄弟、跨级**。当我们的项目比较大时，可以选择更好的状态管理解决方案vuex。



> 方法三、`vuex`

![image-20210909144755178](https://gitee.com/wexia/my_pic_bed/raw/master/pics/20210915114655.png)

**1.简要介绍Vuex原理**

Vuex实现了一个单向数据流，在全局拥有一个State存放数据，当组件要更改State中的数据时，必须通过Mutation进行，Mutation同时提供了订阅者模式供外部插件调用获取State数据的更新。而当所有异步操作(常见于调用后端接口异步获取更新数据)或批量的同步操作需要走Action，但Action也是无法直接修改State的，还是需要通过Mutation来修改State的数据。最后，根据State的变化，渲染到视图上。

**2.简要介绍各模块在流程中的功能：**

- Vue Components：Vue组件。HTML页面上，负责接收用户操作等交互行为，执行dispatch方法触发对应action进行回应。
- dispatch：操作行为触发方法，是唯一能执行action的方法。
- actions：**操作行为处理模块,由组件中的`$store.dispatch('action 名称', data1)`来触发。然后由commit()来触发mutation的调用 , 间接更新 state**。负责处理Vue Components接收到的所有交互行为。包含同步/异步操作，支持多个同名方法，按照注册的顺序依次触发。向后台API请求的操作就在这个模块中进行，包括触发其他action以及提交mutation的操作。该模块提供了Promise的封装，以支持action的链式触发。
- commit：状态改变提交操作方法。对mutation进行提交，是唯一能执行mutation的方法。
- mutations：**状态改变操作方法，由actions中的`commit('mutation 名称')`来触发**。是Vuex修改state的唯一推荐方法。该方法只能进行同步操作，且方法名只能全局唯一。操作之中会有一些hook暴露出来，以进行state的监控等。
- state：页面状态管理容器对象。集中存储Vue components中data对象的零散数据，全局唯一，以进行统一的状态管理。页面显示所需的数据从该对象中进行读取，利用Vue的细粒度数据响应机制来进行高效的状态更新。
- getters：state对象读取方法。图中没有单独列出该模块，应该被包含在了render中，Vue Components通过该方法读取全局state对象。

**3.Vuex与localStorage**

vuex 是 vue 的状态管理器，存储的数据是响应式的。但是并不会保存起来，刷新之后就回到了初始状态，**具体做法应该在vuex里数据改变的时候把数据拷贝一份保存到localStorage里面，刷新之后，如果localStorage里有保存的数据，取出来再替换store里的state。**

这里需要注意的是：由于vuex里，我们保存的状态，都是数组，而localStorage只支持字符串，所以需要用JSON转换：

```
JSON.stringify(state.subscribeList);   // array -> string
JSON.parse(window.localStorage.getItem("subscribeList"));    // string -> array 
```



> 方法四、`$attrs`/`$listeners`

多级组件嵌套需要传递数据时，通常使用的方法是通过vuex。但如果仅仅是传递数据，而不做中间处理，使用 vuex 处理，未免有点大材小用。为此Vue2.4 版本提供了另一种方法----`$attrs`/`$listeners`

- `$attrs`：包含了父作用域中不被 prop 所识别 (且获取) 的特性绑定 (class 和 style 除外)。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 (class 和 style 除外)，并且可以通过 v-bind="$attrs" 传入内部组件。通常配合 interitAttrs 选项一起使用。
- `$listeners`：包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。它可以通过 v-on="$listeners" 传入内部组件

简单来说：`$attrs`与`$listeners` 是两个对象，`$attrs` 里存放的是父组件中绑定的非 Props 属性，`$listeners`里存放的是父组件中绑定的非原生事件。



> 方法五、`provide/inject`

Vue2.2.0新增API,这对选项需要一起使用，**以允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间里始终生效**。一言而蔽之：祖先组件中通过provider来提供变量，然后在子孙组件中通过inject来注入变量。
**provide / inject API 主要解决了跨级组件间的通信问题，不过它的使用场景，主要是子组件获取上级组件的状态，跨级组件间建立了一种主动提供与依赖注入的关系**。



> 方法六、`$parent` / `$children`与 `ref`

- `ref`：如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例
- `$parent` / `$children`：访问父 / 子实例



> **`总结`**

常见使用场景可以分为三类：

- 父子通信：父向子传递数据是通过 props，子向父是通过 events（`$emit`）；通过父链 / 子链也可以通信（`$parent` / `$children`）；ref 也可以访问组件实例；`provide / inject API`；`$attrs/$listeners`

- 兄弟通信：Bus；`Vuex`

- 跨级通信：Bus；`Vuex`；`provide / inject API`、`$attrs/$listeners`



#### 「Vue性能优化」

![image-20211005195554631](https://gitee.com/wexia/my_pic_bed/raw/master/pics/20211006111934.png)

##### 1. 代码层面的优化

> **1.1  v-if 和v-show 区分使用场景**

​		v-if 是 真正 的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建；也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。
v-show 就简单得多， 不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 的 display 属性进行切换。
所以，v-if适用于在运行时很少改变条件，不需要重复频繁切换条件的场景，；v-show则适用于需要非常频繁切换条件的场景

> **1.2  computed和watch区分适用情景**

​		computed： 是计算属性，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值；
​		watch： 更多的是「观察」的作用，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作；

运用场景：
当我们需要进行数值计算时，并且依赖于其他数据时，我们应该适用computed，因为我们可以利用computed的缓存特性，避免每次获取值时，都要重新计算

当我们需要在数据变化时， 执行异步操作或开销较大的操作时，应该使用watch，使用watch选项使我们执行异步操作，（访问一个api），限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态，这是都是计算属性无法做到的

> **1.3  v-for遍历必须为item添加key，且避免同时使用v-if**

（1）v-for 遍历必须为 item 添加 key
在列表数据进行遍历渲染时，需要为每一项 item 设置唯一 key 值，方便 Vue.js 内部机制精准找到该条列表数据。当 state 更新时，新的状态值和旧的状态值对比，较快地定位到 diff 。

（2）v-for 遍历避免同时使用 v-if
v-for 比 v-if 优先级高，如果每一次都需要遍历整个数组，将会影响速度，尤其是当之需要渲染很小一部分的时候，必要情况下应该替换成 computed 属性。
推荐：

```javascript
<ul>
  <li
    v-for="user in activeUsers"
    :key="user.id">
    {{ user.name }}
  </li>
</ul>
computed: {
  activeUsers: function () {
    return this.users.filter(function (user) {
   return user.isActive
    })
  }
}
```

不推荐：

```javascript
<ul>
  <li
    v-for="user in users"
    v-if="user.isActive"
    :key="user.id">
    {{ user.name }}
  </li>
</ul>
```

> **1.4  长列表性能优化**

​		Vue会通过Object.defineProperty 对数据进行劫持，来实现视图响应数据的变化，然而有些时候我们的组件就是纯粹的数据展示，不会有很多的变化，我们就不需要劫持我们的数据，在大量数据下，这能够很明显的减少组件初始化的时间， 那如何禁止Vue劫持我们的数据呢？可以通过Object.freeze方法来冻结一个对象，一旦被冻结的对象就再也不能修改了。

```javascript
export default{
    data() {
        return {
            users:{}
        }
    },
    async created () {
        const users = await axios.get("/api/users")
        this.users = Object.freeze(users);
    }
}
1234567891011
```

> **1.5  事件的销毁**

​		Vue组件销毁时，会自动清理他与其他实例的连接，解绑他的全部指令即事件监听器，但是仅限于组件本身的事件，如果在js内使用`addEventListener`等方式是不会自动销毁的，我们需要在组件销毁时手动移除这些事件的监听，以免造成内存的泄露，如：

```javascript
created () {
    addEventListener('click',this.tick ,false)

},
beforeDestroy () {
    removeEventListener('click',this.tick,false)
}
1234567
```

> **1.6  图片懒加载**

```
对于图片过多的页面，为了加速页面加载速度，所以很多时候我们需要将页面内未出现在可视区域内的图片先不做加载， 等到滚动到可视区域后再去加载。这样对于页面加载性能上会有很大的提升，也提高了用户体验。我们在项目中使用 Vue 的 vue-lazyload 插件：
```

（1）安装插件

```javascript
npm install vue-lazyload --save-de
```

（2）在入口文件 man.js 中引入并使用

```javascript
import VueLazyload from 'vue-lazyload'
```

然后再 vue 中直接使用

```javascript
Vue.use(VueLazyload)
```

或者添加自定义选项

```javascript
Vue.use(VueLazyload, {
preLoad: 1.3,
error: 'dist/error.png',
loading: 'dist/loading.gif',
attempt: 1
})
```

（3）在 vue 文件中将 img 标签的 src 属性直接改为 v-lazy ，从而将图片显示方式更改为懒加载显示：

```javascript
<img v-lazy="/static/img/1.png">
```

以上为 vue-lazyload 插件的简单使用，如果要看插件的更多参数选项，可以查看 vue-lazyload 的 github 地址。

> **1.7  路由懒加载**

​		Vue是单页面应用，可能会有很多的路由引入，这样使用webpack打包后的文件很大，当进入首页是，加载的资源过多，页面会出现白屏的情况，不利于用户体验。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由呗访问的时候才加载对应的组件，这样就会更加高效了，这样会大大提高首屏显示的速度，但是可能其他的页面的速度就会降下来了
路由懒加载：

```javascript
const Foo = () => import('./Foo.vue')
const router = new VueRouter({
  routes: [
    { path: '/foo', component: Foo }
  ]
})
```

> **1.8  第三方插件的按需引入**

​		我们在项目中经常会需要引入第三方插件，如果我们直接引入整个插件，会导致项目的体积太大，我们可以借助 babel-plugin-component ，然后可以只引入需要的组件，以达到减小项目体积的目的。以下为项目中引入 element-ui 组件库为例：
（1）首先，安装 babel-plugin-component ：

```javascript
npm install babel-plugin-component -D
```

（2）然后，将 .babelrc 修改为

```javascript
{
  "presets": [["es2015", { "modules": false }]],
  "plugins": [
    [
      "component",
      {
        "libraryName": "element-ui",
        "styleLibraryName": "theme-chalk"
      }
    ]
  ]
}
```

（3）在 main.js 中引入部分组件：

```javascript
import Vue from 'vue';
import { Button, Select } from 'element-ui';

 Vue.use(Button)
 Vue.use(Select)
```

> **1.9  优化无限列表性能**

如果你的应用存在非常长的或者无限滚动的列表，那么需要采用窗口化的技术来优化性能，只需要渲染少部分的内容，减少重新渲染组件和创建dom节点的时间，你可以参考以下的开源项目vue-vitual-scoll -list 和vue-virtual-scroller ,来优化这种无限列表的场景的

> **1.10  服务端渲染SSR or 预渲染**

​		服务端渲染是指Vue在客户端将标签渲染在整个HTML片段的工作在服务端完成，服务端形成的html片段直接返回给客户端这个过程叫做服务端渲染
（1）服务端渲染的优点

- 更好的SEO：因为 SPA 页面的内容是通过ajax获取的，而搜索引擎爬取的工具并不会等待ajax异步完成后抓取页面的内容，所以在SPA中是抓取不到页面通过ajax获取到的内容，而SSR是直接有服务器返回已经渲染后的页面（数据已经包含页面中），所以搜索引擎爬取工具会可以抓取到渲染好的页面
- 更好的内容到达时间（首屏加载更快），：SPA会等待所有Vue编译后的js文件都下载完成后，才开始进行页面的渲染，文件下载还需要一定的时间，所以首屏渲染需要一定的时间，SSR直接有服务端渲染好的页面直接返回显示，无需等待js文件，所以SSR有更快内容到达时间
  -(2)服务端渲染的缺点
- 更多的开发条件限制：例如服务端渲染只支持 beforCreate 和 created 两个钩子函数，这会导致一些外部扩展库需要特殊处理，才能在服务端渲染应用程序中运行；并且与可以部署在任何静态文件服务器上的完全静态单页面应用程序 SPA 不同，服务端渲染应用程序，需要处于 Node.js server 运行环境；
- 更多的服务器负载：在 Node.js 中渲染完整的应用程序，显然会比仅仅提供静态文件的 server 更加大量占用CPU 资源，因此如果你预料在高流量环境下使用，请准备相应的服务器负载，并明智地采用缓存策略。

​          如果你的项目的 SEO 和 首屏渲染是评价项目的关键指标，那么你的项目就需要服务端渲染来帮助你实现最佳的初始加载性能和 SEO，具体的 Vue SSR 如何实现，可以参考作者的另一篇文章《Vue SSR 踩坑之旅》。如果你的 Vue 项目只需改善少数营销页面（例如 /， /about， /contact 等）的 SEO，那么你可能需要预渲染，在构建时 (build time) 简单地生成针对特定路由的静态 HTML 文件。优点是设置预渲染更简单，并可以将你的前端作为一个完全静态的站点，具体你可以使用 prerender-spa-plugin 就可以轻松地添加预渲染 。

##### 2. Webpack 层面的优化

> **2.1、Webpack 对图片进行压缩**

​		在 vue 项目中除了可以在 webpack.base.conf.js 中 url-loader 中设置 limit 大小来对图片处理，对小于 limit 的图片转化为 base64 格式，其余的不做操作。所以对有些较大的图片资源，在请求资源的时候，加载会很慢，我们可以用 image-webpack-loader来压缩图片：
（1）首先，安装 image-webpack-loader ：

```javascript
npm install image-webpack-loader --save-dev
```

（2）然后，在 webpack.base.conf.js 中进行配置：

```javascript
{
  test: /.(png|jpe?g|gif|svg)(?.*)?$/,
  use:[
    {
    loader: 'url-loader',
    options: {
      limit: 10000,
      name: utils.assetsPath('img/[name].[hash:7].[ext]')
      }
    },
    {
      loader: 'image-webpack-loader',
      options: {
        bypassOnDebug: true,
      }
    }
  ]
}
```

> **2.2、减少 ES6 转为 ES5 的冗余代码**

Babel 插件会在将 ES6 代码转换成 ES5 代码时会注入一些辅助函数，例如下面的 ES6 代码：

```javascript
class HelloWebpack extends Component{...}
```

这段代码再被转换成能正常运行的 ES5 代码时需要以下两个辅助函数：

```javascript
babel-runtime/helpers/createClass  // 用于实现 class 语法
babel-runtime/helpers/inherits  // 用于实现 extends 语法
12
```

在默认情况下， Babel 会在每个输出文件中内嵌这些依赖的辅助函数代码，如果多个源代码文件都依赖这些辅助函数，那么这些辅助函数的代码将会出现很多次，造成代码冗余。为了不让这些辅助函数的代码重复出现，可以在依赖它们时通过 require(‘babel-runtime/helpers/createClass’) 的方式导入，这样就能做到只让它们出现一次。babel-plugin-transform-runtime 插件就是用来实现这个作用的，将相关辅助函数进行替换成导入语句，从而减小 babel 编译出来的代码的文件大小。
（1）首先，安装 babel-plugin-transform-runtime ：

```javascrip
npm install babel-plugin-transform-runtime --save-dev
```

（2）然后，修改 .babelrc 配置文件为：

```javascript
"plugins": [
    "transform-runtime"
]
```

如果要看插件的更多详细内容，可以查看**babel-plugin-transform-runtime** 的 详细介绍。

> **2.3、提取公共代码**

​		如果项目中没有去将每个页面的第三方库和公共模块提取出来，则项目会存在以下问题：
相同的资源被重复加载，浪费用户的流量和服务器的成本。
每个页面需要加载的资源太大，导致网页首屏加载缓慢，影响用户体验。
所以我们需要将多个页面的公共代码抽离成单独的文件，来优化以上问题 。Webpack 内置了专门用于提取多个Chunk 中的公共部分的插件 **CommonsChunkPlugin**，我们在项目中 CommonsChunkPlugin 的配置如下：

```javascript
// 所有在 package.json 里面依赖的包，都会被打包进 vendor.js 这个文件中。
new webpack.optimize.CommonsChunkPlugin({
  name: 'vendor',
  minChunks: function(module, count) {
    return (
      module.resource &&
      /.js$/.test(module.resource) &&
      module.resource.indexOf(
        path.join(__dirname, '../node_modules')
      ) === 0
    );
  }
}),

// 抽取出代码模块的映射关系
new webpack.optimize.CommonsChunkPlugin({
  name: 'manifest',
  chunks: ['vendor']
})
```

如果要看插件的更多详细内容，可以查看 CommonsChunkPlugin 的 详细介绍。

> **2.4、模板预编译**

​		当使用 DOM 内模板或 JavaScript 内的字符串模板时，模板会在运行时被编译为渲染函数。通常情况下这个过程已经足够快了，但对性能敏感的应用还是最好避免这种用法。
预编译模板最简单的方式就是使用单文件组件——相关的构建设置会自动把预编译处理好，所以构建好的代码已经包含了编译出来的渲染函数而不是原始的模板字符串。
如果你使用 webpack，并且喜欢分离 JavaScript 和模板文件，你可以使用 vue-template-loader，它也可以在构建过程中把模板文件转换成为 JavaScript 渲染函数。

> **2.5、提取组件的 CSS**

​		当使用单文件组件时，组件内的 CSS 会以 style 标签的方式通过 JavaScript 动态注入。这有一些小小的运行时开销，如果你使用服务端渲染，这会导致一段 “无样式内容闪烁 (fouc) ” 。将所有组件的 CSS 提取到同一个文件可以避免这个问题，也会让 CSS 更好地进行压缩和缓存。
查阅这个构建工具各自的文档来了解更多：
**webpack + vue-loader ( vue-cli 的 webpack 模板已经预先配置好)
Browserify + vueify
Rollup + rollup-plugin-vue**

> **2.6、优化 SourceMap**

​		我们在项目进行打包后，会将开发中的多个文件代码打包到一个文件中，并且经过压缩、去掉多余的空格、babel编译化后，最终将编译得到的代码会用于线上环境，那么这样处理后的代码和源代码会有很大的差别，当有 bug的时候，我们只能定位到压缩处理后的代码位置，无法定位到开发环境中的代码，对于开发来说不好调式定位问题，因此 sourceMap 出现了，它就是为了解决不好调式代码问题的。
SourceMap 的可选值如下（+ 号越多，代表速度越快，- 号越多，代表速度越慢, o 代表中等速度 ）

开发环境推荐：**cheap-module-eval-source-map**
生产环境推荐：**cheap-module-source-map**

原因如下：
cheap：源代码中的列信息是没有任何作用，因此我们打包后的文件不希望包含列相关信息，只有行信息能建立打包前后的依赖关系。因此不管是开发环境或生产环境，我们都希望添加 cheap 的基本类型来忽略打包前后的列信息；
module ：不管是开发环境还是正式环境，我们都希望能定位到bug的源代码具体的位置，比如说某个 Vue 文件报错了，我们希望能定位到具体的 Vue 文件，因此我们也需要 module 配置；
soure-map ：source-map 会为每一个打包后的模块生成独立的 soucemap 文件 ，因此我们需要增加source-map 属性；
eval-source-map：eval 打包代码的速度非常快，因为它不生成 map 文件，但是可以对 eval 组合使用 eval-source-map 使用会将 map 文件以 DataURL 的形式存在打包后的 js 文件中。在正式环境中不要使用 eval-source-map, 因为它会增加文件的大小，但是在开发环境中，可以试用下，因为他们打包的速度很快。

> **2.7、构建结果输出分析**

​		Webpack 输出的代码可读性非常差而且文件非常大，让我们非常头疼。为了更简单、直观地分析输出结果，社区中出现了许多可视化分析工具。这些工具以图形的方式将结果更直观地展示出来，让我们快速了解问题所在。接下来讲解我们在 Vue 项目中用到的分析工具：

```javascript
webpack-bundle-analyzer 。
我们在项目中 webpack.prod.conf.js 进行配置：
if (config.build.bundleAnalyzerReport) {
  var BundleAnalyzerPlugin =   require('webpack-bundle-analyzer').BundleAnalyzerPlugin;
  webpackConfig.plugins.push(new BundleAnalyzerPlugin());
}
执行  $ npm run build --report  后生成分析报告如下：·
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190909204050634.gif)

> **2.8、Vue 项目的编译优化**

​		如果你的 Vue 项目使用 Webpack 编译，需要你喝一杯咖啡的时间，那么也许你需要对项目的 Webpack 配置进行优化，提高 Webpack 的构建效率。具体如何进行 Vue 项目的 Webpack 构建优化，可以参考作者的另一篇文章《 Vue 项目 Webpack 优化实践》

##### 3.  基础的 Web 技术优化

> **3.1  开启gzip压缩**

​		gzip是GNUzip的缩写，最早用于UNIX文件系统的文件压缩。HTTP协议上的gzip的编码是一种用来改进web应用程序的性能的技术，web服务器和客户端（浏览器），必须共同支持gzip。目前主流的浏览器，Chorme，FireFox，Ie等都支持该协议，常见的web服务器如Apache，NGINX，IIS同样支持，gzip压缩效非常高，通常可以达到70%的压缩率，也就是说，如果的网页有30K压缩之后就变成了9K左右
以下我们以服务端使用我们熟悉的expres为例，开启gzip非常简单，相关步骤如下：

```
//  安装：
npm install compression --save
// 添加代码逻辑：
var compression = require(‘compression’);
var app = express();
app.use(compression())
```

重启服务，观察网络面板里面的 response header，如果看到如下红圈里的字段则表明 gzip 开启成功 ：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190909205202829.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMzY3NzQ5,size_16,color_FFFFFF,t_70)

> **3.2、浏览器缓存**

​		为了提高用户加载页面的速度，对静态资源进行缓存是非常必要的，根据是否需要重新向服务器发起请求来分类，将 HTTP 缓存规则分为两大类（强制缓存，对比缓存），如果对缓存机制还不是了解很清楚的，可以参考作者写的关于 HTTP 缓存的文章《深入理解HTTP缓存机制及原理》，这里不再赘述。

> **3.3、CDN 的使用**

​		浏览器从服务器上下载 CSS、js 和图片等文件时都要和服务器连接，而大部分服务器的带宽有限，如果超过限制，网页就半天反应不过来。而 CDN 可以通过不同的域名来加载文件，从而使下载文件的并发连接数大大增加，且CDN 具有更好的可用性，更低的网络延迟和丢包率 。

> **3.4、使用 Chrome Performance 查找性能瓶颈**

Chrome 的 Performance 面板可以录制一段时间内的 js 执行细节及时间。使用 Chrome 开发者工具分析页面性能的步骤如下。
1.打开 Chrome 开发者工具，切换到 Performance 面板
2.点击 Record 开始录制
3.刷新页面或展开某个节点
4.点击 Stop 停止录制

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190909205102267.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMzY3NzQ5,size_16,color_FFFFFF,t_70)





#### 「Vue怎么实现数据双向绑定」

> vue数据双向绑定是通过**数据劫持结合发布者-订阅者模式**的方式来实现的
>
> vue是通过Object.defineProperty()来实现数据劫持的。

`数据改变 ---> 更新视图`

​		首先我们为每个vue属性用Object.defineProperty()实现数据劫持，为每个属性分配一个订阅者集合的管理数组dep；然后在编译的时候在该属性的数组dep中添加订阅者，v-model会添加一个订阅者，{{}}也会，v-bind也会，只要用到该属性的指令理论上都会，接着为input会添加监听事件，修改值就会为该属性赋值，触发该属性的set方法，在set方法内通知订阅者数组dep，订阅者数组循环调用各订阅者的update方法更新视图。

<img src="https://images2015.cnblogs.com/blog/938664/201705/938664-20170522230647382-1643499691.jpg" alt="img"  />

​	**具体实现过程**

​		首先要对数据进行劫持监听，所以我们需要设置一个监听器Observer，用来监听所有属性。如果属性发生变化了，就需要告诉订阅者Watcher看是否需要更新。因为订阅者是有很多个，所以我们需要有一个消息订阅器Dep来专门收集这些订阅者，然后在监听器Observer和订阅者Watcher之间进行统一管理的。

​		接着，我们还需要有一个指令解析器Compile，对每个节点元素进行扫描和解析，将相关指令对应初始化成一个订阅者Watcher，并替换模板数据或者绑定相应的函数，此时当订阅者Watcher接收到相应属性的变化，就会执行对应的更新函数，从而更新视图。

​		因此接下去我们执行以下3个步骤，实现数据的双向绑定：

​		1.实现一个监听器Observer，用来劫持并监听所有属性，如果有变动的，就通知订阅者。

```
Observer是一个数据监听器，其实现核心方法就是前文所说的Object.defineProperty( )。如果要对所有属性都进行监听的话，那么可以通过递归方法遍历所有属性值，并对其进行Object.defineProperty( )处理。
```

​		2.实现一个订阅者Watcher，可以收到属性的变化通知并执行相应的函数，从而更新视图。

​		3.实现一个解析器Compile，可以扫描和解析每个节点的相关指令，并根据初始化模板数据以及初始化相应的订阅器。

![img](https://images2015.cnblogs.com/blog/938664/201705/938664-20170522225458132-1434604303.png)





#### 「Vue的diff算法」

我们先根据真实DOM生成一颗 `virtual DOM` ，当 `virtual DOM` 某个节点的数据改变后会生成一个新的 `Vnode` ，然后 `Vnode` 和 `oldVnode` 作对比，发现有不一样的地方就直接修改在真实的DOM上，然后使 `oldVnode` 的值为 `Vnode` 。

diff的过程就是调用名为 `patch` 的函数，比较新旧节点，一边比较一边给 **真实的DOM** 打补丁

![img](https://files.jb51.net/file_images/article/201805/2018520163324401.png?2018420163342)

![img](https://files.jb51.net/file_images/article/201805/2018052016274646.png)

![img](https://files.jb51.net/file_images/article/201805/2018052016274647.png)

现在分别对 `oldS、oldE、S、E` 两两做 `sameVnode` 比较，有四种比较方式，当其中两个能匹配上那么真实dom中的相应节点会移到Vnode相应的位置，这句话有点绕，打个比方

1. 如果是oldS和E匹配上了，那么真实dom中的第一个节点会移到最后,  **oldStartIdx向后移动，newEndIdx向前移动。**
2. 如果是oldE和S匹配上了，那么真实dom中的最后一个节点会移到最前，匹配上的两个指针向中间移动， **oldEndIdxx向前移动，newStartIdx向后移动。**
3. 如果四种匹配没有一对是成功的，那么遍历 `oldChild` ， `S` 挨个和他们匹配，匹配成功就在真实dom中将成功的节点移到最前面，如果依旧没有成功的，那么将 `S对应的节点` 插入到dom中对应的 `oldS` 位置， `oldS`和 `S` 指针向中间移动。****（发现新节点E并不存在于旧节点列表中，只能**新建E节点，并插入真实DOM中。哨兵newStartIdx向后移动。**）

![img](https://files.jb51.net/file_images/article/201805/2018052016274648.png)****

这个网站讲的挺好的： https://www.cnblogs.com/wangtong111/p/11198393.html

​													https://blog.csdn.net/qq_34179086/article/details/88086427

```
function patch (oldVnode, vnode) {
 // some code
 if (sameVnode(oldVnode, vnode)) {
  patchVnode(oldVnode, vnode)
 } else {
  const oEl = oldVnode.el // 当前oldVnode对应的真实元素节点
  let parentEle = api.parentNode(oEl) // 父元素
  createEle(vnode) // 根据Vnode生成新元素
  if (parentEle !== null) {
   api.insertBefore(parentEle, vnode.el, api.nextSibling(oEl)) // 将新元素添加进父元素
   api.removeChild(parentEle, oldVnode.el) // 移除以前的旧元素节点
   oldVnode = null
  }
 }
 // some code 
 return vnode
}

//  patch函数接收两个参数 oldVnode 和 Vnode 分别代表新的节点和之前的旧节点
//  判断两节点是否值得比较，值得比较则执行 patchVnode
```



```
patchVnode (oldVnode, vnode) {
 const el = vnode.el = oldVnode.el
 let i, oldCh = oldVnode.children, ch = vnode.children
 if (oldVnode === vnode) return
 if (oldVnode.text !== null && vnode.text !== null && oldVnode.text !== vnode.text) {
  api.setTextContent(el, vnode.text)
 }else {
  updateEle(el, vnode, oldVnode)
  if (oldCh && ch && oldCh !== ch) {
   updateChildren(el, oldCh, ch)
  }else if (ch){
   createEle(vnode) //create el's children dom
  }else if (oldCh){
   api.removeChildren(el)
  }
 }
}
```

`patchVnode (oldVnode, vnode)`函数做了以下事情：

1. 找到对应的真实dom，称为 `el`
2. 判断 `Vnode` 和 `oldVnode` 是否指向同一个对象，
3. 如果是，那么直接 `return` 如果他们都有文本节点并且不相等，那么将 `el` 的文本节点设置为 `Vnode` 的文本节点。
4. 如果 `oldVnode` 有子节点而 `Vnode` 没有，则删除 `el` 的子节点
5. 如果 `oldVnode` 没有子节点而 `Vnode` 有，则将 `Vnode` 的子节点真实化之后添加到 `el` 
6. 如果两者都有子节点，则执行 `updateChildren` 函数比较子节点，这一步很重要



`updateChildren(el, oldCh, ch)`函数做了什么

1. 将 `Vnode` 的子节点 `Vch` 和 `oldVnode` 的子节点 `oldCh` 提取出来
2. `oldCh` 和 `vCh` 各有两个头尾的变量 `StartIdx` 和 `EndIdx` ，它们的2个变量相互比较，一共有4种比较方式。如果4种比较都没匹配，如果设置了 `key` ，就会用 `key` 进行比较，在比较的过程中，变量会往中间靠，一旦 `StartIdx>EndIdx` 表明 `oldCh` 和 `vCh` 至少有一个已经遍历完了，就会结束比较。





#### 「Vue的数据响应式原理」

​	环式调用

![image-20210731132940348](https://gitee.com/wexia/my_pic_bed/raw/master/pics/20210731141201.png)

##### 数组的响应式处理

​		改写七个方法：push、pop、shift、unshift、splice、sort、reverse

```
// 得到Array.prototype
const arrayPrototype = Array.prototype;

// 以Array.prototype为原型创建arrayMethods对象，并暴露
export const arrayMethods = Object.create(arrayPrototype);

// 要被改写的7个数组方法
const methodsNeedChange = [
    'push',
    'pop',
    'shift',
    'unshift',
    'splice',
    'sort',
    'reverse'
];

methodsNeedChange.forEach(methodName => {
    // 备份原来的方法，因为push、pop等7个函数的功能不能被剥夺
    const original = arrayPrototype[methodName];
    // 定义新的方法
    def(arrayMethods, methodName, function () {
        // 恢复原来的功能
        const result = original.apply(this, arguments);
        // 把类数组对象变为数组
        const args = [...arguments];
        // 把这个数组身上的__ob__取出来，__ob__已经被添加了，为什么已经被添加了？因为数组肯定不是最高层，比如obj.g属性是数组，obj不能是数组，第一次遍历obj这个对象的第一层的时候，已经给g属性（就是这个数组）添加了__ob__属性。
        const ob = this.__ob__;

        // 有三种方法push\unshift\splice能够插入新项，现在要把插入的新项也要变为observe的
        let inserted = [];

        switch (methodName) {
            case 'push':
            case 'unshift':
                inserted = args;
                break;
            case 'splice':
                // splice格式是splice(下标, 数量, 插入的新项)
                inserted = args.slice(2);
                break;
        }

        // 判断有没有要插入的新项，让新项也变为响应的
        if (inserted) {
            ob.observeArray(inserted);
        }

        console.log('啦啦啦');

        ob.dep.notify();

        return result;
    }, false);
});
```

​	

​	把依赖收集的代码封装成一个`Dep `类，它用来`管理依赖`，**每个Observer 的实例，成员中都有一个Dep 的实例；**
​	Watcher 是一个中介，数据发生变化时通过`Watcher 中转`，通知组件

![data](https://cn.vuejs.org/images/data.png)



- 依赖就是`Watcher` 。只有`Watcher` 触发的`getter `才会收集依赖，哪个Watcher触发了getter，就把哪个Watcher 收集到Dep 中。
- `Dep `使用`发布订阅模式`，当数据发生变化时，会循环依赖列表，把所有的Watcher 都通知一遍。
- 代码实现的巧妙之处：Watcher 把自己设置到全局的一个指定位置，然后读取数据，因为读取了数据，所以会触发这个数据的getter 。在getter 中就能得到当前正在读取数据的Watcher，并把这Watcher收集到Dep 中。

![在这里插入图片描述](https://img-blog.csdnimg.cn/2020121819281311.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pa29uXzA3MDM=,size_16,color_FFFFFF,t_70)

https://blog.csdn.net/Mikon_0703/article/details/111367773

##### 	发布订阅者和观察者的区别

![img](https://images2015.cnblogs.com/blog/555379/201603/555379-20160313183429007-1351424959.png)

![img](https://images2015.cnblogs.com/blog/555379/201603/555379-20160313183439366-1623019133.png)

从两张图片可以看到，最大的区别是`调度的地方`。

​		虽然两种模式都存在订阅者和发布者（具体观察者可认为是订阅者、具体目标可认为是发布者），但是观察者模式是由具体目标调度的，而发布/订阅模式是统一由调度中心调的，所以观察者模式的订阅者与发布者之间是存在依赖的，而发布/订阅模式则不会。



#### 「Vue的nextTick原理」

​	nextTick是将回调函数延迟在下一次dom更新数据后调用，简单的理解是：当数据更新了，在dom中渲染后，自动执行该函数。所有放在Vue.nextTick()回调函数中的执行的应该是会对DOM进行操作的 js代码；

**`nextTick`中定义的三个重要变量：**

1.callbacks：用来存储所有需要执行的回调函数

2.pending：用来标志是否正在执行回调函数

3.timerFunc：用来触发执行回调函数

**nextTick的使用场景：**

1. 在Vue生命周期的created()钩子函数进行的DOM操作一定要放在Vue.nextTick()的回调函数中。created()钩子函数执行的时候DOM 其实并未进行任何渲染，而此时进行DOM操作无异于徒劳，所以此处一定要将DOM操作的js代码放进Vue.nextTick()的回调函数中。与之对应的就是mounted钩子函数，因为该钩子函数执行时所有的DOM挂载已完成。
2. 在数据变化后要执行的某个操作，而这个操作需要使用随数据改变而改变的DOM结构的时候，这个操作都应该放进Vue.nextTick()的回调函数中。

**nextTick和$nextTick区别:**
      1.nextTick(callback)：当数据发生变化，更新后执行回调。在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。

​		2.$nextTick(callback)：当dom发生变化，更新后执行的回调。将回调延迟到下次 DOM 更新循环之后执行。在修改数据之后立即使用它，然后等待 DOM 更新。

​		3.这两个方法没有太大的不同。区别在于：nextTick(callback) 是全局的方法；而 $nextTick(callback) 是回调的 this 自动绑定到调用它的实例上；所以用的更多的是$nextTick(callback)！

> **原理：**

​			当调用nextTick方法时会传入两个参数，回调函数和执行回调函数的上下文环境，如果没有提供回调函数，那么将返回promise对象。首先将拿到的回调函数存放到数组中，判断是否正在执行回调函数，如果当前没有在pending的时候，就会执行timeFunc，多次执行nextTick只会执行一次timerFunc，timeFunc其实就是执行异步的方法，在timeFunc方法中选择一个异步方法（首先判断是否支持promise，如果支持就将flushCallbacks放在promise中异步执行，并且标记使用微任务。如果不支持promise就看是否支持MutationObserver方法，如果支持就new了一个MutationObserver类，创建一个文本节点进行监听，当数据发生变化了就会异步执行flushCallbacks方法。如果以上两个都不支持就看是否支持setImmediate方法，如果支持setImmediate 就去异步执行flushCallbacks方法。如果以上三种方法都不支持，就使用setTimeout），然后异步去执行flushCallbacks方法，flushCallbacks中就是将传递的函数依次执行。

​		nextTick多次调用会维持一个数组，之后会异步的把数组中的方法以此执行，这样的话用户就会在视图更新之后再获取到真实的dom元素。
![img](https://img-blog.csdnimg.cn/20200627201207279.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDcyMDg2,size_16,color_FFFFFF,t_70)







## 7  let、const和var的区别

https://juejin.cn/post/7007224479218663455

​	  ES5 中作用域有：全局作用域、函数作用域。没有块作用域的概念（ES5中用立即执行函数替代）。

​     ES6 中新增了块级作用域。块作用域由 { } 包括，if语句和 for语句里面的{ }也属于块作用域，`const`和`let`声明的变量是具有**块级作用域**的。

1. `var`定义的变量，没有块的概念，可以**跨块访问**, 不能跨函数访问。不初始化输出`undefined`
2. `let`定义的变量，**只能在块作用域里**访问，不能跨块访问，也不能跨函数访问。
3. `const`用来定义常量，使用时必须初始化(即必须赋值)，**只能在块作用域里**访问，而且不能修改。

#### **「let的暂时性死区」**

> ES6 中新增了块级作用域，最直接的表现就是新增的 let 关键词，使用 let 关键词定义的变量只能在块级作用域中被访问，有“暂时性死区”的特点，也就是说这个变量在定义之前是不能被使用的。

```
console.log(a) //a is not defined
if(true){
  let a = '123'；
  console.log(a)； // 123
}
console.log(a) //a is not defined
```

​		通过 `let` 和 `const` 关键字声明的变量也会提升，但是和 `var` 不同，它们不会被*初始化*。在我们声明（初始化）之前是不能访问它们的。这个行为被称之为暂时性死区。当我们试图在声明之前访问它们时，JavaScript 将会抛出一个 `ReferenceError` 错误。



#### **「变量提升的理解」**

> **为什么会有变量提升？**

   （1）提高性能

​		在JS代码执行之前，会进行语法检查和预编译，并且这一操作只进行一次。这么做就是为了提高性能，如果没有这一步，那么每次执行代码前都必须重新解析一遍该变量（函数），而这是没有必要的，因为变量（函数）的代码并不会改变，解析一遍就够了。

​		在解析的过程中，还会为函数生成预编译代码。在预编译时，会统计声明了哪些变量、创建了哪些函数，并对函数的代码进行压缩，去除注释、不必要的空白等。这样做的好处就是每次执行函数时都可以直接为该函数分配栈空间（不需要再解析一遍去获取代码中声明了哪些变量，创建了哪些函数），并且因为代码压缩的原因，代码执行也更快了。

​	（2）容错性更好

​		变量提升可以在一定程度上提高JS的容错性


​		当栈内存（作用域）形成的，js代码自上而下执行之前，浏览器首先会把带有` var、function`关键字的进行提前`声明或定义`，这种预先处理的机制就是**变量提升**。

​		声明（declare）：var a ; (声明的时候 默认返回值是undefined)

​		定义（defined）：a=12 （定义也可以简单理解为赋值）

> **变量提升阶段：**

​		带“var”关键字只声明不定义；

​		带"function"关键字赋值和定义都完成了；

​		注意：变量提升只发生在当前作用域（eg: 开始加载页面的时候只对全局作用域下的进行变量提升，因此函数中存储的只是代码字符串而已）

 		从广义上说，在全局作用域下声明的变量或函数是”全局变量“，同理，在私有作用域下声明的变量时”私有变量“，【带有 “var”、"function"关键字的才是声明】，不带var声明的 变量就得一层一层向上级作用域查找，直到查找到全局无论是否找到都得停止

​		私有作用域形成之后，代码也并不是立即执行，带有形参的函数要先进行形参的赋值，再进行变量提升，在函数中遇到的大括号（例如for循环、if语句）不会形成栈内存，因为在ES3/ES5语法规范中明确规定了只有全局作用域和函数执行的私有作用域（栈内存），其他大括号不会形成栈内存。

​		值得注意的一点是，由于之前声明时函数已经被声明并且定义，当代码在自上而下执行时浏览器会直接跳过那一段被声明切赋值的函数。



#### **「作用域和作用域链」**

作用域就是代码的执行环境，全局执行环境就是全局作用域，函数的执行环境就是私有作用域，它们都是栈内存。

**作用域就是一个独立的地盘，让变量不会外泄、暴露出去**。也就是说**作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突。**

当代码在一个环境中执行时，会创建变量对象的一个**作用域链**（作用域形成的链条）

- 作用域链的前端，始终都是当前执行的代码所在环境的变量对象
- 作用域链中的下一个对象来自于外部环境，而在下一个变量对象则来自下一个外部环境，一直到全局执行环境
- 全局执行环境的变量对象始终都是作用域链上的最后一个对象

**内部环境可以通过作用域链访问所有外部环境，但外部环境不能访问内部环境的任何变量和函数。**

```
var n = 10;
function outer(){
  function inner(){
    function center(){
      console.log(n);
    }
    center();
  }
  inner();
  var n = 15;
}
outer(); //=> undefined
```



#### **「JS如何支持块级作用域」**

**`（1）创建执行上下文`**

创建的执行上下文如图所示：

![变量提升-块级作用域.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cfb441dd367a4f3e8cd0da9b594a9b5a~tplv-k3u1fbpfcp-watermark.awebp)

通过上图可知：

- 通过 var 声明的变量，在编译阶段会被存放到**变量环境**中。
- 通过 let 声明的变量，在编译阶段会被存放到**词法环境**中。
- 在函数作用域内部，通过 let 声明的变量并没有被存放到词法环境中。

**`（2）执行代码`**

当执行到代码块中时，变量环境中 a 的值已经被设置成了 1，词法环境中 b 的值已经被设置成了 2，这时函数的执行上下文如图所示： ![变量提升-块级作用域1.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/38b340ba3107449e8490ad146ac7bfca~tplv-k3u1fbpfcp-watermark.awebp) 



​      可以看到，当进入函数的作用域块时，作用域块中通过 let 声明的变量，会被存放在词法环境的一个单独的区域中，这个区域中的变量并不影响作用域块外面的变量，比如在作用域外面声明了变量 b，在该作用域块内部也声明了变量 b，当执行到作用域内部时，它们都是独立的存在。

其实，在词法环境内部，维护了一个栈结构，栈底是函数最外层的变量，进入一个作用域块后，就会把该作用域块内部的变量压到栈顶；当作用域执行完成之后，该作用域的信息就会从栈顶弹出，这就是词法环境的结构。这里的变量是指通过 let 或者 const 声明的变量。

接下来，当执行到作用域块中的`console.log(a)`时，就需要在词法环境和变量环境中查找变量 a 的值了，查找方式：沿着词法环境的栈顶向下查询，如果在词法环境中的某个块中查找到了，就直接返回给 JavaScript 引擎，如果没有查找到，那么继续在变量环境中查找。这样变量查找就完成了： ![变量提升-块级作用域2.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a79044d02e2045f791cc5fe123087d53~tplv-k3u1fbpfcp-watermark.awebp) 

当作用域块执行结束之后，其内部定义的变量就会从词法环境的栈顶弹出，最终执行上下文如图所示： ![变量提升-块级作用域3.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/50ad4ddf45064c3ab9672c18647f2896~tplv-k3u1fbpfcp-watermark.awebp) 

​    **块级作用域就是通过词法环境的栈结构来实现的，而变量提升是通过变量环境来实现，通过这两者的结合，JavaScript 引擎就同时支持了变量提升和块级作用域。**





#### **「内存泄漏及解决」**

> JavaScript 内存泄露指对象在不需要使用它时仍然存在，导致占用的内存不能使用或回收

- 未使用 var 声明的全局变量
- 闭包函数(Closures)
- 循环引用(两个对象相互引用)
- 控制台日志(console.log)
- 移除存在绑定事件的DOM元素(IE)
- `setTimeout` 的第一个参数使用字符串而非函数的话，会引发内存泄漏
- 垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收

**内存泄漏的识别方法**

1、使用快捷键 F12 或者 Ctrl+Shift+J 打开 Chrome 浏览器的「开发者工具」。

2、选择 Performance(老版为Timeline) 选项卡，在 Capture 选项中，只勾选 Memory。

3、设置完成后，点击最左边的 Record 按钮，然后就可以访问网页了。

4、打开一个网站，例如：www.taobao.com，当网页加载完成后，点击 Stop，等待分析结果。

5、然后在 ChartView 上寻找内存急速下降的部分，查看对应的 EventLog，可以从中找到 GC 的日志。

![bbf1c009611cde23145fe360e47c964d.png](https://img-blog.csdnimg.cn/img_convert/bbf1c009611cde23145fe360e47c964d.png)

**避免策略：**

1. 减少不必要的全局变量，或者生命周期较长的对象，及时对无用的数据进行垃圾回收(**即赋值为null**)；
2. 注意程序逻辑，避免“死循环”之类的 ；
3. 避免创建过多的对象 原则：**不用了的东西要记得及时归还。**
4. 减少层级过多的引用










## 8  数组和对象的区别与联系

​	对象就是**包含 属性/值 的集合**，数组就是**一组 值 的集合**
​	数组具有一个最基本特征：**索引**，这是对象所没有的，通过` 数组名[索引] `可以访问数组元素。数组表示有序数据的集合，而对象表示`无序数据的集合`。如果数据的顺序很重要，就用数组，否则就用对象。

  ① 数组是一个特殊的对象，数组具有对象的所有性质；
  ② 数组*可以*是一个有序的数据集合，而对象是无序的(因为数组是一个特殊的对象，所有如果按照对象的方法操作数组，那么数组也可以是无序的)；
  ③ 数组中的属性会区分数字字符串和普通字符串，如果是数字字符串且强转后数值小于(232−1)，那么我们称该属性为索引属性，数组对索引属性会区别操作；
  ④ 数组默认会有一个`length`属性，该属性与数组索引属性的操作密切关联，该属性具有以下几个特点:
     1.`length`属性值始终大于数组中所有索引属性值(所以如果数组中索引属性值是不连续的，那么`length`值并不能反映数组中元素的个数)；
     2.如果直接对数组中`length`属性赋值，那么数组中所有大于等于`length`属性值的索引属性都会被删除(原型中继承的索引属性除外)

### 「**七种数据类型」**

> **`USONB ---> undefined、symbol、string、object、null、number、boolean`**

**基本类型和引用类型的区别**

**原始值**：存储在`栈（stack）`中的简单数据段，也就是说，它们的值直接存储在变量访问的位置。这是因为这些原始类型占据的空间是固定的，所以可将他们存储在较小的内存区域 – 栈中。这样存储便于迅速查寻变量的值。

基本类型复制值的时候，会重新在变量对象上创建一个新值，然后把值赋值到新变量分配的空间上来（理解为栈中的空间）；



**引用值**：存储在`堆（heap）`中的对象，也就是说，存储在变量处的值是一个指针（point），指向存储对象的内存地址。

引用类型复制时，也会在储存在变量对象中的值复制一份放到为新变量分配的空间上来，但是不同的是新复制的值是一个指针，指向原值所在堆内存中的地址；



### 补充：symbol 的应用场景及作用

Symbol是由ES6规范引入的一项新特性，它的功能类似于一种标识唯一性的ID。

Symbol 是完全不一样的东西。一旦创建后就不可更改，不能对它们设置属性（如果在严格模式下尝试这样做，你将得到一个 TypeError）。它们可以作为属性名，这时它们和字符串的属性名没有什么区别。

另一方面，每个 Symbol 都是独一无二的，不与其它 Symbol 重复（即便是使用相同的 Symbol 描述创建），创建一个 Symbol 就跟创建一个对象一样方便。

**应用场景1：**使用Symbol来作为`对象属性名(key)`

**应用场景2：**使用Symbol来`替代常量`

**应用场景3：**使用Symbol定义`类的私有属性/方法`

**应用场景4：**注册和获取`全局Symbol`



###  typeof NaN 的结果是什么？

NaN 指“不是一个数字”（not a number），NaN 是一个“警戒值”（sentinel value，有特殊用途的常规值），用于指出数字类型中的错误情况，即“执行数学运算没有成功，这是失败后返回的结果”。

```javascript
typeof NaN; // "number"
```

NaN 是一个特殊值，它和自身不相等，是唯一一个非自反（自反，reflexive，即 x === x 不成立）的值。而 NaN !== NaN 为 true。



### isNaN 和 Number.isNaN 函数的区别？

- 函数 isNaN 接收参数后，会尝试将这个参数转换为数值，任何不能被转换为数值的的值都会返回 true，因此非数字值传入也会返回 true ，会影响 NaN 的判断。
- 函数 Number.isNaN 会首先判断传入参数是否为数字，如果是数字再继续判断是否为 NaN ，不会进行数据类型的转换，这种方法对于 NaN 的判断更为准确。



### == 操作符的强制类型转换规则？

对于 `==` 来说，如果对比双方的类型**不一样**，就会进行**类型转换**。假如对比 `x` 和 `y` 是否相同，就会进行如下判断流程：

1. 首先会判断两者类型是否**相同，**相同的话就比较两者的大小；
2. 类型不相同的话，就会进行类型转换；
3. 会先判断是否在对比 `null` 和 `undefined`，是的话就会返回 `true`
4. 判断两者类型是否为 `string` 和 `number`，是的话就会将字符串转换为 `number`

```javascript
1 == '1'
      ↓
1 ==  1
```

1. 判断其中一方是否为 `boolean`，是的话就会把 `boolean` 转为 `number` 再进行判断

```javascript
'1' == true
        ↓
'1' ==  1
        ↓
 1  ==  1
```

1. 判断其中一方是否为 `object` 且另一方为 `string`、`number` 或者 `symbol`，是的话就会把 `object` 转为原始类型再进行判断

```javascript
'1' == { name: 'js' }        ↓'1' == '[object Object]'
```

其流程图如下： ![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c451c19e23dd4726b3f36223b6c18a1e~tplv-k3u1fbpfcp-watermark.awebp)

### JavaScript隐式类型转换规则

首先要介绍`ToPrimitive`方法，这是 JavaScript 中每个值隐含的自带的方法，用来将值 （无论是基本类型值还是对象）转换为基本类型值。如果值为基本类型，则直接返回值本身；如果值为对象，其看起来大概是这样：

```javascript
/**
* @obj 需要转换的对象
* @type 期望的结果类型
*/
ToPrimitive(obj,type)
```

`type`的值为`number`或者`string`。

**（1）当**`type`**为**`number`**时规则如下：**

- 调用`obj`的`valueOf`方法，如果为原始值，则返回，否则下一步；
- 调用`obj`的`toString`方法，后续同上；
- 抛出`TypeError` 异常。

**（2）当**`type`**为**`string`**时规则如下：**

- 调用`obj`的`toString`方法，如果为原始值，则返回，否则下一步；
- 调用`obj`的`valueOf`方法，后续同上；
- 抛出`TypeError` 异常。

可以看出两者的主要区别在于调用`toString`和`valueOf`的先后顺序。默认情况下：

- 如果对象为 Date 对象，则`type`默认为`string`；
- 其他情况下，`type`默认为`number`。

总结上面的规则，对于 Date 以外的对象，转换为基本类型的大概规则可以概括为一个函数：

```javascript
var objToNumber = value => Number(value.valueOf().toString())
objToNumber([]) === 0
objToNumber({}) === NaN
```

而 JavaScript 中的隐式类型转换主要发生在`+、-、*、/`以及`==、>、<`这些运算符之间。而这些运算符只能操作基本类型值，所以在进行这些运算前的第一步就是将两边的值用`ToPrimitive`转换成基本类型，再进行操作。

以下是基本类型的值在不同操作符的情况下隐式转换的规则 （对于对象，其会被`ToPrimitive`转换成基本类型，所以最终还是要应用基本类型转换规则）：

`+`**操作符**

`+`操作符的两边有至少一个`string`类型变量时，两边的变量都会被隐式转换为字符串；其他情况下两边的变量都会被转换为数字。

```javascript
1 + '23' // '123'
 1 + false // 1 
 1 + Symbol() // Uncaught TypeError: Cannot convert a Symbol value to a number
 '1' + false // '1false'
 false + true // 1
```

`-`、`*`、`\`**操作符**

`NaN`也是一个数字

```javascript
1 * '23' // 23
 1 * false // 0
 1 / 'aa' // NaN
```

**对于**`==`**操作符**

操作符两边的值都尽量转成`number`：

```javascript
3 == true // false, 3 转为number为3，true转为number为1
'0' == false //true, '0'转为number为0，false转为number为0
'0' == 0 // '0'转为number为0
```

**对于**`<`**和**`>`**比较符**

如果两边都是字符串，则比较字母表顺序：

```javascript
'ca' < 'bd' // false
'a' < 'b' // true
```

其他情况下，转换为数字再比较：

```javascript
'12' < 13 // true
false > -1 // true
```

以上说的是基本类型的隐式转换，而对象会被`ToPrimitive`转换为基本类型再进行转换：

```javascript
var a = {}
a > 2 // false
```

其对比过程如下：

```javascript
a.valueOf() // {}, 上面提到过，ToPrimitive默认type为number，所以先valueOf，结果还是个对象，下一步
a.toString() // "[object Object]"，现在是一个字符串了
Number(a.toString()) // NaN，根据上面 < 和 > 操作符的规则，要转换成数字
NaN > 2 //false，得出比较结果
```

又比如：

```javascript
var a = {name:'Jack'}
var b = {age: 18}
a + b // "[object Object][object Object]"
```

运算过程如下：

```javascript
a.valueOf() // {}，上面提到过，ToPrimitive默认type为number，所以先valueOf，结果还是个对象，下一步
a.toString() // "[object Object]"
b.valueOf() // 同理
b.toString() // "[object Object]"
a + b // "[object Object][object Object]"
```

### 











## 9  http缓存：强缓存与协商缓存

### 「浏览器缓存机制理解」

![image-20211004204901526](https://gitee.com/wexia/my_pic_bed/raw/master/pics/20211006113234.png)

**`强缓存`：**其实强是强制的意思。当浏览器去请求某个文件的时候，服务端就在response header里面对该文件做了缓存配置。缓存的时间、缓存类型都由服务端控制，具体表现为：

​	response header 的cache-control，常见的设置是max-age public private no-cache no-store等

如下图,  设置了**cahe-control: max-age=31536000,public,immutable**

![image-20210627133939353](https://gitee.com/wexia/my_pic_bed/raw/master/pics/20210627133939.png)

​		**max-age**表示缓存的时间是31536000秒（1年），**public**表示可以被**浏览器和代理服务器**缓存，代理服务器一般可用nginx来做。**immutable**表示该资源永远不变，但是实际上该资源并不是永远不变，它这么设置的意思是为了让用户在刷新页面的时候不要去请求服务器！啥意思？就是说，如果你只设置了`cahe-control:max-age=31536000,public  `这属于强缓存，`每次用户正常打开这个页面`，浏览器会`判断缓存是否过期`，没有过期就从缓存中读取数据；但是有一些 "聪明" 的用户会点击浏览器左上角的刷新按钮去刷新页面，这时候就算资源没有过期（1年没这么快过），浏览器也会直接去请求服务器，这就是额外的请求消耗了，这时候就`相当于是走协商缓存`的流程了（下面会讲到）。如果`cahe-control:max-age=315360000,public`再加个immutable的话，就算用户刷新页面，浏览器也不会发起请求去服务，浏览器会直接从本地磁盘或者内存中读取缓存并返回200状态，看上图的红色框（from memory cache）。这是2015年facebook团队向制定 HTTP 标准的 IETF 工作组提到的建议：他们希望 HTTP 协议能给 Cache-Control 响应头增加一个属性字段表明该资源永不过期，浏览器就没必要再为这些资源发送条件请求了。

### 「强缓存总结」

1. cache-control: max-age=xxxx，public
    客户端和代理服务器都可以缓存该资源；
    客户端在xxx秒的有效期内，如果有请求该资源的需求的话就直接读取缓存,status code:200 ，如果用户做了刷新操作，就向服务器发起http请求
2. cache-control: max-age=xxxx，private
    只让客户端可以缓存该资源；代理服务器不缓存
    客户端在xxx秒内直接读取缓存,status code:200
3. cache-control: max-age=xxxx，immutable
    客户端在xxx秒的有效期内，如果有请求该资源的需求的话就直接读取缓存,status code:200 ，即使用户做了刷新操作，也不向服务器发起http请求
4. cache-control: no-cache
    跳过设置强缓存，但是不妨碍设置协商缓存；一般如果你做了强缓存，只有在强缓存失效了才走协商缓存的，设置了no-cache就不会走强缓存了，每次请求都回询问服务端。
5. cache-control: no-store
    不缓存，这个会让客户端、服务器都不缓存，也就没有所谓的强缓存、协商缓存了。



### 「协商缓存」

​		上面说到的强缓存就是给`资源设置个过期时间`，客户端每次请求资源时都会看是否过期；只有在过期才会去询问服务器。所以，强缓存就是为了给`客户端自给自足`用的。而当某天，客户端请求该资源时发现其过期了，这是就会去请求服务器了，而这时候去请求服务器的这过程就可以设置协商缓存。这时候，协商缓存就是`需要客户端和服务器两端进行交互的`。

**怎么设置协商缓存？**

​	response header里面的设置

```
etag: '5c20abbd-e2e8'
last-modified: Mon, 24 Dec 2018 09:49:49 GMT
```

**etag：**每个文件有一个，改动文件就变了，就是个文件hash，每个文件唯一，就像用webpack打包的时候，每个资源都会有这个东西，如： app.js打包后变为 app.c20abbde.js，加个唯一hash，也是为了解决缓存问题。

**last-modified**：文件的修改时间，精确到秒

​		也就是说，每次请求返回来 response header 中的` etag` 和` last-modified`，在下次请求时在 request header 就把这两个带上，服务端把你带过来的标识进行对比，然后`判断资源是否更改`，如果更改就直接返回新的资源，和更新对应的response header的标识etag、last-modified。如果`资源没有变`，那就不变etag、last-modified，这时候对客户端来说，每次请求都是要进行协商缓存了，即：

​	**`	发请求-->看资源是否过期-->过期-->请求服务器-->服务器对比资源是否真的过期-->没过期-->返回304状态码-->客户端用缓存的老资源。`**

​		这就是一条`完整的协商缓存`的过程。

​		当然，当服务端发现资源真的过期的时候，会走如下流程：

​		**`发请求-->看资源是否过期-->过期-->请求服务器-->服务器对比资源是否真的过期-->过期-->返回200状态码-->客户端如第一次接收该资源一样，记下它的cache-control中的max-age、etag、last-modified等。`**

所以协商缓存步骤总结：

​		 请求资源时，把用户本地该资源的 etag 同时带到服务端，服务端和最新资源做对比。
​		 如果资源**没更改**，返回**304**，浏览器读取本地缓存。
​		 如果资源**有更改**，返回**200**，返回最新的资源。

​	补充一点，response header中的etag、last-modified在客户端重新向服务端发起请求时，会在request header中换个key名：

```csharp
// response header
etag: '5c20abbd-e2e8'
last-modified: Mon, 24 Dec 2018 09:49:49 GMT

// request header 变为
if-none-matched: '5c20abbd-e2e8'
if-modified-since: Mon, 24 Dec 2018 09:49:49 GMT
```

**为什么要有etag？**
 你可能会觉得使用last-modified已经足以让浏览器知道本地的缓存副本是否足够新，为什么还需要etag呢？HTTP1.1中etag的出现（也就是说，etag是新增的，为了解决之前只有If-Modified的缺点）主要是为了解决几个last-modified比较难解决的问题：

1. 一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新get；
2. 某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说1s内修改了N次)，if-modified-since能检查到的粒度是秒级的，这种修改无法判断(或者说UNIX记录MTIME只能精确到秒)；

1. 某些服务器不能精确的得到文件的最后修改时间。

### 「怎么设置强与协商缓存」

![image-20211004205020110](https://gitee.com/wexia/my_pic_bed/raw/master/pics/20211006113218.png)



### 「no-store\no-cache区别」

no-cache 和 no-store 都是 HTTP 协议头 Cache-Control 的值。区别是：

- no-store

  彻底禁用缓冲，所有内容都不会被缓存到缓存或临时文件中。

- no-cache

  在浏览器使用缓存前，会往返对比 ETag，如果 ETag 没变，返回 304，则使用缓存。



### 「http状态码」

| 分类 | 分类描述                                       |
| :--- | :--------------------------------------------- |
| 1**  | 信息，服务器收到请求，需要请求者继续执行操作   |
| 2**  | 成功，操作被成功接收并处理                     |
| 3**  | 重定向，需要进一步的操作以完成请求             |
| 4**  | 客户端错误，请求包含语法错误或无法完成请求     |
| 5**  | 服务器错误，服务器在处理请求的过程中发生了错误 |

![image-20211005141550823](https://gitee.com/wexia/my_pic_bed/raw/master/pics/20211006111452.png)

HTTP状态码列表:

| 状态码 |         状态码英文名称          | 中文描述                                                     |
| :----: | :-----------------------------: | :----------------------------------------------------------- |
|  100   |            Continue             | 继续。[客户端](http://www.dreamdu.com/webbuild/client_vs_server/)应继续其请求 |
|  101   |       Switching Protocols       | 切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议 |
|        |                                 |                                                              |
|  200   |               OK                | 请求成功。一般用于GET与POST请求                              |
|  201   |             Created             | 已创建。成功请求并创建了新的资源                             |
|  202   |            Accepted             | 已接受。已经接受请求，但未处理完成                           |
|  203   |  Non-Authoritative Information  | 非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本 |
|  204   |           No Content            | 无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档 |
|  205   |          Reset Content          | 重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域 |
|  206   |         Partial Content         | 部分内容。服务器成功处理了部分GET请求                        |
|        |                                 |                                                              |
|  300   |        Multiple Choices         | 多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择 |
|  301   |        Moved Permanently        | 永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替 |
|  302   |              Found              | 临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI |
|  303   |            See Other            | 查看其它地址。与301类似。使用GET和POST请求查看               |
|  304   |          Not Modified           | 未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源 |
|  305   |            Use Proxy            | 使用代理。所请求的资源必须通过代理访问                       |
|  306   |             Unused              | 已经被废弃的HTTP状态码                                       |
|  307   |       Temporary Redirect        | 临时重定向。与302类似。使用GET请求重定向                     |
|        |                                 |                                                              |
|  400   |           Bad Request           | 客户端请求的语法错误，服务器无法理解                         |
|  401   |          Unauthorized           | 请求要求用户的身份认证                                       |
|  402   |        Payment Required         | 保留，将来使用                                               |
|  403   |            Forbidden            | 服务器理解请求客户端的请求，但是拒绝执行此请求               |
|  404   |            Not Found            | 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置"您所请求的资源无法找到"的个性页面 |
|  405   |       Method Not Allowed        | 客户端请求中的方法被禁止                                     |
|  406   |         Not Acceptable          | 服务器无法根据客户端请求的内容特性完成请求                   |
|  407   |  Proxy Authentication Required  | 请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权 |
|  408   |        Request Time-out         | 服务器等待客户端发送的请求时间过长，超时                     |
|  409   |            Conflict             | 服务器完成客户端的 PUT 请求时可能返回此代码，服务器处理请求时发生了冲突 |
|  410   |              Gone               | 客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置 |
|  411   |         Length Required         | 服务器无法处理客户端发送的不带Content-Length的请求信息       |
|  412   |       Precondition Failed       | 客户端请求信息的先决条件错误                                 |
|  413   |    Request Entity Too Large     | 由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息 |
|  414   |      Request-URI Too Large      | 请求的URI过长（URI通常为网址），服务器无法处理               |
|  415   |     Unsupported Media Type      | 服务器无法处理请求附带的媒体格式                             |
|  416   | Requested range not satisfiable | 客户端请求的范围无效                                         |
|  417   |       Expectation Failed        | 服务器无法满足Expect的请求头信息                             |
|        |                                 |                                                              |
|  500   |      Internal Server Error      | 服务器内部错误，无法完成请求                                 |
|  501   |         Not Implemented         | 服务器不支持请求的功能，无法完成请求                         |
|  502   |           Bad Gateway           | 作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应 |
|  503   |       Service Unavailable       | 由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中 |
|  504   |        Gateway Time-out         | 充当网关或代理的服务器，未及时从远端服务器获取请求           |
|  505   |   HTTP Version not supported    | 服务器不支持请求的HTTP协议的版本，无法完成处理               |



## 10  ES6中Set、Map以及WeakMap

#### 「Set 实例属性和方法」

Set 是 ES6 新增的有序列表集合，它不会包含重复项。之前我们通常用对象（Object）或者数组（Array）来实现没有重复项的集合。但对象会对 key 进行 toString() 操作，这会导致某些 key 会意外覆盖之前的数据；如果 key 本身是一个对象，toString() 也得不到想要的结果。

**Set 实例属性:**

```
Set.prototype.constructor：构造函数，默认就是Set函数。
Set.prototype.size：返回Set实例的成员总数。
```

**Set 实例方法: **
分为两大类：**操作方法（用于操作数据）和遍历方法（用于遍历成员）**。

```
add(value)：添加某个值，返回 Set 结构本身。
delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。
has(value)：返回一个布尔值，表示该值是否为Set的成员。
clear()：清除所有成员，没有返回值。
```

遍历操作

```
Set 结构的实例有四个遍历方法，可以用于遍历成员:
keys()：返回键名的遍历器
values()：返回键值的遍历器
entries()：返回键值对的遍历器
forEach()：使用回调函数遍历每个成员
```



#### 「Map 实例属性和方法」

Map 是 ES6 新增的有序键值对集合。键值对的 key 和 value 都可以是任何类型的元素。通过 set(key, value) 方法为 Map 设置新的键值对，如果设置的 key 已经存在则用新的 value 覆盖，Map 在比较 key 时也不做类型转换，跟 Set 类似；Map 的 get(key) 方法用来获取指定 key 的值；Map 的 has(key) 、 delete(key) 、clear() 这些方法和 size 属性，与 Set 类似

**size: 属性返回 Map 结构的成员总数**

**实例方法（基本上同Set）：**

```
set(key, value): 返回的是当前的Map对象，因此可以采用链式写法。
get(key)：读取key对应的键值，如果找不到key，返回undefined。
has(key)
delete(key)
clear()
```

**遍历方法**
Map 结构原生提供三个遍历器生成函数和一个遍历方法。

```
keys()：返回键名的遍历器。
values()：返回键值的遍历器。
entries()：返回所有成员的遍历器。
forEach()：遍历 Map 的所有成员。
```



#### 「WeakMap」

​	WeakMap 相对于普通的 Map，也是键值对集合，只不过 WeakMap 的 key 只能是`非空对象（non-null object）`。WeakMap 对它的 key 仅保持弱引用，也就是说它不阻止垃圾回收器回收它所引用的 key。WeakMap 最大的好处是可以避免`内存泄漏`。一个仅被 WeakMap 作为 key 而引用的对象，会被垃圾回收器回收掉。

​	WeakMap 拥有和 Map 类似的 set(key, value) 、get(key)、has(key)、delete(key) 和 clear() 方法，但没有 size 属性，也没有任何与迭代有关的方法。





## 11  手撕Promise函数

![image-20211004195751987](https://gitee.com/wexia/my_pic_bed/raw/master/pics/20211006110259.png)



```
class Promise{
    //构造方法
    constructor(executor){
        //添加属性
        this.PromiseState = 'pending';
        this.PromiseResult = null;
        //声明属性
        this.callbacks = [];
        //保存实例对象的 this 的值
        const self = this;// self _this that
        //resolve 函数
        function resolve(data){
            //判断状态
            if(self.PromiseState !== 'pending') return;
            //1. 修改对象的状态 (promiseState)
            self.PromiseState = 'fulfilled';// resolved
            //2. 设置对象结果值 (promiseResult)
            self.PromiseResult = data;
            //调用成功的回调函数
            setTimeout(() => {
                self.callbacks.forEach(item => {
                    item.onResolved(data);
                });
            });
        }
        //reject 函数
        function reject(data){
            //判断状态
            if(self.PromiseState !== 'pending') return;
            //1. 修改对象的状态 (promiseState)
            self.PromiseState = 'rejected';// 
            //2. 设置对象结果值 (promiseResult)
            self.PromiseResult = data;
            //执行失败的回调
            setTimeout(() => {
                self.callbacks.forEach(item => {
                    item.onRejected(data);
                });
            });
        }
        try{
            //同步调用『执行器函数』
            executor(resolve, reject);
        }catch(e){
            //修改 promise 对象状态为『失败』
            reject(e);
        }
    }

    //then 方法封装
    then(onResolved,onRejected){
        const self = this;
        //判断回调函数参数
        if(typeof onRejected !== 'function'){
            onRejected = reason => {
                throw reason;
            }
        }
        if(typeof onResolved !== 'function'){
            onResolved = value => value;
            //value => { return value};
        }
        return new Promise((resolve, reject) => {
            //封装函数
            function callback(type){
                try{
                    //获取回调函数的执行结果
                    let result = type(self.PromiseResult);
                    //判断
                    if(result instanceof Promise){
                        //如果是 Promise 类型的对象
                        result.then(v => {
                            resolve(v);
                        }, r=>{
                            reject(r);
                        })
                    }else{
                        //结果的对象状态为『成功』
                        resolve(result);
                    }
                }catch(e){
                    reject(e);
                }
            }
            //调用回调函数  PromiseState
            if(this.PromiseState === 'fulfilled'){
                setTimeout(() => {
                    callback(onResolved);
                });
            }
            if(this.PromiseState === 'rejected'){
                setTimeout(() => {
                    callback(onRejected);
                });
            }
            //判断 pending 状态
            if(this.PromiseState === 'pending'){
                //保存回调函数
                this.callbacks.push({
                    onResolved: function(){
                        callback(onResolved);
                    },
                    onRejected: function(){
                        callback(onRejected);
                    }
                });
            }
        })
    }

    //catch 方法
    catch(onRejected){
        return this.then(undefined, onRejected);
    }

    //添加 resolve 方法
    static resolve(value){
        //返回promise对象
        return new Promise((resolve, reject) => {
            if(value instanceof Promise){
                value.then(v=>{
                    resolve(v);
                }, r=>{
                    reject(r);
                })
            }else{
                //状态设置为成功
                resolve(value);
            }
        });
    }

    //添加 reject 方法
    static reject(reason){
        return new Promise((resolve, reject)=>{
            reject(reason);
        });
    }

    //添加 all 方法
    static all(promises){
        //返回结果为promise对象
        return new Promise((resolve, reject) => {
            //声明变量
            let count = 0;
            let arr = [];
            //遍历
            for(let i=0;i<promises.length;i++){
                //
                promises[i].then(v => {
                    //得知对象的状态是成功
                    //每个promise对象 都成功
                    count++;
                    //将当前promise对象成功的结果 存入到数组中
                    arr[i] = v;
                    //判断
                    if(count === promises.length){
                        //修改状态
                        resolve(arr);
                    }
                }, r => {
                    reject(r);
                });
            }
        });
    }

    //添加 race 方法
    static race (promises){
        return new Promise((resolve, reject) => {
            for(let i=0;i<promises.length;i++){
                promises[i].then(v => {
                    //修改返回对象的状态为 『成功』
                    resolve(v);
                },r=>{
                    //修改返回对象的状态为 『失败』
                    reject(r);
                })
            }
        });
    }
}   
```

**class类封装**：在`js`的类中，可分为三种方法，`constructor构造方法、静态方法与普通方法`。

#### 「constructor构造方法」

**1.概念**

​		类的作用在于构建对象，而constructor构造方法就是用于构建对象实例。

**2.使用方法**

​		在使用new关键字生成对象时，constructor方法会被执行，最终return的结果就是生成的对象实例。
​		当一个类没有constructor方法时会自动生成一个空的constructor方法，返回结果为空。
​		用new关键字实例化对象时传入的参数会做为constructor构造函数的参数传入。

```
class Point {
    constructor(name) {
        console.log('Instantiate objects:'+ name);
    }
}
new Point('testObj');
//Instantiate objects:testObj
```



> `constructor`才是**实例A的构造函数**，写在constructor外部的可以理解为绑定**在构造函数的原型**上

​		constructor 方法是类的构造函数，是一个默认方法，通过 new 命令创建对象实例时，自动调用该方法。一个类必须有 constructor 方法，如果没有显式定义，一个默认的 consructor 方法会被默认添加。所以即使你没有添加构造函数，也是会有一个默认的构造函数的。一般 constructor 方法返回实例对象 this ，但是也可以指定 constructor 方法返回一个全新的对象，让返回的实例对象不是该类的实例。



> `super` 这个关键字，既可以当做函数使用，也可以当做对象使用。这两种情况下，它的用法完全不用。

**1  当做函数使用**

```
class A {}
class B extends A {
  constructor() {
    super();  // ES6 要求，子类的构造函数必须执行一次 super 函数，否则会报错。
  }
}
```

**注：在 constructor 中必须调用 super 方法，**因为子类没有自己的 this 对象，而是继承父类的 this 对象，然后对其进行加工,而 super 就代表了父类的构造函数。super 虽然代表了父类 A 的构造函数，但是返回的是子类 B 的实例，即 super 内部的 this 指的是 B，因此 super() 在这里相当于 ```A.prototype.constructor.call(this, props)``。

**2   当作对象使用**

在普通方法中，指向父类的原型对象；在静态方法中，指向父类。

```
class A {
  c() {
    return 2;
  }
}
 
class B extends A {
  constructor() {
    super();
    console.log(super.c()); // 2
  }
}
 
let b = new B();
```

上面代码中，子类 B 当中的 super.c()，就是将 super 当作一个对象使用。这时，super 在普通方法之中，指向 A.prototype，所以 super.c() 就相当于 A.prototype.c()。



`通过 super 调用父类的方法时，super 会绑定子类的 this。`

```
class A {
  constructor() {
    this.x = 1;
  }
  s() {
    console.log(this.x);
  }
}
 
class B extends A {
  constructor() {
    super();
    this.x = 2;
  }
  m() {
    super.s();
  }
}
 
let b = new B();
b.m(); // 2
```

上面代码中，`super.s()` 虽然调用的是 `A.prototytpe.s()`，但是 `A.prototytpe.s()`会绑定子类 B 的 `this`，导致输出的是 2，而不是 1。也就是说，实际上执行的是 `super.s.call(this)`。



由于绑定子类的 `this`，所以如果通过 `super` 对某个属性赋值，这时 `super` 就是 `this`，赋值的属性会变成子类实例的属性。

```
class A {
  constructor() {
    this.x = 1;
  }
}
 
class B extends A {
  constructor() {
    super();
    this.x = 2;
    super.x = 3;
    console.log(super.x); // undefined
    console.log(this.x); // 3
  }
}
 
let b = new B();
```

上面代码中，`super.x` 赋值为 3，这时等同于对 `this.x` 赋值为 3。而当读取 `super.x` 的时候，调用的是 `A.prototype.x`，但并没有 `x` 方法，所以返回 undefined。



#### 「普通方法」

**1.概念**

​	class类的普通方法可以看作是构造函数的另一种写法，相当于在类的prototype属性上上边定义方法。

**2.使用方法**

​		(1).该类实例化的对象上使用此方法

```
class Point {
    toString() {
        // ...
    }
}

let obj = new Point();
obj.toString();
```

​		(2).直接通过该类的prototype调用此方法

```
class Point {
    toString() {
        // ...
    }
}

Point.prototype.toString();
```

​		(3).通过子类的`__proto__`调用

```
class Foo {
  commonMethod() {
    return 'hello';
  }
}

class Bar extends Foo {
}

Bar.__proto__.prototype.commonMethod();
```



#### 「静态方法」

**1.概念**

​	类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法**`不会被实例继承`**，而是直接通过类来调用（通过类调用指**在该类之外调用**），这就称为“静态方法”。

**2.使用方法**

​	静态方法只能在当前类上调用，不能被该类的实例对象调用。父类的静态方法可以被子类继承。

​	因此静态方法被调用的方式一共有三种(三种调用方式都在下面一段代码中使用到了，请耐心阅读)：
​		\- 父类直接调用
​		\- 子类继承父类后调用
​		\- 子类通过super对象调用

```
class Foo {
  static classMethod() {
    return 'hello';
  }
}

Foo.classMethod();  //hello

class Bar extends Foo {
}

class Cla extends Foo {
    return super.classMethod(); //hello
}

Bar.classMethod();  //hello
```

| 对比     | 静态方法                                                     | 普通方法                                                     | 构造方法                                                   |
| -------- | :----------------------------------------------------------- | :----------------------------------------------------------- | ---------------------------------------------------------- |
| 关键字   | static                                                       | 无                                                           | constructor                                                |
| 使用场景 | 声明一个仅供当前类或当前类的子类使用的方法                   | 创建实例化对象可直接调用的方法                               | 在用new关键字通过此类实例化对象时执行的方法                |
| 使用对象 | 当前类或当前类的子类                                         | 通过该类或该类的子类实例化生成的对象                         | 该类自身                                                   |
| 调用方法 | 1.父类直接调用<br />2.子类继承父类后调用<br />3.子类通过super对象调用 | 1.通过该类及该类的子类实例生成的对象调用<br/>2.该类通过prototype调用<br/>3.该类的子类通过__proto__隐式原型链调用 | 1.该类实例化对象时调用<br/>2.该类的子类使用super关键字调用 |

注：在class类中，它的静态属性与普通属性允许重名。但是不建议重名，这里就不给出demo了

**示例demo**

```
class Person{
    constructor() {
        // 添加到 this 的所有内容都会存在于不同的实例上
        this.locate = () => console.log('instance',this);
    }
    
    // 定义在类的原型对象上
    locate(){
        console.log('prototype', this);
    }
    
    // 定义在类本身上
    static locate(){
        console.log('class',this);
    }
}

let p = new Person();

p.locate();                  // instance, Person()
Person.prototype.locate();   // prototype. {constructor: ... }
Person.locate();             // class, class Person { }

```



## 12  浏览器多线程与JS单线程问题

#### 「浏览器的线程」

![image-20211004203913088](https://gitee.com/wexia/my_pic_bed/raw/master/pics/20211004203914.png)

**浏览器的渲染进程是多线程的。js则是单线程的**

![image-20210905150642038](https://gitee.com/wexia/my_pic_bed/raw/master/pics/20210905150646.png)

① 图形用户界面GUI渲染线程

- 负责渲染浏览器界面，包括解析HTML、CSS、构建DOM树、Render树、布局与绘制等
- 当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行

② JS引擎线程

- JS内核，也称JS引擎，负责处理执行javascript脚本
- 等待任务队列的任务的到来，然后加以处理，浏览器无论什么时候都只有一个JS引擎在运行JS程序

③ 事件触发线程

- 听起来像JS的执行，但是其实归属于浏览器，而不是JS引擎，用来控制时间循环（可以理解，JS引擎自己都忙不过来，需要浏览器另开线程协助）
- 当JS引擎执行代码块如setTimeout时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求等），会将对应任务添加到事件线程中
- 当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理
- 注意：由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行）

④ 定时触发器线程

- `setInterval`与`setTimeout`所在线程
- 定时计时器并不是由JS引擎计时的，因为如果JS引擎是单线程的，如果JS引擎处于堵塞状态，那会影响到计时的准确
- 当计时完成被触发，事件会被添加到事件队列，等待JS引擎空闲了执行
- 注意：W3C的HTML标准中规定，setTimeout中低与`4ms`的时间间隔算为`4ms`

⑤ 异步HTTP请求线程

- 在XMLHttpRequest在连接后新启动的一个线程
- 线程如果检测到请求的状态变更，如果设置有回调函数，该线程会把回调函数添加到事件队列，同理，等待JS引擎空闲了执行



#### 「浏览器内核中线程之间的关系」

> **GUI渲染线程与JS引擎线程互斥**

​		因为JS引擎可以修改DOM树，那么如果JS引擎在执行修改了DOM结构的同时，GUI线程也在渲染页面，那么这样就会导致渲染线程获取的DOM的元素信息可能与JS引擎操作DOM后的结果不一致。		为了防止这种现象，GUI线程与JS线程需要设计为互斥关系，当JS引擎执行的时候，GUI线程需要被冻结，但是GUI的渲染会被保存在一个队列当中，等待JS引擎空闲的时候执行渲染。
​		由此也可以推出，如果JS引擎正在进行CPU密集型计算，那么JS引擎将会阻塞，长时间不空闲，导致渲染进程一直不能执行渲染，页面就会看起来卡顿卡顿的，渲染不连贯，所以，要尽量避免JS执行时间过长。

> **JS引擎线程与事件触发线程、定时触发器线程、异步HTTP请求线程**

​		事件触发线程、定时触发器线程、异步HTTP请求线程三个线程有一个共同点，那就是使用回调函数的形式，当满足了特定的条件，这些回调函数会被执行。这些回调函数被浏览器内核理解成事件，在浏览器内核中拥有一个事件队列，这三个线程当满足了内部特定的条件，会将这些回调函数添加到事件队列中，等待JS引擎空闲执行。例如异步HTTP请求线程，线程如果检测到请求的状态变更，如果设置有回调函数，回调函数会被添加事件队列中，等待JS引擎空闲了执行。
​		但是，JS引擎对事件队列（宏任务）与JS引擎内的任务（微任务）执行存在着先后循序，当每执行完一个事件队列的时间，JS引擎会检测内部是否有未执行的任务，如果有，将会优先执行（微任务）。



#### 「WebWorker、SharedWorker」

​		因为JS引擎是单线程的，当JS执行时间过长会**页面阻塞**，为了解决这个问题，HTML5中支持了` web worker`。

​		Web Workers 使得一个Web应用程序可以在**与主执行线程分离的后台线程**中运行一个脚本操作。这样做的好处是可以在一个单独的线程中执行费时的处理任务，从而允许主（通常是UI）线程运行而不被阻塞/放慢。

​		如果需要进行一些高耗时的计算时，可以单独开启一个`WebWorker`线程，这样不管这个`WebWorker`子线程怎么密集计算、怎么阻塞，都不会影响JS引擎主线程，只需要等计算结束，将结果通过`postMessage`传输给主线程就可以了。

另外，还有个东西叫 `SharedWorker`，与WebWorker在概念上所不同。

- WebWorker 只属于某一个页面，不会和其他标签页的Renderer进程共享，WebWorker是属于Renderer进程创建的进程。
- SharedWorker 是由浏览器单独创建的进程来运行的JS程序，它被所有的Renderer进程所共享，在浏览器中，最多只能存在一个SharedWorker进程。

SharedWorker由进程管理，WebWorker是某一个Renderer进程下的线程。

SharedWorker的实质在于share，不同的线程可以共享一个线程，他们的数据也是共享的。



#### 「WebSocket」

WebSocket是一种网络通信协议，是 `HTML5` 开始提供的一种在`单个TCP连接上`进行`全双工通讯`的协议。WebSocket用于在Web浏览器和服务器之间进行**任意的双向数据传输**的一种技术。WebSocket协议**基于TCP协议**实现，包含初始的握手过程，以及后续的多次数据帧双向传输过程。其目的是在WebSocket应用和WebSocket服务器进行频繁双向通信时，可以使服务器避免打开多个HTTP连接进行工作来节约资源，提高了工作效率和资源利用率。


**诞生原因：**

- 因为 HTTP 协议有一个缺陷：通信只能由客户端发起
- 我们都知道轮询的效率低，非常浪费资源（因为必须不停连接，或者 HTTP 连接始终打开）, 因此websocket应运而生。

https://blog.csdn.net/sinat_36422236/article/details/85051547



#### 「宏任务微任务顺序判断」

**`宏任务`**:为了协调这些任务有条不紊地在主线程上执行，页面进程引入了 消息队列 和 事件循环机制 ，渲染进程内部会维护多个消息队列，比如延迟执行队列和普通的消息队列。然后主线程采用一个 for循环，不断地从这些任务队列中取出任务并执行任务。

​		宏任务包含： script(整体代码)、setTimeout()、setInterval()、postMessage、I/O、UI交互事件

**`微任务`**就是一个需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前。

 **产生微任务的两种方式：**

​		第一种方式是使用 **MutationObserver 监控某个 DOM 节点**，然后再通过 JavaScript 来修改这个节点，或者为这个节点添加、删除部分子节点，当 DOM 节点发生变化时，就会产生 DOM 变化记录的微任务。
​		第二种方式是**使用 Promise** ，当调用` Promise.resolve() `或者` Promise.reject() `的时候，也会产生微任务。

![image-20210719223459261](https://gitee.com/wexia/my_pic_bed/raw/master/pics/20210721194012.png)

​		Microtask （微任务）虽然是队列，但并不是一个一个放入执行栈，而是当执行栈清空，会执行全部Microtask （微任务）队列中的任务，最后才是取回调队列的第一个 Macrotask (宏任务)

​		通常情况下，在当前宏任务中的 JavaScript 快执行完成时，也就在 JavaScript 引擎准备退出全局执行上下文并清空调用栈的时候， JavaScript 引擎会`检查全局执行上下文中的微任务队列`，然后按照顺序执行队列中的微任务。WHATWG 把执行微任务的时间点称为 检查点。

​		如果在执行微任务的过程中，产生了新的微任务，同样会将该微任务添加到微任务队列中，V8 引擎一直循环执行微任务队列中的任务，直到队列为空才算执行结束。也就是说 在`执行微任务过程中产生的新的微任务并不会推迟到下个宏任务中执行`，而是在当前的宏任务中继续执行。

​		**`async和await函数的影响`**：async 函数返回一个 Promise 对象，当函数执行的时候，一旦遇到 await 就会先返回，等到触发的异步操作完成，再接着执行函数体内后面的语句。(MDN描述：async 函数中可能会有 await 表达式，这会使 async 函数暂停执行，等待表达式中的 Promise 解析完成后继续执行 async 函数并返回解决结果。) ------->  意思就是` await` 表达式的存在会让出线程(`跳出async函数体`)，然后继续执行后面的脚本。



**经典例题：**

```
async function async1() {
  console.log('async1 start')
  await async2()
  console.log('async1 end')
}
async function async2() {
  console.log('async2')
}
console.log('script start')
setTimeout(function () {
  console.log('setTimeout')
}, 0)
async1()
new Promise(function (resolve) {
  console.log('promise1')
  resolve()
}).then(function () {
  console.log('promise2')
})
console.log('script end')
```

```
// 最终输出
script start
async1 start
async2
promise1
script end
async1 end
promise2
setTimeout
```

**解释说明：**

**`总体思路就是：先执行宏任务（当前代码块也算是宏任务），然后执行当前宏任务产生的微任务，然后接着执行宏任务`**
		1  从上往下执行代码，先执行同步代码，输出 script start
		2  遇到` setTimeout` ，现把 `setTimeout` 的代码放到宏任务队列中
		3  执行 `async1()` ，输出` async1 start` , 然后执行` async2() `, 输出 `async2 `，由于`aysnc2`存在`await`，于是运行完之后会让出线程，把 `async2() `后面的代码 `console.log('async1 end') `放到微任务队列中
		4  接着往下执行，输出 promise1 ，把 .then() 放到微任务队列中；**注意 Promise 本身是同步的立即执行函数，.then是异步执行函数**
		5  接着往下执行， 输出 script end 。同步代码（同时也是宏任务）执行完成，接下来开始执行刚才放到微任务中的代码
		6  依次执行微任务中的代码，依次输出 async1 end 、 promise2 , 微任务中的代码执行完成后，开始执行宏任务中的代码，输出 setTimeout



## 13  JavaScript常见六种继承方式

![img](http://img-repo.poetries.top/images/20210414142754.png)

#### 「原型链继承」

​	这种方式关键在于:**子类型的原型为父类型的一个实例对象。**

       //父类型
       function Person(name, age) {
           this.name = name,
           this.age = age,
           this.play = [1, 2, 3]
           this.setName = function () { }
       }
       Person.prototype.setAge = function () { }
       //子类型
       function Student(price) {
           this.price = price
           this.setScore = function () { }
       }
       Student.prototype = new Person() // 子类型的原型为父类型的一个实例对象
       var s1 = new Student(15000)
       var s2 = new Student(14000)
       console.log(s1,s2)

![image-20210914095956516](https://gitee.com/wexia/my_pic_bed/raw/master/pics/20210915114656.png)

​		实现的本质是通过将子类的原型指向了父类的实例，所以**子类的实例就可以通过__proto__访问到 Student.prototype 也就是Person的实例，这样就可以访问到父类的私有方法，然后再通过__proto__指向父类的prototype就可以获得到父类原型上的方法**。于是做到了将父类的私有、公有方法和属性都当做子类的公有属性。

​	**子类继承父类的属性和方法是将父类的私有属性和公有方法都作为自己的公有属性和方法**，我们都知道在操作基本数据类型的时候操作的是值，在操作引用数据类型的时候操作的是地址，如果说父类的私有属性中有引用类型的属性，那它被子类继承的时候会作为公有属性，这样子类1操作这个属性的时候，就会影响到子类2。

​	**我们需要在子类中添加新的方法或者是重写父类的方法时候，切记一定要放到替换原型的语句之后**

       function Person(name, age) {
           this.name = name,
           this.age = age
       }
       Person.prototype.setAge = function () {
           console.log("111")
       }
       function Student(price) {
           this.price = price
           this.setScore = function () { }
       }
       // Student.prototype.sayHello = function () { }//在这里写子类的原型方法和属性是无效的，
      //因为会改变原型的指向，所以应该放到重新指定之后
       Student.prototype = new Person()
       Student.prototype.sayHello = function () { }
       var s1 = new Student(15000)
       console.log(s1)

> **特点**：

- 父类新增原型方法/原型属性，子类都能访问到
- 简单，易于实现

> **缺点**：

- 无法实现多继承
- 来自原型对象的所有属性被所有实例共享
- 创建子类实例时，无法向父类构造函数传参
- 要想为子类新增属性和方法，必须要在`Student.prototype = new Person()` 之后执行，不能放到构造器中



#### 「借用构造函数继承」

这种方式关键在于:**在子类型构造函数中调用call()或者apply()方法绑定父类型构造函数**

```
function Person(name, age) {
    this.name = name,
    this.age = age,
    this.setName = function () {}
  }
  Person.prototype.setAge = function () {}
  function Student(name, age, price) {
    Person.call(this, name, age)  // 相当于: this.Person(name, age)
    /*this.name = name
    this.age = age*/
    this.price = price
  }
  var s1 = new Student('Tom', 20, 15000)
```

![image-20210914100355207](https://gitee.com/wexia/my_pic_bed/raw/master/pics/20210915114657.png)

这种方式只是实现部分的继承，如果父类的原型还有方法和属性，子类是拿不到这些方法和属性的。

> **特点**：

- 解决了原型链继承中子类实例共享父类引用属性的问题
- 创建子类实例时，可以向父类传递参数
- 可以实现多继承(call多个父类对象)

> **缺点**：

- 实例并不是父类的实例，只是子类的实例
- 只能继承父类的实例属性和方法，不能继承原型属性和方法
- 无法实现函数复用，每个子类都有父类实例函数的副本，影响性能



#### 「原型链+借用构造函数--继承」

这种方式关键在于:**通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用。**

        function Person(name, age) {
            this.name = name,
            this.age = age,
            this.setAge = function () { }
        }
        Person.prototype.setAge = function () {
            console.log("111")
        }
        function Student(name, age, price) {
            Person.call(this,name,age)
            this.price = price
            this.setScore = function () { }
        }
        Student.prototype = new Person()
        Student.prototype.constructor = Student//组合继承也是需要修复构造函数指向的
        Student.prototype.sayHello = function () { }
        var s1 = new Student('Tom', 20, 15000)
        var s2 = new Student('Jack', 22, 14000)
        console.log(s1)
        console.log(s1.constructor) //Student
        console.log(p1.constructor) //Person

![image-20210914100421628](https://gitee.com/wexia/my_pic_bed/raw/master/pics/20210915114658.png)

这种方式融合原型链继承和构造函数的优点，是 JavaScript 中最常用的继承模式。不过也存在缺点就是无论在什么情况下，都会调用两次构造函数：一次是在创建子类型原型的时候，另一次是在子类型构造函数的内部，子类型最终会包含父类型对象的全部实例属性，但我们不得不在调用子类构造函数时重写这些属性。

> **优点**：

- 可以继承实例属性/方法，也可以继承原型属性/方法
- 不存在引用属性共享问题
- 可传参
- 函数可复用

> **缺点**：

- 调用了两次父类构造函数，生成了两份实例



#### 「组合继承优化1」

**这种方式通过父类原型和子类原型指向同一对象，子类可以继承到父类的公有方法当做自己的公有方法，而且不会初始化两次实例方法/属性，避免的组合继承的缺点**。

       function Person(name, age) {
            this.name = name,
                this.age = age,
                this.setAge = function () { }
        }
        Person.prototype.setAge = function () {
            console.log("111")
        }
        function Student(name, age, price) {
            Person.call(this, name, age)
            this.price = price
            this.setScore = function () { }
        }
        Student.prototype = Person.prototype
        Student.prototype.sayHello = function () { }
        var s1 = new Student('Tom', 20, 15000)
        console.log(s1)

![image-20210914100500995](https://gitee.com/wexia/my_pic_bed/raw/master/pics/20210915114659.png)

但这种方式没办法辨别是对象是子类还是父类实例化

> **优点**：

- 不会初始化两次实例方法/属性，避免的组合继承的缺点

> **缺点**：

- 没办法辨别是实例是子类还是父类创造的，子类和父类的构造函数指向是同一个。

  

#### 「寄生组合继承」

**借助原型可以基于已有的对象来创建对象，`var B = Object.create(A)`以A对象为原型，生成了B对象。B继承了A的所有属性和方法。**

       function Person(name, age) {
            this.name = name,
            this.age = age
        }
        Person.prototype.setAge = function () {
            console.log("111")
        }
        function Student(name, age, price) {
            Person.call(this, name, age)
            this.price = price
            this.setScore = function () {}
        }
        Student.prototype = Object.create(Person.prototype)//核心代码
        Student.prototype.constructor = Student//核心代码
        var s1 = new Student('Tom', 20, 15000)
        console.log(s1 instanceof Student, s1 instanceof Person) // true true
        console.log(s1.constructor) //Student
        console.log(s1)

![image-20210914100534619](https://gitee.com/wexia/my_pic_bed/raw/master/pics/20210915114700.png)

同样的，Student继承了所有的Person原型对象的属性和方法。目前来说，最完美的继承方法



#### 「ES6中class 的继承」

ES6中引入了class关键字，class可以通过extends关键字实现继承，还可以通过static关键字定义类的静态方法,这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。

ES5 的继承，实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面（Parent.apply(this)）。ES6 的继承机制完全不同，实质是先将父类实例对象的属性和方法，加到this上面（所以必须先调用super方法），然后再用子类的构造函数修改this。

**需要注意的是，class关键字只是原型的语法糖，JavaScript继承仍然是基于原型实现的**。

       class Person {
            //调用类的构造方法
            constructor(name, age) {
                this.name = name
                this.age = age
            }
            //定义一般的方法
            showName() {
                console.log("调用父类的方法")
                console.log(this.name, this.age);
            }
        }
        let p1 = new  Person('kobe', 39)
        console.log(p1)
        //定义一个子类
        class Student extends Person {
            constructor(name, age, salary) {
                super(name, age)//通过super调用父类的构造方法
                this.salary = salary
            }
            showName() {//在子类自身定义方法
                console.log("调用子类的方法")
                console.log(this.name, this.age, this.salary);
            }
        }
        let s1 = new Student('wade', 38, 1000000000)
        console.log(s1)
        s1.showName()

![image-20210914100551755](https://gitee.com/wexia/my_pic_bed/raw/master/pics/20210915114701.png)

**优点**：

- 语法简单易懂,操作更方便

**缺点**：

- 并不是所有的浏览器都支持class关键字



**ES5 和 ES6 继承的区别：**

- ES6 继承的子类需要调用 `super()` 才能拿到子类，ES5 的话是通过 `apply` 这种绑定的方式
- 类声明不会提升，和 `let` 这些一致



## 14  Proxy代理ES6

#### 「Proxy概述」

​		可以把Proxy看作是一个拦截器，外界对该对象的访问，都必须先通过这层拦截，可以对目标对象的访问进行过滤和改写。proxy实例可以拦截对象的属性读取、赋值、删除、通过`definedProperty`定义等操作外，还可以拦截到对象被当作方法调用还是构造函数使用等操作。

ES6 原生提供 Proxy 构造函数，用来生成 Proxy 实例。

```javascript
var proxy = new Proxy(target, handler);
```

Proxy 对象的所有用法，都是上面这种形式，不同的只是handler参数的写法。其中，new Proxy()表示生成一个Proxy实例，target参数表示所要拦截的目标对象，handler参数也是一个对象，用来定制拦截行为。

> 注意，要使得Proxy起作用，必须针对Proxy实例进行操作，而不是针对目标对象进行操作。

如果handler没有设置任何拦截，那就等同于直接通向原对象。

一个技巧是将 Proxy 对象，设置到`object.proxy`属性，从而可以在`object对象`上调用。

```
var object = { proxy: new Proxy(target, handler) };
```

Proxy 实例也可以作为`其他对象的原型对象`。

```
var proxy = new Proxy({}, {
  get: function(target, propKey) {
    return 35;
  }
});

let obj = Object.create(proxy);
obj.time // 35

// 上面代码中，proxy对象是obj对象的原型，obj对象本身并没有time属性，所以根据原型链，会在proxy对象上读取该属性，导致被拦截。
```

同一个拦截器函数，可以设置拦截多个操作。

对于可以设置、但没有设置拦截的操作，则直接落在目标对象上，按照原先的方式产生结果。

**下面是 Proxy 支持的拦截操作一览，一共 13 种。**

- get(target, propKey, receiver)：拦截对象属性的读取，比如proxy.foo和proxy['foo']。
- set(target, propKey, value, receiver)：拦截对象属性的设置，比如proxy.foo = v或proxy['foo'] = v，返回一个布尔值。
- has(target, propKey)：拦截propKey in proxy的操作，返回一个布尔值。
- deleteProperty(target, propKey)：拦截delete proxy[propKey]的操作，返回一个布尔值。
- ownKeys(target)：拦截Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)、for...in循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而Object.keys()的返回结果仅包括目标对象自身的可遍历属性。
- getOwnPropertyDescriptor(target, propKey)：拦截Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象。
- defineProperty(target, propKey, propDesc)：拦截Object.defineProperty(proxy, propKey, propDesc）、Object.defineProperties(proxy, propDescs)，返回一个布尔值。
- preventExtensions(target)：拦截Object.preventExtensions(proxy)，返回一个布尔值。
- getPrototypeOf(target)：拦截Object.getPrototypeOf(proxy)，返回一个对象。
- isExtensible(target)：拦截Object.isExtensible(proxy)，返回一个布尔值。
- setPrototypeOf(target, proto)：拦截Object.setPrototypeOf(proxy, proto)，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。
- apply(target, object, args)：拦截 Proxy 实例作为函数调用的操作，比如proxy(...args)、proxy.call(object, ...args)、proxy.apply(...)。
- construct(target, args)：拦截 Proxy 实例作为构造函数调用的操作，比如new proxy(...args)。



#### 「Proxy实例的方法」

**`get()`**

get方法用于拦截某个属性的`读取操作`，可以接受三个参数，依次为目标对象、属性名和 proxy 实例本身（严格地说，是操作行为所针对的对象），其中最后一个参数可选。

```
var person = {
  name: "张三"
};
 
var proxy = new Proxy(person, {
  get: function(target, propKey) {
    if (propKey in target) {
      return target[propKey];
    } else {
      throw new ReferenceError("Prop name \"" + propKey + "\" does not exist.");
    }
  }
});
 
proxy.name // "张三"
proxy.age // 抛出一个错误

//上面代码表示，如果访问目标对象不存在的属性，会抛出一个错误。如果没有这个拦截函数，访问不存在的属性，只会返回undefined。
```

**get()方法可以继承**

```
let proto = new Proxy({}, {
  get(target, propertyKey, receiver) {
    console.log('GET ' + propertyKey);
    return target[propertyKey];
  }
});
 
let obj = Object.create(proto);
obj.foo // "GET foo"

// 上面代码中，拦截操作定义在Prototype对象上面，所以如果读取obj对象继承的属性时，拦截会生效
```



**`set()`**

set方法用来拦截某个属性的`赋值操作`，可以接受四个参数，依次为目标对象、属性名、属性值和 Proxy 实例本身，其中最后一个参数可选。

```
// 假定Person对象有一个age属性，该属性应该是一个不大于 200 的整数，那么可以使用Proxy保证age的属性值符合要求。

let validator = {
  set: function(obj, prop, value) {
    if (prop === 'age') {
      if (!Number.isInteger(value)) {
        throw new TypeError('The age is not an integer');
      }
      if (value > 200) {
        throw new RangeError('The age seems invalid');
      }
    }
 
    // 对于满足条件的 age 属性以及其他属性，直接保存
    obj[prop] = value;
  }
};
 
let person = new Proxy({}, validator);
 
person.age = 100;
 
person.age // 100
person.age = 'young' // 报错
person.age = 300 // 报错
```

利用set方法，还可以数据绑定，即每当对象发生变化时，会自动更新 DOM。

有时，我们会在对象上面设置内部属性，属性名的第一个字符使用下划线开头，表示这些属性不应该被外部使用。结合get和set方法，就可以做到防止这些内部属性被外部读写。

```
const handler = {
  get (target, key) {
    invariant(key, 'get');
    return target[key];
  },
  set (target, key, value) {
    invariant(key, 'set');
    target[key] = value;
    return true;
  }
};
function invariant (key, action) {
  if (key[0] === '_') {
    throw new Error(`Invalid attempt to ${action} private "${key}" property`);
  }
}
const target = {};
const proxy = new Proxy(target, handler);
proxy._prop
// Error: Invalid attempt to get private "_prop" property
proxy._prop = 'c'
// Error: Invalid attempt to set private "_prop" property
```



set方法的第四个参数receiver，指的是原始的操作行为所在的那个对象，一般情况下是proxy实例本身

```
const handler = {
  set: function(obj, prop, value, receiver) {
    obj[prop] = receiver;
  }
};
const proxy = new Proxy({}, handler);
proxy.foo = 'bar';
proxy.foo === proxy // true
```

```
// 设置myObj.foo属性的值时，myObj并没有foo属性，因此引擎会到myObj的原型链去找foo属性。myObj的原型对象proxy是一个 Proxy 实例，设置它的foo属性会触发set方法。这时，第四个参数receiver就指向原始赋值行为所在的对象myObj。

// 注意，如果目标对象自身的某个属性，不可写且不可配置，那么set方法将不起作用。

const handler = {
  set: function(obj, prop, value, receiver) {
    obj[prop] = receiver;
  }
};
const proxy = new Proxy({}, handler);
const myObj = {};
Object.setPrototypeOf(myObj, proxy);
 
myObj.foo = 'bar';
myObj.foo === myObj // true
```



**Object.setPrototypeOf()** 方法设置一个指定的对象的原型 ( 即, 内部[[Prototype]]属性）到另一个对象或  [`null`]

```
Object.setPrototypeOf(obj, prototype)
```

​		obj  ：要设置其原型的对象。

​		prototype：  该对象的新原型(一个对象 或 [`null`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/null))



**`apply()`**

apply方法拦截函数的调用、call和apply操作。

apply方法可以接受三个参数，分别是目标对象、目标对象的上下文对象（this）和目标对象的参数数组。

```
var target = function () { return 'I am the target'; };
var handler = {
  apply: function () {
    return 'I am the proxy';
  }
};
 
var p = new Proxy(target, handler);
 
p()
// "I am the proxy"
```



**`has()`**

has()方法用来拦截HasProperty操作，即判断对象是否具有某个属性时，这个方法会生效。典型的操作就是in运算符。

has()方法可以接受两个参数，分别是目标对象、需查询的属性名。



**`construct()`**

construct()方法用于拦截new命令，下面是拦截对象的写法。

construct()方法可以接受三个参数。

- target：目标对象。
- args：构造函数的参数数组。
- newTarget：创造实例对象时，new命令作用的构造函数（下面例子的p）。

```
const p = new Proxy(function () {}, {
  construct: function(target, args) {
    console.log('called: ' + args.join(', '));
    return { value: args[0] * 10 };
  }
});
 
(new p(1)).value
// "called: 1"
// 10
```

construct()方法返回的必须是一个对象，否则会报错。另外，由于construct()拦截的是构造函数，所以它的目标对象必须是函数，否则就会报错。

注意，construct()方法中的this指向的是handler，而不是实例对象。

```
const handler = {
  construct: function(target, args) {
    console.log(this ===  handler);
    return new target(...args);
  }
}
 
let p = new Proxy(function () {}, handler);
new p() // true
```



**`deleteProperty()`**

deleteProperty方法用于拦截delete操作，如果这个方法抛出错误或者返回false，当前属性就无法被delete命令删除。

```
var handler = {
  deleteProperty (target, key) {
    invariant(key, 'delete');
    delete target[key];
    return true;
  }
};
function invariant (key, action) {
  if (key[0] === '_') {
    throw new Error(`Invalid attempt to ${action} private "${key}" property`);
  }
}
 
var target = { _prop: 'foo' };
var proxy = new Proxy(target, handler);
delete proxy._prop
// Error: Invalid attempt to delete private "_prop" property
```



**`defineProperty()`**

`defineProperty()`方法拦截了`Object.defineProperty()`操作。

```
var handler = {
  defineProperty (target, key, descriptor) {
    return false;
  }
};
var target = {};
var proxy = new Proxy(target, handler);
proxy.foo = 'bar' // 不会生效
```

上面代码中，`defineProperty()`方法内部没有任何操作，只返回false，导致添加新属性总是无效。注意，这里的false只是用来提示操作失败，本身并不能阻止添加新属性。

注意，如果目标对象不可扩展（non-extensible），则`defineProperty()`不能增加目标对象上不存在的属性，否则会报错。另外，如果目标对象的某个属性不可写（writable）或不可配置（configurable），则`defineProperty()`方法不得改变这两个设置。



**`getOwnPropertyDescriptor()`**

`getOwnPropertyDescriptor()`方法拦截`Object.getOwnPropertyDescriptor()`，返回一个属性描述对象或者undefined。

```
var handler = {
  getOwnPropertyDescriptor (target, key) {
    if (key[0] === '_') {
      return;
    }
    return Object.getOwnPropertyDescriptor(target, key);
  }
};
var target = { _foo: 'bar', baz: 'tar' };
var proxy = new Proxy(target, handler);
Object.getOwnPropertyDescriptor(proxy, 'wat')
// undefined
Object.getOwnPropertyDescriptor(proxy, '_foo')
// undefined
Object.getOwnPropertyDescriptor(proxy, 'baz')
// { value: 'tar', writable: true, enumerable: true, configurable: true }
```



**`getPrototypeOf()`**

`getPrototypeOf()`方法主要用来拦截获取对象原型。具体来说，拦截下面这些操作。

- `Object.prototype.__proto`__
- `Object.prototype.isPrototypeOf()`
- `Object.getPrototypeOf()`
- `Reflect.getPrototypeOf()`
- `instanceof`

**`ownKeys()`**

`ownKeys()`方法用来拦截对象自身属性的读取操作。具体来说，拦截以下操作。

- `Object.getOwnPropertyNames()`
- `Object.getOwnPropertySymbols()`
- `Object.keys()`
- `for...in循环`



**`isExtensible()`**

isExtensible()方法拦截Object.isExtensible()操作。

**`preventExtensions()`**

preventExtensions()方法拦截Object.preventExtensions()。该方法必须返回一个布尔值，否则会被自动转为布尔值。

**`setPrototypeOf()`**

setPrototypeOf()方法主要用来拦截Object.setPrototypeOf()方法。



#### **「Proxy的this指向问题」**

正常情况下，Proxy代理的钩子函数中的this指向的是Proxy代理实例（construct钩子函数除外，该钩子函数中this指向的是handler)

虽然 Proxy 可以代理针对目标对象的访问，但它不是目标对象的透明代理，即不做任何拦截的情况下，也无法保证与目标对象的行为一致。主要原因就是在 Proxy 代理的情况下，目标对象内部的this关键字会指向 Proxy 代理。

#### 「Proxy实例：Web服务客户端」

```
const service = createWebService('http://example.com/data');
 
service.employees().then(json => {
  const employees = JSON.parse(json);
  // ···
});
```

​		上面代码新建了一个 Web 服务的接口，这个接口返回各种数据。Proxy 可以拦截这个对象的任意属性，所以不用为每一种数据写一个适配方法，只要写一个 Proxy 拦截就可以了。



## 15  工程化--Webpack

- `WebPack` 是一个模块打包工具，你可以使用`WebPack`管理你的模块依赖，并编绎输出模块们所需的静态文件。它能够很好地管理、打包`Web`开发中所用到的`HTML`、`Javascript`、`CSS`以及各种静态文件（图片、字体等），让开发过程更加高效。对于不同类型的资源，`webpack`有对应的模块加载器。`webpack`模块打包器会分析模块间的依赖关系，最后 生成了优化且合并后的静态资源

#### 「1 打包体积 优化思路」

- 提取第三方库或通过引用外部文件的方式引入第三方库
- 代码压缩插件`UglifyJsPlugin`
- 服务器启用gzip压缩
- 按需加载资源文件 `require.ensure`
- 优化`devtool`中的`source-map`
- 剥离`css`文件，单独打包
- 去除不必要插件，通常就是开发环境与生产环境用同一套配置文件导致

#### 「2 打包效率」

- 开发环境采用增量构建，启用热更新
- 开发环境不做无意义的工作如提取`css`计算文件hash等
- 配置`devtool`
- 选择合适的`loader`
- 个别`loader`开启`cache` 如`babel-loader`
- 第三方库采用引入方式
- 提取公共代码
- 优化构建时的搜索路径 指明需要构建目录及不需要构建目录
- 模块化引入需要的部分

#### 「3 Loader」

编写一个loader

> `loader`就是一个`node`模块，它输出了一个函数。当某种资源需要用这个`loader`转换时，这个函数会被调用。并且，这个函数可以通过提供给它的`this`上下文访问`Loader API`。 `reverse-txt-loader`

```js
// 定义
module.exports = function(src) {
  //src是原文件内容（abcde），下面对内容进行处理，这里是反转
  var result = src.split('').reverse().join('');
  //返回JavaScript源码，必须是String或者Buffer
  return `module.exports = '${result}'`;
}
//使用
{
	test: /\.txt$/,
	use: [
		{
			'./path/reverse-txt-loader'
		}
	]
},
```

#### 「4  webpack的plugin，webpack对项目进行优化」

**构建优化**

- 减少编译体积 `ContextReplacementPugin`、`IgnorePlugin`、`babel-plugin-import`、`babel-plugin-transform-runtime`
- 并行编译 `happypack`、`thread-loader`、`uglifyjsWebpackPlugin`开启并行
- 缓存 `cache-loader`、`hard-source-webpack-plugin`、`uglifyjsWebpackPlugin`开启缓存、`babel-loader`开启缓存
- 预编译 `dllWebpackPlugin && DllReferencePlugin`、`auto-dll-webapck-plugin`

**性能优化**

- 减少编译体积 `Tree-shaking`、`Scope Hositing`
- `hash`缓存 `webpack-md5-plugin`
- 拆包 `splitChunksPlugin`、`import()`、`require.ensure`

**webpack性能优化：**开发环境性能优化，生产环境性能优化

**开发环境性能优化：**优化打包构建速度（HMR），优化代码调试（source-map）

**生产环境性能优化：**优化打包构建速度（oneOf、缓存--babel缓存），多进程打包（并行打包，一般用于babel）

**优化代码运行的性能：**缓存 hash-chunk、hash--content、tree shaking--es6模块 production默认启动 sideEffect

**code split** ：单入口  ---> optimization、import xxx 语法、dll 

**多入口**  --->lazy loading 懒加载/预加载：

​			懒加载触发再加载，预加载空闲时加载（兼容性问题严重）

**pwa**：离线也能访问

​		三个hash的区别：

​		`hash`指的是webpack每次打包时都会生成唯一的hash值，文件不管会不会变，hash一定会变，---这会导致文件没改变，打包却重新打包了

​	`chunkhash`：来自入同一个入口则属于同一个chunk，同属于一个chunk则共享一个hash值，--js和css同属于一个chunk，这样的话，js变了，css也得重新打包

​		`contenthash`：根据文件内容生成hash，如果内容不变，`contenthash`就不会变



![image-20211004200735659](https://gitee.com/wexia/my_pic_bed/raw/master/pics/20211006110409.png)



#### 「1  webpack 的构建流程」

**核心概念**

- `entry`：入口。webpack是基于模块的，使用webpack首先需要指定模块解析入口(entry)，webpack从入口开始根据模块间依赖关系递归解析和处理所有资源文件。
- `output`：输出。源代码经过webpack处理之后的最终产物。
- `loader`：模块转换器。本质就是一个函数，在该函数中对接收到的内容进行转换，返回转换后的结果。因为 Webpack 只认识 JavaScript，所以 Loader 就成了翻译官，对其他类型的资源进行转译的预处理工作。
- `plugin`：扩展插件。基于事件流框架 `Tapable`，插件可以扩展 Webpack 的功能，在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。
- `module`：模块。除了js范畴内的`es module、commonJs、AMD`等，`css @import、url(...)`、图片、字体等在webpack中都被视为模块。

**解释几个 webpack 中的术语**

- `module`：指在模块化编程中我们把应用程序分割成的独立功能的代码模块
- `chunk`：指模块间按照引用关系组合成的代码块，一个 `chunk` 中可以包含多个 `module`
- `chunk group`：指通过配置入口点（`entry point`）区分的块组，一个 `chunk group` 中可包含一到多个 chunk
- `bundling`：webpack 打包的过程
- `asset/bundle`：打包产物

**webpack 的打包思想可以简化为 3 点：**

- 一切源代码文件均可通过各种 `Loader` 转换为 JS 模块 （`module`），模块之间可以互相引用。
- webpack 通过入口点（`entry point`）递归处理各模块引用关系，最后输出为一个或多个产物包 `js(bundle)` 文件。
- 每一个入口点都是一个块组（`chunk group`），在不考虑分包的情况下，一个 `chunk group` 中只有一个 `chunk`，该 chunk 包含递归分析后的所有模块。每一个 `chunk` 都有对应的一个打包后的输出文件（`asset/bundle`）

![img](http://img-repo.poetries.top/images/20210422211832.png)

**打包流程**

1. 初始化参数：从配置文件和 Shell 语句中读取并合并参数，得出最终的配置参数。
2. 开始编译：从上一步得到的参数初始化 `Compiler` 对象，加载所有配置的插件，执行对象的 `run` 方法开始执行编译。
3. 确定入口：根据配置中的 `entry` 找出所有的入口文件。
4. 编译模块：从入口文件出发，调用所有配置的 `loader` 对模块进行翻译，再找出该模块依赖的模块，这个步骤是递归执行的，直至所有入口依赖的模块文件都经过本步骤的处理。
5. 完成模块编译：经过第 4 步使用 loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系。
6. 输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 `chunk`，再把每个 `chunk` 转换成一个单独的文件加入到输出列表，这一步是可以修改输出内容的最后机会。
7. 输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。

![img](http://img-repo.poetries.top/images/20210517175408.png)

**简版**

- Webpack CLI 启动打包流程；
- 载入 Webpack 核心模块，创建 `Compiler` 对象；
- 使用 `Compiler` 对象开始编译整个项目；
- 从入口文件开始，解析模块依赖，形成依赖关系树；
- 递归依赖树，将每个模块交给对应的 Loader 处理；
- 合并 Loader 处理完的结果，将打包结果输出到 dist 目录。

> 在以上过程中，`Webpack 会在特定的时间点广播出特定的事件`，插件在监听到相关事件后会执行特定的逻辑，并且插件可以调用 Webpack 提供的 API 改变 Webpack 的运行结果

**构建流程核心概念：**

- `Tapable`：一个基于发布订阅的事件流工具类，`Compiler` 和 `Compilation` 对象都继承于 `Tapable`
- `Compiler`：compiler对象是一个全局单例，他负责把控整个webpack打包的构建流程。在编译初始化阶段被创建的全局单例，包含完整配置信息、`loaders`、plugins以及各种工具方法
- `Compilation`：代表一次 webpack 构建和生成编译资源的的过程，在`watch`模式下每一次文件变更触发的重新编译都会生成新的 `Compilation` 对象，包含了当前编译的模块 `module`, 编译生成的资源，变化的文件, 依赖的状态等
- 而每个模块间的依赖关系，则依赖于`AST`语法树。每个模块文件在通过Loader解析完成之后，会通过`acorn`库生成模块代码的AST语法树，通过语法树就可以分析这个模块是否还有依赖的模块，进而继续循环执行下一个模块的编译解析。

最终`Webpack`打包出来的`bundle`文件是一个`IIFE`的执行函数。

```js
// webpack 5 打包的bundle文件内容

(() => { // webpackBootstrap
    var __webpack_modules__ = ({
        'file-A-path': ((modules) => { // ... })
        'index-file-path': ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => { // ... })
    })
    
    // The module cache
    var __webpack_module_cache__ = {};
    
    // The require function
    function __webpack_require__(moduleId) {
        // Check if module is in cache
        var cachedModule = __webpack_module_cache__[moduleId];
        if (cachedModule !== undefined) {
                return cachedModule.exports;
        }
        // Create a new module (and put it into the cache)
        var module = __webpack_module_cache__[moduleId] = {
                // no module.id needed
                // no module.loaded needed
                exports: {}
        };

        // Execute the module function
        __webpack_modules__[moduleId](module, module.exports, __webpack_require__);

        // Return the exports of the module
        return module.exports;
    }
    
    // startup
    // Load entry module and return exports
    // This entry module can't be inlined because the eval devtool is used.
    var __webpack_exports__ = __webpack_require__("./src/index.js");
})
```

![img](http://img-repo.poetries.top/images/20210503212144.png)

**webpack详细工作流程**

![img](http://img-repo.poetries.top/images/20210517174932.png)

#### 「2 介绍 Loader」

**常用 Loader:**

- `file-loader`: 加载文件资源，如 字体 / 图片 等，具有移动/复制/命名等功能；
- `url-loader`: 通常用于加载图片，可以将小图片直接转换为 Date Url，减少请求；
- `babel-loader`: 加载 js / jsx 文件， 将 ES6 / ES7 代码转换成 ES5，抹平兼容性问题；
- `ts-loader`: 加载 ts / tsx 文件，编译 TypeScript；
- `style-loader`: 将 css 代码以`<style>`标签的形式插入到 html 中；
- `css-loader`: 分析@import和url()，引用 css 文件与对应的资源；
- `postcss-loader`: 用于 css 的兼容性处理，具有众多功能，例如 添加前缀，单位转换 等；
- `less-loader / sass-loader`: css预处理器，在 css 中新增了许多语法，提高了开发效率；

**编写原则:**

- 单一原则: 每个 Loader 只做一件事；
- 链式调用: Webpack 会按顺序链式调用每个 Loader；
- 统一原则: 遵循 Webpack制定的设计规则和结构，输入与输出均为字符串，各个 Loader 完全独立，即插即用；

#### 「3 介绍 plugin」

> 插件系统是 Webpack 成功的一个关键性因素。在编译的整个生命周期中，Webpack 会触发许多事件钩子，Plugin 可以监听这些事件，根据需求在相应的时间点对打包内容进行定向的修改。

**一个最简单的 plugin 是这样的:**

```js
class Plugin{
  	// 注册插件时，会调用 apply 方法
  	// apply 方法接收 compiler 对象
  	// 通过 compiler 上提供的 Api，可以对事件进行监听，执行相应的操作
  	apply(compiler){
  		// compilation 是监听每次编译循环
  		// 每次文件变化，都会生成新的 compilation 对象并触发该事件
    	compiler.plugin('compilation',function(compilation) {})
  	}
}
```

**注册插件:**

```js
// webpack.config.js
module.export = {
	plugins:[
		new Plugin(options),
	]
}
```

**事件流机制:**

> Webpack 就像工厂中的一条产品流水线。原材料经过 Loader 与 Plugin 的一道道处理，最后输出结果。

- 通过链式调用，按顺序串起一个个 Loader；
- 通过事件流机制，让 Plugin 可以插入到整个生产过程中的每个步骤中；

> Webpack 事件流编程范式的核心是基础类 Tapable，是一种 观察者模式 的实现事件的订阅与广播：

```js
const { SyncHook } = require("tapable")

const hook = new SyncHook(['arg'])

// 订阅
hook.tap('event', (arg) => {
	// 'event-hook'
	console.log(arg)
})

// 广播
hook.call('event-hook')
```

> `Webpack` 中两个最重要的类 `Compiler` 与 `Compilation` 便是继承于 `Tapable`，也拥有这样的事件流机制。

- **Compiler**: 可以简单的理解为 Webpack 实例，它包含了当前 Webpack 中的所有配置信息，如 options， loaders, plugins 等信息，全局唯一，只在启动时完成初始化创建，随着生命周期逐一传递；
- `Compilation`: 可以称为 编译实例。当监听到文件发生改变时，Webpack 会创建一个新的 Compilation 对象，开始一次新的编译。它包含了当前的输入资源，输出资源，变化的文件等，同时通过它提供的 api，可以监听每次编译过程中触发的事件钩子；
- **区别:**
  - `Compiler` 全局唯一，且从启动生存到结束；
  - `Compilation`对应每次编译，每轮编译循环均会重新创建；
- **常用 Plugin:**
  - UglifyJsPlugin: 压缩、混淆代码；
  - CommonsChunkPlugin: 代码分割；
  - ProvidePlugin: 自动加载模块；
  - html-webpack-plugin: 加载 html 文件，并引入 css / js 文件；
  - extract-text-webpack-plugin / mini-css-extract-plugin: 抽离样式，生成 css 文件； DefinePlugin: 定义全局变量；
  - optimize-css-assets-webpack-plugin: CSS 代码去重；
  - webpack-bundle-analyzer: 代码分析；
  - compression-webpack-plugin: 使用 gzip 压缩 js 和 css；
  - happypack: 使用多进程，加速代码构建；
  - EnvironmentPlugin: 定义环境变量；
- 调用插件 `apply` 函数传入 `compiler` 对象
- 通过 `compiler` 对象监听事件

**loader和plugin有什么区别？**

> webapck默认只能打包JS和JOSN模块，要打包其它模块，需要借助loader，loader就可以让模块中的内容转化成webpack或其它loader可以识别的内容。

- `loader`就是模块转换化，或叫加载器。不同的文件，需要不同的`loader`来处理。
- `plugin`是插件，可以参与到整个webpack打包的流程中，不同的插件，在合适的时机，可以做不同的事件。

**webpack中都有哪些插件，这些插件有什么作用？**

- `html-webpack-plugin` 自动创建一个HTML文件，并把打包好的JS插入到HTML文件中
- `clean-webpack-plugin` 在每一次打包之前，删除整个输出文件夹下所有的内容
- `mini-css-extrcat-plugin` 抽离CSS代码，放到一个单独的文件中
- `optimize-css-assets-plugin` 压缩css

#### 「4 webpack 热更新实现原理」

![img](http://img-repo.poetries.top/images/20210319101659.png)

**HMR 的基本流程图**

![img](http://img-repo.poetries.top/images/20210422211446.png)

- 当修改了一个或多个文件；
- 文件系统接收更改并通知 `webpack`；
- `webpack` 重新编译构建一个或多个模块，并通知 HMR 服务器进行更新；
- `HMR Server` 使用 `webSocket` 通知 `HMR runtime` 需要更新，`HMR` 运行时通过 `HTTP` 请求更新 `jsonp`
- `HMR` 运行时替换更新中的模块，如果确定这些模块无法更新，则触发整个页面刷新



大概流程是我们用`webpack-dev-server`启动一个服务之后，浏览器和服务端是通过`websocket`进行长连接，`webpack`内部实现的watch就会监听文件修改，只要有修改就`webpack`会重新打包编译到内存中，然后`webpack-dev-server`依赖中间件`webpack-dev-middleware`和`webpack`之间进行交互，每次热更新都会请求一个携带hash值的json文件和一个js，websocker传递的也是hash值，内部机制通过hash值检查进行热更新， 至于内部原理，因为水平限制，目前还看不懂。



#### 「5 webpack 层面做性能优化」

**优化前的准备工作**

- 准备基于时间的分析工具：我们需要一类插件，来帮助我们统计项目构建过程中在编译阶段的耗时情况。`speed-measure-webpack-plugin` 分析插件加载的时间
- 使用 `webpack-bundle-analyzer` 分析产物内容

**代码优化:**

> 无用代码消除，是许多编程语言都具有的优化手段，这个过程称为 DCE (dead code elimination)，即 删除不可能执行的代码；

例如我们的 `UglifyJs`，它就会帮我们在生产环境中删除不可能被执行的代码，例如:

```js
var fn = function() {
	return 1;
	// 下面代码便属于 不可能执行的代码；
	// 通过 UglifyJs (Webpack4+ 已内置) 便会进行 DCE；
	var a = 1;
	return a;
}
```

> 摇树优化 (Tree-shaking)，这是一种形象比喻。我们把打包后的代码比喻成一棵树，这里其实表示的就是，通过工具 "摇" 我们打包后的 js 代码，将没有使用到的无用代码 "摇" 下来 (删除)。即 消除那些被 引用了但未被使用 的模块代码。

- 原理: 由于是在编译时优化，因此最基本的前提就是语法的静态分析，ES6的模块机制 提供了这种可能性。不需要运行时，便可进行代码字面上的静态分析，确定相应的依赖关系。
- 问题: 具有 副作用 的函数无法被**tree-shaking**：
  - 在引用一些第三方库，需要去观察其引入的代码量是不是符合预期；
  - 尽量写纯函数，减少函数的副作用；
  - 可使用 `webpack-deep-scope-plugin`，可以进行作用域分析，减少此类情况的发生，但仍需要注意；

**code-spliting: 代码分割技术**，将代码分割成多份进行 懒加载 或 异步加载，避免打包成一份后导致体积过大，影响页面的首屏加载；

- `Webpack` 中使用 `SplitChunksPlugin` 进行拆分；
- 按 页面 拆分: 不同页面打包成不同的文件；
- 按 功能 拆分:
  - 将类似于播放器，计算库等大模块进行拆分后再懒加载引入；
  - 提取复用的业务代码，减少冗余代码；
- 按 文件修改频率 拆分: 将第三方库等不常修改的代码单独打包，而且不改变其文件 hash 值，能最大化运用浏览器的缓存；

**scope hoisting**: 作用域提升，将分散的模块划分到同一个作用域中，避免了代码的重复引入，有效减少打包后的代码体积和运行时的内存损耗；

**编译性能优化:**

- 升级至 最新 版本的 `webpack`，能有效提升编译性能；
- 使用dev-server/ **模块热替换 (HMR)** 提升开发体验；
  - 监听文件变动 忽略 node_modules 目录能有效提高监听时的编译效率；
- 缩小编译范围
  - `modules`: 指定模块路径，减少递归搜索；
  - `mainFields`: 指定入口文件描述字段，减少搜索；
  - `noParse`: 避免对非模块化文件的加载；
  - `includes/exclude`: 指定搜索范围/排除不必要的搜索范围；
  - `alias`: 缓存目录，避免重复寻址；
- **babel-loader**
  - 忽略`node_moudles`，避免编译第三方库中已经被编译过的代码
  - 使用`cacheDirectory`，可以缓存编译结果，避免多次重复编译
- 多进程并发
  - `webpack-parallel-uglify-plugin`: 可多进程并发压缩 js 文件，提高压缩速度；
  - `HappyPack`: 多进程并发文件的 `Loader` 解析；
- 第三方库模块缓存:
  - `DLLPlugin` 和 `DLLReferencePlugin` 可以提前进行打包并缓存，避免每次都重新编译；
- 使用分析
  - `Webpack Analyse / webpack-bundle-analyzer` 对打包后的文件进行分析，寻找可优化的地方
  - 配置profile：true，对各个编译阶段耗时进行监控，寻找耗时最多的地方
- **source-map:**
  - 开发: `cheap-module-eval-source-map`
  - 生产: `hidden-source-map`；

**优化webpack打包速度**

- 减少文件搜索范围
  - 比如通过别名
  - `loader` 的 `test`，`include & exclude`
- `Webpack4` 默认压缩并行
- `Happypack` 并发调用
- `babel` 也可以缓存编译
- `Resolve` 在构建时指定查找模块文件的规则
- 使用`DllPlugin`，不用每次都重新构建
- `externals`和`DllPlugin`解决的是同一类问题：将依赖的框架等模块从构建过程中移除。它们的区别在于：
  - 在 Webpack 的配置方面，`externals` 更简单，而 `DllPlugin` 需要独立的配置文件。
  - `DllPlugin` 包含了依赖包的独立构建流程，而 `externals` 配置中不包含依赖框架的生成方式，通常使用已传入 CDN 的依赖包
  - `externals` 配置的依赖包需要单独指定依赖模块的加载方式：全局对象、CommonJS、AMD 等
  - 在引用依赖包的子模块时，`DllPlugin` 无须更改，而 `externals` 则会将子模块打入项目包中

**优化打包体积**

- 提取第三方库或通过引用外部文件的方式引入第三方库
- 代码压缩插件`UglifyJsPlugin`
- 服务器启用`gzip`压缩
- 按需加载资源文件 `require.ensure`
- 优化`devtool`中的`source-map`
- 剥离`css`文件，单独打包
- 去除不必要插件，通常就是开发环境与生产环境用同一套配置文件导致
- `Tree Shaking` 在构建打包过程中，移除那些引入但未被使用的无效代码
- 开启`scope hosting`
  - 体积更小
  - 创建函数作用域更小
  - 代码可读性更好

![img](http://img-repo.poetries.top/images/20210409165629.png) ![img](http://img-repo.poetries.top/images/20210409165723.png)

#### 「6 介绍一下 Tree Shaking」

**对tree-shaking的了解**

**作用：**

它表示在打包的时候会去除一些无用的代码

**原理**：

- `ES6`的模块引入是静态分析的，所以在编译时能正确判断到底加载了哪些模块
- 分析程序流，判断哪些变量未被使用、引用，进而删除此代码

**特点：**

- 在生产模式下它是默认开启的，但是由于经过`babel`编译全部模块被封装成`IIFE`，它存在副作用无法被`tree-shaking`掉
- 可以在`package.json`中配置`sideEffects`来指定哪些文件是有副作用的。它有两种值，一个是布尔类型，如果是`false`则表示所有文件都没有副作用；如果是一个数组的话，数组里的文件路径表示改文件有副作用
- `rollup`和`webpack`中对`tree-shaking`的层度不同，例如对`babel`转译后的`class`，如果`babel`的转译是宽松模式下的话(也就是`loose`为`true`)，`webpack`依旧会认为它有副作用不会`tree-shaking`掉，而`rollup`会。这是因为`rollup`有程序流分析的功能，可以更好的判断代码是否真正会产生副作用。

**原理**

- `ES6 Module` 引入进行静态分析，故而编译的时候正确判断到底加载了那些模块
- 静态分析程序流，判断那些模块和变量未被使用或者引用，进而删除对应代码

> 依赖于`import/export`

通过导入所有的包后再进行条件获取。如下：

```js
import foo from "foo";
import bar from "bar";

if(condition) {
    // foo.xxxx
} else {
    // bar.xxx
}
```

> ES6的import语法完美可以使用tree shaking，因为可以在代码不运行的情况下就能分析出不需要的代码

**CommonJS的动态特性模块意味着tree shaking不适用**。因为它是不可能确定哪些模块实际运行之前是需要的或者是不需要的。在ES6中，进入了完全静态的导入语法：import。这也意味着下面的导入是不可行的：

```js
// 不可行，ES6 的import是完全静态的
if(condition) {
    myDynamicModule = require("foo");
} else {
    myDynamicModule = require("bar");
}
```

#### 「7 介绍一下 webpack scope hosting」

> 作用域提升，将分散的模块划分到同一个作用域中，避免了代码的重复引入，有效减少打包后的代码体积和运行时的内存损耗；

#### 「8 Webpack Proxy工作原理？为什么能解决跨域」

**1. 是什么**

`webpack proxy`，即`webpack`提供的代理服务

基本行为就是接收客户端发送的请求后转发给其他服务器

其目的是为了便于开发者在开发模式下解决跨域问题（浏览器安全策略限制）

想要实现代理首先需要一个中间服务器，`webpack`中提供服务器的工具为`webpack-dev-server`

**2. webpack-dev-server**

`webpack-dev-server`是 `webpack` 官方推出的一款开发工具，将自动编译和自动刷新浏览器等一系列对开发友好的功能全部集成在了一起

目的是为了提高开发者日常的开发效率，「只适用在开发阶段」

关于配置方面，在`webpack`配置对象属性中通过`devServer`属性提供，如下：

```js
// ./webpack.config.js
const path = require('path')

module.exports = {
    // ...
    devServer: {
        contentBase: path.join(__dirname, 'dist'),
        compress: true,
        port: 9000,
        proxy: {
            '/api': {
                target: 'https://api.github.com'
            }
        }
        // ...
    }
}
```

`devServetr`里面`proxy`则是关于代理的配置，该属性为对象的形式，对象中每一个属性就是一个代理的规则匹配

属性的名称是需要被代理的请求路径前缀，一般为了辨别都会设置前缀为`/api`，值为对应的代理匹配规则，对应如下：

- `target`：表示的是代理到的目标地址
- `pathRewrite`：默认情况下，我们的 `/api-hy` 也会被写入到URL中，如果希望删除，可以使用`pathRewrite`
- `secure`：默认情况下不接收转发到`https`的服务器上，如果希望支持，可以设置为`false`
- `changeOrigin`：它表示是否更新代理后请求的 `headers` 中`host`地址

**2. 工作原理**

> `proxy`工作原理实质上是利用`http-proxy-middleware` 这个`http`代理中间件，实现请求转发给其他服务器

举个例子：

在开发阶段，本地地址为`http://localhost:3000`，该浏览器发送一个前缀带有`/api`标识的请求到服务端获取数据，但响应这个请求的服务器只是将请求转发到另一台服务器中

```js
const express = require('express');
const proxy = require('http-proxy-middleware');

const app = express();

app.use('/api', proxy({target: 'http://www.example.org', changeOrigin: true}));
app.listen(3000);

// http://localhost:3000/api/foo/bar -> http://www.example.org/api/foo/bar
```

**3. 跨域**

> 在开发阶段， `webpack-dev-server` 会启动一个本地开发服务器，所以我们的应用在开发阶段是独立运行在 `localhost`的一个端口上，而后端服务又是运行在另外一个地址上

所以在开发阶段中，由于浏览器同源策略的原因，当本地访问后端就会出现跨域请求的问题

通过设置`webpack proxy`实现代理请求后，相当于浏览器与服务端中添加一个代理者

当本地发送请求的时候，代理服务器响应该请求，并将请求转发到目标服务器，目标服务器响应数据后再将数据返回给代理服务器，最终再由代理服务器将数据响应给本地

![img](http://img-repo.poetries.top/images/20210507090546.png)

在代理服务器传递数据给本地浏览器的过程中，两者同源，并不存在跨域行为，这时候浏览器就能正常接收数据

> 注意：`「服务器与服务器之间请求数据并不会存在跨域行为，跨域行为是浏览器安全策略限制」`

#### 「9 介绍一下 babel原理」

> `babel` 的编译过程分为三个阶段：**parsing**、**transforming**、**generating**，以 ES6 编译为 ES5 作为例子：

1. `ES6` 代码输入；
2. `babylon` 进行解析得到 AST；
3. `plugin` 用 `babel-traverse` 对 `AST`树进行遍历编译，得到新的 `AST`树；
4. 用 `babel-generator` 通过 `AST`树生成 `ES5` 代码。

[Babel原理及其使用(opens new window)](http://interview.poetries.top/principle-docs/webpack/05-Babel原理及其使用.html)

#### 「10 介绍一下Rollup」

> Rollup 是一款 ES Modules 打包器。它也可以将项目中散落的细小模块打包为整块代码，从而使得这些划分的模块可以更好地运行在浏览器环境或者 Node.js 环境。

**Rollup优势：**

- 输出结果更加扁平，执行效率更高；
- 自动移除未引用代码；
- 打包结果依然完全可读。

**缺点**

- 加载非 ESM 的第三方模块比较复杂；
- 因为模块最终都被打包到全局中，所以无法实现 `HMR`；
- 浏览器环境中，代码拆分功能必须使用 `Require.js` 这样的 `AMD` 库

> - 我们发现如果我们开发的是一个应用程序，需要大量引用第三方模块，同时还需要 HMR 提升开发体验，而且应用过大就必须要分包。那这些需求 Rollup 都无法满足。
> - 如果我们是开发一个 JavaScript 框架或者库，那这些优点就特别有必要，而缺点呢几乎也都可以忽略，所以在很多像 React 或者 Vue 之类的框架中都是使用的 Rollup 作为模块打包器，而并非 Webpack

**总结一下**：`Webpack 大而全，Rollup 小而美`。

在对它们的选择上，我的基本原则是：`应用开发使用 Webpack，类库或者框架开发使用 Rollup`。

不过这并不是绝对的标准，只是经验法则。因为 Rollup 也可用于构建绝大多数应用程序，而 Webpack 同样也可以构建类库或者框架。



#### 「11 loader和plugin区别」

> loader 用于加载某些资源文件。

​		因为 webpack 只能理解 JavaScript 和 JSON 文件，对于其他资源例如 css，图片，或者其他的语法集，比如 jsx， coffee，是没有办法加载的。 这就需要对应的loader将资源转化，加载进来。从字面意思也能看出，loader是用于加载的，它作用于一个个文件上。

> plugin 用于扩展webpack的功能。

​		目的在于解决loader无法实现的其他事,它直接作用于 webpack，扩展了它的功能。当然loader也是变相的扩展了 webpack ，但是它只专注于转化文件（transform）这一个领域。而plugin的功能更加的丰富，而不仅局限于资源的加载。














## 16 深浅拷贝

#### **「1. 浅拷贝原理和实现」**

> 自己创建一个新的对象，来接受你要重新复制或引用的对象值。如果对象属性是基本的数据类型，复制的就是基本类型的值给新对象；但如果属性是引用数据类型，复制的就是内存中的地址，如果其中一个对象改变了这个内存中的地址，肯定会影响到另一个对象

**方法一：object.assign**

> `object.assign`是 ES6 中 `object` 的一个方法，该方法可以用于 JS 对象的合并等多个用途，`其中一个用途就是可以进行浅拷贝`。该方法的第一个参数是拷贝的目标对象，后面的参数是拷贝的来源对象（也可以是多个来源）。

```text
object.assign 的语法为：Object.assign(target, ...sources)
```

object.assign 的示例代码如下：

```js
let target = {};
let source = { a: { b: 1 } };
Object.assign(target, source);
console.log(target); // { a: { b: 1 } };
```

**但是使用 object.assign 方法有几点需要注意**

- 它不会拷贝对象的继承属性；
- 它不会拷贝对象的不可枚举的属性；
- 可以拷贝 `Symbol` 类型的属性。

```js
let obj1 = { a:{ b:1 }, sym:Symbol(1)}; 
Object.defineProperty(obj1, 'innumerable' ,{
    value:'不可枚举属性',
    enumerable:false
});
let obj2 = {};
Object.assign(obj2,obj1)
obj1.a.b = 2;
console.log('obj1',obj1);
console.log('obj2',obj2);
```

![img](http://img-repo.poetries.top/images/20210414134752.png)

> 从上面的样例代码中可以看到，利用 `object.assign` 也可以拷贝 `Symbol` 类型的对象，但是如果到了对象的第二层属性 obj1.a.b 这里的时候，前者值的改变也会影响后者的第二层属性的值，说明其中`依旧存在着访问共同堆内存的问题`，也就是说`这种方法还不能进一步复制，而只是完成了浅拷贝的功能`

**方法二：扩展运算符方式**

- 我们也可以利用 JS 的扩展运算符，在构造对象的同时完成浅拷贝的功能。
- 扩展运算符的语法为：`let cloneObj = { ...obj };`

```js
/* 对象的拷贝 */
let obj = {a:1,b:{c:1}}
let obj2 = {...obj}
obj.a = 2
console.log(obj)  //{a:2,b:{c:1}} console.log(obj2); //{a:1,b:{c:1}}
obj.b.c = 2
console.log(obj)  //{a:2,b:{c:2}} console.log(obj2); //{a:1,b:{c:2}}
/* 数组的拷贝 */
let arr = [1, 2, 3];
let newArr = [...arr]; //跟arr.slice()是一样的效果
```

> 扩展运算符 和 `object.assign` 有同样的缺陷，也就是`实现的浅拷贝的功能差不多`，但是如果属性都是`基本类型的值，使用扩展运算符进行浅拷贝会更加方便`

**方法三：concat 拷贝数组**

> 数组的 `concat` 方法其实也是浅拷贝，所以连接一个含有引用类型的数组时，需要注意修改原数组中的元素的属性，因为它会影响拷贝之后连接的数组。不过 `concat` 只能用于数组的浅拷贝，使用场景比较局限。代码如下所示。

```js
let arr = [1, 2, 3];
let newArr = arr.concat();
newArr[1] = 100;
console.log(arr);  // [ 1, 2, 3 ]
console.log(newArr); // [ 1, 100, 3 ]
```

**方法四：slice 拷贝数组**

> `slice` 方法也比较有局限性，因为`它仅仅针对数组类型`。`slice方法会返回一个新的数组对象`，这一对象由该方法的前两个参数来决定原数组截取的开始和结束时间，是不会影响和改变原始数组的。

```text
slice 的语法为：arr.slice(begin, end);
let arr = [1, 2, {val: 4}];
let newArr = arr.slice();
newArr[2].val = 1000;
console.log(arr);  //[ 1, 2, { val: 1000 } ]
```

> 从上面的代码中可以看出，这就是`浅拷贝的限制所在了——它只能拷贝一层对象`。如果`存在对象的嵌套，那么浅拷贝将无能为力`。因此深拷贝就是为了解决这个问题而生的，它能解决多层对象嵌套问题，彻底实现拷贝

**手工实现一个浅拷贝**

根据以上对浅拷贝的理解，如果让你自己实现一个浅拷贝，大致的思路分为两点：

- 对基础类型做一个最基本的一个拷贝；
- 对引用类型开辟一个新的存储，并且拷贝一层对象属性。

```js
const shallowClone = (target) => {
  if (typeof target === 'object' && target !== null) {
    const cloneTarget = Array.isArray(target) ? []: {};
    for (let prop in target) {
      if (target.hasOwnProperty(prop)) {
          cloneTarget[prop] = target[prop];
      }
    }
    return cloneTarget;
  } else {
    return target;
  }
}
```

> 利用类型判断，针对引用类型的对象进行 for 循环遍历对象属性赋值给目标对象的属性，基本就可以手工实现一个浅拷贝的代码了

#### **「2. 深拷贝原理和实现」**

`浅拷贝只是创建了一个新的对象，复制了原有对象的基本类型的值，而引用数据类型只拷贝了一层属性，再深层的还是无法进行拷贝`。深拷贝则不同，对于复杂引用数据类型，其在堆内存中完全开辟了一块内存地址，并将原有的对象完全复制过来存放。

这两个对象是相互独立、不受影响的，彻底实现了内存上的分离。总的来说，`深拷贝的原理可以总结如下`：

> 将一个对象从内存中完整地拷贝出来一份给目标对象，并从堆内存中开辟一个全新的空间存放新对象，且新对象的修改并不会改变原对象，二者实现真正的分离。

**方法一：乞丐版（JSON.stringify）**

> `JSON.stringify()` 是目前开发过程中最简单的深拷贝方法，其实就是把一个对象序列化成为 `JSON` 的字符串，并将对象里面的内容转换成字符串，最后再用 `JSON.parse()` 的方法将 `JSON` 字符串生成一个新的对象

```js
let a = {
    age: 1,
    jobs: {
        first: 'FE'
    }
}
let b = JSON.parse(JSON.stringify(a))
a.jobs.first = 'native'
console.log(b.jobs.first) // FE
```

**但是该方法也是有局限性的**：

- 会忽略 `undefined`
- 会忽略 `symbol`
- 不能序列化函数
- 无法拷贝不可枚举的属性
- 无法拷贝对象的原型链
- 拷贝 `RegExp` 引用类型会变成空对象
- 拷贝 `Date` 引用类型会变成字符串
- 对象中含有 `NaN`、`Infinity` 以及 `-Infinity`，`JSON` 序列化的结果会变成 `null`
- 不能解决循环引用的对象，即对象成环 (`obj[key] = obj`)。

```js
function Obj() { 
  this.func = function () { alert(1) }; 
  this.obj = {a:1};
  this.arr = [1,2,3];
  this.und = undefined; 
  this.reg = /123/; 
  this.date = new Date(0); 
  this.NaN = NaN;
  this.infinity = Infinity;
  this.sym = Symbol(1);
} 
let obj1 = new Obj();
Object.defineProperty(obj1,'innumerable',{ 
  enumerable:false,
  value:'innumerable'
});
console.log('obj1',obj1);
let str = JSON.stringify(obj1);
let obj2 = JSON.parse(str);
console.log('obj2',obj2);
```

![img](http://img-repo.poetries.top/images/20210414141731.png)

> 使用 `JSON.stringify` 方法实现深拷贝对象，虽然到目前为止还有很多无法实现的功能，但是这种方法足以满足日常的开发需求，并且是最简单和快捷的。而对于其他的也要实现深拷贝的，比较麻烦的属性对应的数据类型，`JSON.stringify` 暂时还是无法满足的，那么就需要下面的几种方法了

**方法二：基础版（手写递归实现）**

> 下面是一个实现 deepClone 函数封装的例子，通过 `for in` 遍历传入参数的属性值，如果值是引用类型则再次递归调用该函数，如果是基础数据类型就直接复制

```js
let obj1 = {
  a:{
    b:1
  }
}
function deepClone(obj) { 
  let cloneObj = {}
  for(let key in obj) {                 //遍历
    if(typeof obj[key] ==='object') { 
      cloneObj[key] = deepClone(obj[key])  //是对象就再次调用该函数递归
    } else {
      cloneObj[key] = obj[key]  //基本类型的话直接复制值
    }
  }
  return cloneObj
}
let obj2 = deepClone(obj1);
obj1.a.b = 2;
console.log(obj2);   //  {a:{b:1}}
```

虽然利用递归能实现一个深拷贝，但是同上面的 `JSON.stringify` 一样，还是有一些问题没有完全解决，例如：

- 这个深拷贝函数并不能复制不可枚举的属性以及 `Symbol` 类型；
- 这种方法`只是针对普通的引用类型的值做递归复制`，而对于 `Array、Date、RegExp、Error、Function` 这样的引用类型并不能正确地拷贝；
- 对象的属性里面成环，即`循环引用没有解决`。

这种基础版本的写法也比较简单，可以应对大部分的应用情况。但是你在面试的过程中，如果只能写出这样的一个有缺陷的深拷贝方法，有可能不会通过。

所以为了“拯救”这些缺陷，下面我带你一起看看改进的版本，以便于你可以在面试种呈现出更好的深拷贝方法，赢得面试官的青睐。

**方法三：改进版（改进后递归实现）**

> 针对上面几个待解决问题，我先通过四点相关的理论告诉你分别应该怎么做。

- 针对能够遍历对象的不可枚举属性以及 `Symbol` 类型，我们可以使用 `Reflect.ownKeys` 方法；
- 当参数为 `Date、RegExp` 类型，则直接生成一个新的实例返回；
- 利用 `Object` 的 `getOwnPropertyDescriptors` 方法可以获得对象的所有属性，以及对应的特性，顺便结合 `Object.create` 方法创建一个新对象，并继承传入原对象的原型链；
- 利用 `WeakMap` 类型作为 `Hash` 表，因为 `WeakMap` 是弱引用类型，可以有效防止内存泄漏（你可以关注一下 `Map` 和 `weakMap` 的关键区别，这里要用 `weakMap`），作为检测循环引用很有帮助，如果存在循环，则引用直接返回 `WeakMap` 存储的值

如果你在考虑到循环引用的问题之后，还能用 `WeakMap` 来很好地解决，并且向面试官解释这样做的目的，那么你所展示的代码，以及你对问题思考的全面性，在面试官眼中应该算是合格的了

**实现深拷贝**

```js
const isComplexDataType = obj => (typeof obj === 'object' || typeof obj === 'function') && (obj !== null)

const deepClone = function (obj, hash = new WeakMap()) {
  if (obj.constructor === Date) {
    return new Date(obj)       // 日期对象直接返回一个新的日期对象
  }
  
  if (obj.constructor === RegExp){
    return new RegExp(obj)     //正则对象直接返回一个新的正则对象
  }
  
  //如果循环引用了就用 weakMap 来解决
  if (hash.has(obj)) {
    return hash.get(obj)
  }
  let allDesc = Object.getOwnPropertyDescriptors(obj)

  //遍历传入参数所有键的特性
  let cloneObj = Object.create(Object.getPrototypeOf(obj), allDesc)

  //继承原型链
  hash.set(obj, cloneObj)

  for (let key of Reflect.ownKeys(obj)) { 
    cloneObj[key] = (isComplexDataType(obj[key]) && typeof obj[key] !== 'function') ? deepClone(obj[key], hash) : obj[key]
  }
  return cloneObj
}
// 下面是验证代码
let obj = {
  num: 0,
  str: '',
  boolean: true,
  unf: undefined,
  nul: null,
  obj: { name: '我是一个对象', id: 1 },
  arr: [0, 1, 2],
  func: function () { console.log('我是一个函数') },
  date: new Date(0),
  reg: new RegExp('/我是一个正则/ig'),
  [Symbol('1')]: 1,
};
Object.defineProperty(obj, 'innumerable', {
  enumerable: false, value: '不可枚举属性' }
);
obj = Object.create(obj, Object.getOwnPropertyDescriptors(obj))
obj.loop = obj    // 设置loop成循环引用的属性
let cloneObj = deepClone(obj)
cloneObj.arr.push(4)
console.log('obj', obj)
console.log('cloneObj', cloneObj)
```

我们看一下结果，`cloneObj` 在 `obj` 的基础上进行了一次深拷贝，`cloneObj` 里的 `arr` 数组进行了修改，并未影响到 `obj.arr` 的变化，如下图所示

![img](http://img-repo.poetries.top/images/20210414142525.png)





```
function deepClone(obj){
  let cloneObj;
  // 判断当输入的数据是简单数据类型时，直接复制
  if(obj && typeof obj !== 'object'){
    cloneObj = obj;
  }
  // 当输入的数据是对象或者数组时
  else if(obj && typeof obj === 'object'){
    // 检测输入的数据是数组还是对象
    cloneObj = Array.isArray(obj) ? [] : {};

    // 变量数据对象
    for(let key in obj){
      // 判断对象是否存在key属性
      if(obj.hasOwnProperty(key)){
        if(obj[key] && typeof obj[key] === 'object'){
          // 若当前元素类型为对象时，递归调用
          cloneObj[key] = deepClone(obj[key]);
        }
        // 若当前元素类型为基本数据类型
        else{
          cloneObj[key] = obj[key];
        }
      }
    }
  }
  return cloneObj;
}
```





## 17  节流与防抖以及回流重绘

#### 「1.  **函数防抖** 」

- 是指在事件**被触发 n 秒后再执行回调**，如果在这 n 秒内事件又被触发，**则重新计时**。这可以使用在一些点击请求的事件上，避免因为用户的多次点击向后端发送多次请求。

```
// 函数防抖的实现
function debounce(fn, wait) {
  var timer = null;

  return function() {
    var context = this;
    var args = arguments;

    // 如果此时存在定时器的话，则取消之前的定时器重新记时
    if (timer) {
     clearTimeout(timer);
     timer = null;
    }

    // 设置定时器，使事件间隔指定事件后执行
   timer = setTimeout(() => {
      fn.apply(context, args);
   }, wait);
  };
}
```



#### 「2.  函数节流」

- 是指规定一个单位时间，在这个单位时间内，只能**有一次触发事件的回调函数执行**，如果在同一个单位时间内某事件被触发多次，**只有一次能生效**。节流可以使用在 scroll 函数的事件监听上，通过事件节流来降低事件调用的频率。

```
// 函数节流的实现;
function throttle(fn, delay) {
  var preTime = Date.now();

  return function() {
    var context = this;
    var args = arguments;
    var nowTime = Date.now();

    // 如果两次时间间隔超过了指定时间，则执行函数。
    if (nowTime - preTime >= delay) {
      preTime = Date.now();
      return fn.apply(context, args);
    }
  };
}

function throttle(fn, delay) {
  var timer = null
  return function (...args) {
    var that = this
    if (!timer) {
      timer = setTimeout(function () {
        fn.apply(that, args)
        timer = null
      }, delay)
    }
  }
}


function throttle(func, wait ,type) {
    if(type===1){
        let previous = 0;
    }else if(type===2){
        let timeout;
    }
    return function() {
        let context = this;
        let args = arguments;
        if(type===1){
            let now = Date.now();

            if (now - previous > wait) {
                func.apply(context, args);
                previous = now;
            }
        }else if(type===2){
            if (!timeout) {
                timeout = setTimeout(() => {
                    timeout = null;
                    func.apply(context, args)
                }, wait)
            }
        }
    }
}
```



#### 「3.  重绘和回流」

- **重绘：**当渲染树中的元素外观（如：颜色）发生改变，不影响布局时，产生重绘
- **回流：**当渲染树中的元素的布局（如：尺寸、位置、隐藏/状态状态）发生改变时，产生重绘回流
- 注意：JS获取Layout属性值（如：`offsetLeft`、`scrollTop`、`getComputedStyle`等）也会引起回流。因为浏览器需要通过回流计算最新值
- 回流必将引起重绘，而重绘不一定会引起回流

**如何最小化重绘(repaint)和回流(reflow)**：

- 需要要对元素进行复杂的操作时，可以先隐藏(`display:"none"`)，操作完成后再显示
- 需要创建多个`DOM`节点时，使用`DocumentFragment`创建完后一次性的加入`document`
- 缓存`Layout`属性值，如：`var left = elem.offsetLeft;` 这样，多次使用 `left` 只产生一次回流
- 尽量避免用`table`布局（`table`元素一旦触发回流就会导致table里所有的其它元素回流）
- 避免使用`css`表达式(`expression`)，因为每次调用都会重新计算值（包括加载页面）
- 尽量使用 `css` 属性简写，如：用 `border` 代替 `border-width`, `border-style`, `border-color`
- 批量修改元素样式：`elem.className` 和 `elem.style.cssText` 代替 `elem.style.xxx`



## 18  ajax和axios

- `Ajax`的原理简单来说是在用户和服务器之间加了—个中间层(`AJAX`引擎)，通过`XmlHttpRequest`对象来向服务器发异步请求，从服务器获得数据，然后用`javascrip`t来操作`DOM`而更新页面。使用户操作与服务器响应异步化。这其中最关键的一步就是从服务器获得请求数据

  `Ajax`的过程只涉及`JavaScript`、`XMLHttpRequest`和`DOM`。`XMLHttpRequest`是`ajax`的核心机制
  
- 创建AJAX请求的步骤：

  - **创建一个 XMLHttpRequest 对象。**
  - 在这个对象上**使用 open 方法创建一个 HTTP 请求**，open 方法所需要的参数是请求的方法、请求的地址、是否异步和用户的认证信息。
  - 在发起请求前，可以为这个对象**添加一些信息和监听函数**。比如说可以通过 setRequestHeader 方法来为请求添加头信息。还可以为这个对象添加一个状态监听函数。一个 XMLHttpRequest 对象一共有 5 个状态，当它的状态变化时会触发onreadystatechange 事件，可以通过设置监听函数，来处理请求成功后的结果。当对象的 readyState 变为 4 的时候，代表服务器返回的数据接收完成，这个时候可以通过判断请求的状态，如果状态是 2xx 或者 304 的话则代表返回正常。这个时候就可以通过 response 中的数据来对页面进行更新了。
  - 当对象的属性和监听函数设置完成后，最后调**用 sent 方法来向服务器发起请求**，可以传入参数作为发送的数据体。

> 它是一种异步通信的方法，通过直接由 js 脚本向服务器发起 http 通信，然后根据服务器返回的数据，更新网页的相应部分，而不用刷新整个页面的一种方法。
>

![img](https://poetries1.gitee.io/img-repo/2020/09/9.png)

**区别ajax请求与一般HTTP请求：**
			ajax请求是一种**特别的http请求**: 只有通过XHR/fetch发送的是ajax请求, 其它都是一般HTTP请求
	对服务器端来说, 没有任何区别, 区别在浏览器端
	浏览器端发请求: 只有XHR或fetch发出的才是ajax请求, 其它所有的都是非ajax请求
	浏览器端接收到响应
      一般请求: 浏览器一般会直接显示响应体数据, 也就是我们常说的刷新/跳转页面
  	  ajax请求: 浏览器不会对界面进行任何更新操作, 只是调用监视的回调函数并传入响应相关数据



#### 「ajax和fetch的区别」

![image-20211004165941974](https://gitee.com/wexia/my_pic_bed/raw/master/pics/20211006113414.png)



#### 「**面试手写（原生）」**

```js
//1：创建Ajax对象
var xhr = window.XMLHttpRequest?new XMLHttpRequest():new ActiveXObject('Microsoft.XMLHTTP');// 兼容IE6及以下版本
//2：配置 Ajax请求地址
xhr.open('get','index.xml',true);
//3：发送请求
xhr.send(null); // 严谨写法
//4:监听请求，接受响应
xhr.onreadysatechange=function(){
     if(xhr.readySate==4&&xhr.status==200 || xhr.status==304 )
          console.log(xhr.responsetXML)
}
```

#### **「promise 封装实现」**

```js
// promise 封装实现：

function getJSON(url) {
  // 创建一个 promise 对象
  let promise = new Promise(function(resolve, reject) {
    let xhr = new XMLHttpRequest();

    // 新建一个 http 请求
    xhr.open("GET", url, true);

    // 设置状态的监听函数
    xhr.onreadystatechange = function() {
      if (this.readyState !== 4) return;

      // 当请求成功或失败时，改变 promise 的状态
      if (this.status === 200) {
        resolve(this.response);
      } else {
        reject(new Error(this.statusText));
      }
    };

    // 设置错误监听函数
    xhr.onerror = function() {
      reject(new Error(this.statusText));
    };

    // 设置响应的数据类型
    xhr.responseType = "json";

    // 设置请求头信息
    xhr.setRequestHeader("Accept", "application/json");

    // 发送 http 请求
    xhr.send(null);
  });

  return promise;
}
```

> axios是通过promise实现对ajax技术的一种封装，就像jQuery实现ajax封装，是现在前端最流行的ajax请求库
>



## 19  数组去重方法

#### 「1.  利用ES6 Set（ES6最常用）」

```pgsql
function unique (arr) {
  return Array.from(new Set(arr))
}
var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];
console.log(unique(arr))
 //[1, "true", true, 15, false, undefined, null, NaN, "NaN", 0, "a", {}, {}]
```

不考虑兼容性，这种去重的方法代码最少。这种方法还无法去掉“{}”空对象，后面的高阶方法会添加去掉重复“{}”的方法。

#### 「2.  利用for嵌套+splice（ES5」

```pgsql
function unique(arr){            
        for(var i=0; i<arr.length; i++){
            for(var j=i+1; j<arr.length; j++){
                if(arr[i]==arr[j]){         //第一个等同于第二个，splice方法删除第二个
                    arr.splice(j,1);
                    j--;
                }
            }
        }
return arr;
}
var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];
    console.log(unique(arr))
    //[1, "true", 15, false, undefined, NaN, NaN, "NaN", "a", {…}, {…}]     //NaN和{}没有去重，两个null直接消失了
```

双层循环，外层循环元素，内层循环时比较值。值相同时，则删去这个值。
想快速学习更多常用的ES6语法，可以看我之前的文章[《学习ES6笔记──工作中常用到的ES6语法》](https://segmentfault.com/a/1190000016068235)。

#### 「3.  利用indexOf」

```pgsql
function unique(arr) {
    if (!Array.isArray(arr)) {
        console.log('type error!')
        return
    }
    var array = [];
    for (var i = 0; i < arr.length; i++) {
        if (array .indexOf(arr[i]) === -1) {
            array .push(arr[i])
        }
    }
    return array;
}
var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];
console.log(unique(arr))
   // [1, "true", true, 15, false, undefined, null, NaN, NaN, "NaN", 0, "a", {…}, {…}]  //NaN、{}没有去重
```

新建一个空的结果数组，for 循环原数组，判断结果数组是否存在当前元素，如果有相同的值则跳过，不相同则push进数组。

#### 「4. 利用sort()」

```pgsql
function unique(arr) {
    if (!Array.isArray(arr)) {
        console.log('type error!')
        return;
    }
    arr = arr.sort()
    var arrry= [arr[0]];
    for (var i = 1; i < arr.length; i++) {
        if (arr[i] !== arr[i-1]) {
            arrry.push(arr[i]);
        }
    }
    return arrry;
}
     var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];
        console.log(unique(arr))
// [0, 1, 15, "NaN", NaN, NaN, {…}, {…}, "a", false, null, true, "true", undefined]      //NaN、{}没有去重
```

利用sort()排序方法，然后根据排序后的结果进行遍历及相邻元素比对。

#### 「5.  利用includes」

```pgsql
function unique(arr) {
    if (!Array.isArray(arr)) {
        console.log('type error!')
        return
    }
    var array =[];
    for(var i = 0; i < arr.length; i++) {
            if( !array.includes( arr[i]) ) {//includes 检测数组是否有某个值
                    array.push(arr[i]);
              }
    }
    return array
}
var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];
    console.log(unique(arr))
    //[1, "true", true, 15, false, undefined, null, NaN, "NaN", 0, "a", {…}, {…}]     //{}没有去重
```

#### 「6.  利用hasOwnProperty」

```pgsql
function unique(arr) {
    var obj = {};
    return arr.filter(function(item, index, arr){
        return obj.hasOwnProperty(typeof item + item) ? false : (obj[typeof item + item] = true)
    })
}
    var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];
        console.log(unique(arr))
//[1, "true", true, 15, false, undefined, null, NaN, "NaN", 0, "a", {…}]   //所有的都去重了
```

利用hasOwnProperty 判断是否存在对象属性

#### 「7.  利用filter」

```pgsql
function unique(arr) {
  return arr.filter(function(item, index, arr) {
    //当前元素，在原始数组中的第一个索引==当前索引值，否则返回当前元素
    return arr.indexOf(item, 0) === index;
  });
}
    var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];
        console.log(unique(arr))
//[1, "true", true, 15, false, undefined, null, "NaN", 0, "a", {…}, {…}]
```

#### 「8.  利用递归」

```pgsql
function unique(arr) {
        var array= arr;
        var len = array.length;

    array.sort(function(a,b){   //排序后更加方便去重
        return a - b;
    })

    function loop(index){
        if(index >= 1){
            if(array[index] === array[index-1]){
                array.splice(index,1);
            }
            loop(index - 1);    //递归loop，然后数组去重
        }
    }
    loop(len-1);
    return array;
}
 var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];
console.log(unique(arr))
//[1, "a", "true", true, 15, false, 1, {…}, null, NaN, NaN, "NaN", 0, "a", {…}, undefined]
```

#### 「9.  利用Map数据结构」

```pgsql
function arrayNonRepeatfy(arr) {
  let map = new Map();
  let array = new Array();  // 数组用于返回结果
  for (let i = 0; i < arr.length; i++) {
    if(map .has(arr[i])) {  // 如果有该key值
      map .set(arr[i], true); 
    } else { 
      map .set(arr[i], false);   // 如果没有该key值
      array .push(arr[i]);
    }
  } 
  return array ;
}
 var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];
    console.log(unique(arr))
//[1, "a", "true", true, 15, false, 1, {…}, null, NaN, NaN, "NaN", 0, "a", {…}, undefined]
```

创建一个空Map数据结构，遍历需要去重的数组，把数组的每一个元素作为key存到Map中。由于Map中不会出现相同的key值，所以最终得到的就是去重后的结果。

#### 「10.  利用reduce+includes」

```coffeescript
function unique(arr){
    return arr.reduce((prev,cur) => prev.includes(cur) ? prev : [...prev,cur],[]);
}
var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];
console.log(unique(arr));
// [1, "true", true, 15, false, undefined, null, NaN, "NaN", 0, "a", {…}, {…}]
```

#### 「11.  [...new Set(arr)]」

```cos
[...new Set(arr)] 
//代码就是这么少----（其实，严格来说并不算是一种，相对于第一种方法来说只是简化了代码）
```



## 20 常见的CSS布局方法

![常见CSS布局](https://gitee.com/wexia/my_pic_bed/raw/master/pics/20210810143751.png)

#### 「1.  单栏布局」

常见的单列布局有两种：

- **header,content 和 footer 等宽的单列布局**
- **header 与 footer 等宽,content 略窄的单列布局**



##### header,content 和 footer 等宽的单列布局

​		先通过对 header,content,footer 统一设置 width：1000px;或者 max-width：1000px(这两者的区别是当屏幕小于 1000px 时，前者会出现滚动条，后者则不会，显示出实际宽度);然后设置 `margin:auto` 实现居中即可得到。

```
<div class="header"></div>
<div class="content"></div>
<div class="footer"></div>
```

```
.header{
    margin:0 auto; 
    max-width: 960px;
    height:100px;
}
.content{
    margin: 0 auto;
    max-width: 960px;
    height: 400px;
}
.footer{
    margin: 0 auto;
    max-width: 960px;
    height: 100px;
}
```



##### header 与 footer 等宽,content 略窄的单列布局

对于第二种，header、footer的内容宽度不设置，块级元素充满整个屏幕，但header、content和footer的内容区设置同一个width，并通过`margin:auto`实现居中。

```
<div class="header">
    <div class="nav"></div>
</div>
<div class="content"></div>
<div class="footer"></div>
```

```
.header{
    margin:0 auto;
    max-width: 960px;
    height:100px;
}
.nav{
    margin: 0 auto;
    max-width: 800px;
    height: 50px;
}
.content{
    margin: 0 auto;
    max-width: 800px;
    height: 400px;
}
.footer{
    margin: 0 auto;
    max-width: 960px;
    height: 100px;
}
```



#### 「2.  两栏布局」

​	**`两列自适应布局是指一列由内容撑开，另一列撑满剩余宽度的布局方式`**

##### 	float+overflow:hidden

​		如果是普通的两列布局，浮动+普通元素的 margin便可以实现，但如果是自适应的两列布局，利用`float+overflow:hidden`便可以实现，这种办法主要通过 overflow 触发 BFC,而 BFC 不会重叠浮动元素。由于设置 `overflow:hidden` 并不会触发 IE6-浏览器的 `haslayout `属性，所以需要设置` zoom:1 `来兼容 IE6-浏览器。

```
<div class="parent" style="background-color: lightgrey;">
    <div class="left" style="background-color: lightblue;">
        <p>left</p>
    </div>
    <div class="right"  style="background-color: lightgreen;">
        <p>right</p>
        <p>right</p>
    </div>        
</div>
```

```
.parent {
  overflow: hidden;
  zoom: 1;
}
.left {
  float: left;
  margin-right: 20px;
}
.right {
  overflow: hidden;
  zoom: 1;
}
```

> 注意点:如果侧边栏在右边时，注意渲染顺序。即在HTML中，先写侧边栏后写主内容



##### Flex布局

Flex布局，也叫弹性盒子布局，区区简单几行代码就可以实现各种页面的的布局。

 flex 子项目占的份数: **分配剩余的空间**（把父盒子里面的都分配完了之后，剩余的空间再拿来分）

```
//html部分同上
.parent {
  display:flex;
}  
.right {
  margin-left:20px; 
  flex:1;
}
```

**flex**属性 是 flex-grow、flex-shrink、flex-basis三个属性的缩写。

##### Grid布局

Grid布局，是一个基于网格的二维布局系统，目的是用来优化用户界面设计。

```
//html部分同上
.parent {
  display:grid;
  grid-template-columns:auto 1fr;
  grid-gap:20px
} 
```



#### 「3.  三栏布局」

**`特征：中间列自适应宽度，旁边两侧固定宽度，实现三栏布局有多种方式：`**

##### 浮动布局

![image-20210810152530917](https://gitee.com/wexia/my_pic_bed/raw/master/pics/20210810152534.png)

```
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Layout</title>
    <style media="screen">
        html * {
            padding: 0;
            margin: 0;
        }
        .layout article div {
            min-height: 150px;
        }
    </style>
</head>
<body>
<!--浮动布局 -->
<section class="layout float">
    <style media="screen">
        .layout.float .left {
            float: left;
            width: 300px;
            background: red;
        }
        .layout.float .center {
            background: yellow;
        }
        .layout.float .right {
            float: right;
            width: 300px;
            background: blue;
        }
    </style>
    <h1>三栏布局</h1>
    <article class="left-right-center">
        <div class="left"></div>
        <div class="right"></div> // 右栏部分要写在中间内容之前
        <div class="center">
            <h2>浮动解决方案</h2>
            1.这是三栏布局的浮动解决方案； 2.这是三栏布局的浮动解决方案； 3.这是三栏布局的浮动解决方案； 4.这是三栏布局的浮动解决方案； 5.这是三栏布局的浮动解决方案； 6.这是三栏布局的浮动解决方案；
        </div>
    </article>
</section>
</body>
</html> 
```

> 这种布局方式，dom 结构必须是先写**浮动部分**，然后**再中间块**，否则**右浮动块会掉到下一行**。 浮动布局的优点就是**比较简单，兼容性也比较好**。但浮动布局是有局限性的，浮动元素脱离文档流，要做清除浮动，这个处理不好的话，会带来很多问题，比如父容器高度塌陷等。



##### 绝对定位布局

```
html同上
<!--绝对布局 -->
<section class="layout absolute">
  <style>
    .layout.absolute .left-center-right>div{
      position: absolute;//三块都是绝对定位
    }
    .layout.absolute .left {
      left:0;
      width: 300px;
      background: red;
    }
    .layout.absolute .center {
      right: 300px;
      left: 300px;//离左右各三百
    background: yellow;
    }
    .layout.absolute .right {
      right: 0;
      width: 300px;
      background: blue;
    }
  </style>
  <h1>三栏布局</h1>
  <article class="left-center-right">
    <div class="left"></div>
    <div class="center"> </div>
    <div class="right"></div>
  </article>
</section> 
```

> 绝对定位布局优点就是**快捷，设置很方便**，而且也不容易出问题。缺点就是，容器脱离了文档流，后代元素也脱离了文档流，高度未知的时候，会有问题，这就导致了这种方法的有效性和可使用性是比较差的。



##### flexbox布局

```
html同上
<!--flexbox布局-->
<section class="layout flexbox">
  <style>
    .layout.flexbox .left-center-right{
      display: flex;
    }
    .layout.flexbox .left {
      width: 300px;
      background: red;
    }
    .layout.flexbox .center {
      background: yellow;
      flex: 1;
    }
    .layout.flexbox .right {
      width: 300px;
      background: blue;
    }
  </style>
  <h1>三栏布局</h1>
  <article class="left-center-right">
    <div class="left"></div>
    <div class="center"> </div>
    <div class="right"></div>
  </article>
</section> 
```

> flexbox 布局是 css3 里新出的一个，它就是为了解决上述两种方式的不足出现的，是比较完美的一个。目前移动端的布局也都是用 flexbox。 flexbox 的缺点就是 IE10 开始支持，但是 IE10 的是-ms 形式的。



##### 表格布局

```
html同上
<!--表格布局-->
<section class="layout table">
  <style>
    .layout.table .left-center-right {
      display: table;
      height: 150px;
      width: 100%;
    }
    .layout.table .left-center-right>div {
      display: table-cell;
    }
    .layout.table .left {
      width: 300px;
      background: red;
    }
    .layout.table .center {
      background: yellow;
    }
    .layout.table .right {
      width: 300px;
      background: blue;
    }
  </style>
  <h1>三栏布局</h1>
  <article class="left-center-right">
    <div class="left"></div>
    <div class="center"> </div>
    <div class="right"></div>
  </article>
</section> 
```

> 表格布局的兼容性很好，在 flex 布局不兼容的时候，可尝试表格布局。当内容溢出时会自动撑开父元素。
>
> 表格布局也是有缺陷:**① 无法设置栏边距；② 对 seo 不友好**；③ 当其中一个单元格高度超出的时候，两侧的单元格也是会跟着一起变高的，然而有时候这并不是我们想要的效果。



##### 网格布局

```
<!--网格布局-->
<section class="layout grid">
  <style>
    .layout.grid .left-center-right {
      display: grid;
      width: 100%;
      grid-template-columns: 300px auto 300px;
      grid-template-rows: 150px;//行高
    }
    .layout.grid .left {
      background: red;
    }
    .layout.grid .center {
      background: yellow;
    }
    .layout.grid .right {
      background: blue;
    }
  </style>
    <h1>三栏布局</h1>
  <article class="left-center-right">
    <div class="left"></div>
    <div class="center"> </div>
    <div class="right"></div>
  </article>
</section> 
```

> CSS Grid 是创建网格布局最强大和最简单的工具。就像表格一样，网格布局可以让 Web 设计师根据元素按列或行对齐排列，但他和表格不同，网格布局没有内容结构，从而使各种布局不可能与表格一样。例如，一个网格布局中的子元素都可以定位自己的位置，这样他们可以重叠和类似元素定位。
>
> 但网格布局的兼容性不好。IE10+上支持，而且也仅支持部分属性。



##### 圣杯布局

① 特点

比较特殊的三栏布局，同样也是两边固定宽度，中间自适应，唯一区别是 **dom 结构必须是先写中间列部分**，这样实现中间列可以优先加载。

```
 <article class="container">
    <div class="center">
      <h2>圣杯布局</h2>
    </div>
    <div class="left"></div>
    <div class="right"></div>
  </article>
```

```
  .container {
    padding-left: 220px;//为左右栏腾出空间
    padding-right: 220px;
  }
  .left {
    float: left;
    width: 200px;
    height: 400px;
    background: red;
    margin-left: -100%;
    position: relative;
    left: -220px;
  }
  .center {
    float: left;
    width: 100%;
    height: 500px;
    background: yellow;
  }
  .right {
    float: left;
    width: 200px;
    height: 400px;
    background: blue;
    margin-left: -200px;
    position: relative;
    right: -220px;
  }
```

② 实现步骤

- 三个部分都**设定为左浮动**，否则左右两边内容上不去，就不可能与中间列同一行。然后设置**center的宽度为100%**(实现中间列内容自适应)，此时，left和right部分会跳到下一行

- 通过设置 **margin-left 为负值**让 left 和 right 部分回到与 center 部分同一行

- 通过设置**父容器**的 padding-left 和 padding-right，让左右两边留出间隙。
- 通过设置相对定位，让 left 和 right 部分移动到两边。

③ 缺点

- center 部分的最小宽度不能小于 left 部分的宽度，否则会 left 部分掉到下一行
- 如果其中一列内容高度拉长(如下图)，其他两列的背景并不会自动填充。(借助等高布局正padding+负margin可解决，下文会介绍)



##### 双飞翼布局

① 特点

​		同样也是三栏布局，在圣杯布局基础上进一步优化，解决了圣杯布局错乱问题，实现了内容与布局的分离。而且任何一栏都可以是最高栏，不会出问题。

```
  <article class="container">
        <div class="center">
            <div class="inner">双飞翼布局</div>
        </div>
        <div class="left"></div>
        <div class="right"></div>
    </article>
```

```
 .container {
        min-width: 600px;//确保中间内容可以显示出来，两倍left宽+right宽
    }
    .left {
        float: left;
        width: 200px;
        height: 400px;
        background: red;
        margin-left: -100%;
    }
    .center {
        float: left;
        width: 100%;
        height: 500px;
        background: yellow;
    }
    .center .inner {
        margin: 0 200px; //新增部分
    }
    .right {
        float: left;
        width: 200px;
        height: 400px;
        background: blue;
        margin-left: -200px;
    }
```

② 实现步骤(前两步与圣杯布局一样)

- 三个部分都设定为左浮动，然后设置center的宽度为100%，此时，left和right部分会跳到下一行；
- 通过设置margin-left为负值让left和right部分回到与center部分同一行；
- center部分**增加一个内层div，并设margin: 0 200px；**

③ 缺点

​	多加一层 dom 树节点，增加渲染树生成的计算量。



***\*3.两种布局实现方式对比:\****

- 两种布局方式都是把主列放在文档流最前面，使主列优先加载。
- 两种布局方式在实现上也有相同之处，都是让三列浮动，然后通过负外边距形成三列布局。
- 两种布局方式的不同之处在于如何处理中间主列的位置：圣杯布局是利用父容器的左、右内边距+两个从列相对定位；双飞翼布局是把主列嵌套在一个新的父级块中利用主列的左、右外边距进行布局调整



#### 「4.  等高布局」

​		等高布局是指**子元素在父元素中高度相等**的布局方式。等高布局的实现包括**伪等高和真等高**,伪等高只是看上去等高而已,真等高是实实在在的等高。

​		此处我们通过伪等布局便可解决圣杯布局的第二点缺点，因为背景是在padding区域显示的，设置一个大数值的`padding-bottom`，再设置相同数值的负的`margin-bottom`，并在所有列外面加上一个容器，并设置`overflow:hidden`把溢出背景切掉。这种可能实现多列等高布局，并且也能实现列与列之间分隔线效果，结构简单，兼容所有浏览器。

```
      .center,
      .left,
      .right {
        padding-bottom: 10000px;
        margin-bottom: -10000px;
      }
      .container {
        padding-left: 220px;
        padding-right: 220px;
        overflow: hidden;//把溢出背景切掉
      }
```

##### 1.利用背景图片

​		这种方法是我们实现等高列最早使用的一种方法，就是**使用背景图片**，在列的父元素上使用这个背景图**进行Y轴的铺放**，从而实现一种等高列的假象。实现方法简单，兼容性强，不需要太多的css样式就可以轻松实现,但此方法不适合流体布局等高列的布局。

在制作样式之前需要一张类似下面的背景图：

![CSS常见的五大布局](http://p99.pstatp.com/large/pgc-image/91b046fe13d84c0f8df6d6fb06cb9bb2)

```
<div class=”container clearfix”> 
 <div class=”left”></div> 
 <div class=”content”></div> 
 <div class=”right”></div> 
</div> 

.container { 
background: url("column.png") repeat-y; 
width: 960px; 
margin: 0 auto; 
} 
.left { 
float: left; 
width: 220px; 
} 
.content { 
float: left; 
width: 480px; 
} 
.right { 
float: left; 
width: 220px; 
} 
```



##### 2.利用正padding+负margin

​		我们通过等布局便可解决圣杯布局的第二点缺点，因为背景是在 padding 区域显示的，设置一个大数值的 `padding-bottom`，再设置相同数值的负的 `margin-bottom`，并在所有列外面加上一个容器，并设置 `overflow:hidden` 把溢出背景切掉。这种可能实现多列等高布局，并且也能实现列与列之间分隔线效果，结构简单，兼容所有浏览器。

```
.center, 
 .left, 
 .right { 
 padding-bottom: 10000px; 
 margin-bottom: -10000px; 
 } 
 .container { 
 padding-left: 220px; 
 padding-right: 220px; 
 overflow: hidden;//把溢出背景切掉 
 } 
```

![CSS常见的五大布局](http://p99.pstatp.com/large/pgc-image/1c23df1339684ba7b5ad6816a96afb59)

##### 3.模仿表格布局

​		这是一种非常简单，易于实现的方法。不过兼容性不好，在ie6-7无法正常运行。

```
<div class="container table">
  <div class="containerInner tableRow">
    <div class="column tableCell cell1">
      <div class="left aside">
        ....
      </div>
    </div>
    <div class="column tableCell cell2">
      <div class="content section">
        ...
      </div>
    </div>
    <div class="column tableCell cell3">
      <div class="right aside">
        ...
      </div>
    </div>
  </div>
</div>

.table {
width: auto;
min-width: 1000px;
margin: 0 auto;
padding: 0;
display: table;
}
.tableRow {
display: table-row;
}
.tableCell {
display: table-cell;
width: 33%;
}
.cell1 {
background: #f00;
height: 800px;
}
.cell2 {
background: #0f0;
}
.cell3 {
background: #00f;
} 
```



##### 4.使用边框和定位

​		这种方法是使用**边框和绝对定位**来实现一个假的高度相等列的效果。结构简单，兼容各浏览器，容易掌握。假设你需要实现一个两列等高布局，侧栏高度要和主内容高度相等。

```
#wrapper {
width: 960px;
margin: 0 auto;
}
#mainContent {
border-right: 220px solid #dfdfdf;
position: absolute;
width: 740px;
height: 800px;
background: green;
}
#sidebar {
background: #dfdfdf;
margin-left: 740px;
position: absolute;
height: 800px;
width: 220px;
}

<div id="wrapper">
  <div id="mainContent">...</div>
  <div id="sidebar">...</div>
</div> 
```





#### 「5. 粘连布局」

**1.特点**

- 有一块内容<main>，当<main>的高康足够长的时候，紧跟在<main>后面的元素<footer>会跟在<main>元素的后面。
- 当<main>元素比较短的时候(比如小于屏幕的高度),我们期望这个<footer>元素能够“粘连”在屏幕的底部

![CSS常见的五大布局](http://p99.pstatp.com/large/pgc-image/44e8e012b8314ad78878fe4758b23b0c)

```
<div id="wrap">
  <div class="main">
    main <br />
    main <br />
    main <br />
  </div>
</div>
<div id="footer">footer</div>


* {
margin: 0;
padding: 0;
}
html,
body {
height: 100%;//高度一层层继承下来
}
#wrap {
min-height: 100%;
background: pink;
text-align: center;
overflow: hidden;
}
#wrap .main {
padding-bottom: 50px;
}
#footer {
height: 50px;
line-height: 50px;
background: deeppink;
text-align: center;
margin-top: -50px;
```



**2.实现步骤**

(1)footer 必须是一个独立的结构，与 wrap 没有任何嵌套关系

(2)wrap 区域的高度通过设置 min-height，变为视口高度

(3)footer 要使用 margin 为负来确定自己的位置

(4)在 main 区域需要设置 padding-bottom。这也是为了防止负 margin 导致 footer 覆盖任何实际内容。



## 21 JS如何判断数组

在JS中，数组是属于Object类型的，也就是属于引用类型（引用类型存放在堆内存中，在栈内存会有一个或者多个地址来指向这个堆内存）。

所以对于引用类型，我们不能typeof来判断具体的类型，因为返回的都是‘object’。

接下来，我将介绍六种判断方法，并且对这六种方法进行逐一解析

#### **① instanceof 操作符判断**

**用法：arr instanceof Array**
**instanceof 主要是用来判断某个实例是否属于某个对象**

```javascript
function obj(){}
let o1 = new obj();
console.log(o1 instanceof obj);  // true
```

那么我们用instanceof 来判断数组的方法如下：

```javascript
let arr = [];
console.log(arr instanceof Array); // true
```

> 但是 instanceof 会有一个问题，**它的问题在于假定只有一个全局执行的环境**。如果网页中包含多个框架，那实际上就存在**两个以上不同的全局执行环境**，**从而存在两个以上不同版本的Array构造函数**。如果你从一个框架向另一个框架传入一个数组，那么传入的数组与在第二个框架中原生创建的数组分别具有不同的构造函数。

#### **②对象构造函数的 constructor判断**

**用法：arr.constructor === Array**
**Object的每个实例都有构造函数 constructor，用于保存着用于创建当前对象的函数**

```abnf
function obj(){}
let o1 = new obj();
console.log(o1.constructor === obj);  // true
```

如上所示，obj 的实例 o1 的 constructor 跟 obj 对象是相等的
那么我们就可以用此来判断数组了

```abnf
let arr = [];
console.log(arr.constructor === Array); // true
```

#### **③Array 原型链上的 isPrototypeOf**

**用法：Array.prototype.isPrototypeOf(arr**)
**Array.prototype  属性表示 Array 构造函数的原型**
其中有一个方法是 isPrototypeOf() 用于测试一个对象是否存在于另一个对象的原型链上。

```javascript
let arr = [];
console.log(Array.prototype.isPrototypeOf(arr)); // true
```

#### **④Object.getPrototypeOf**

**用法：Object.getPrototypeOf(arr) === Array.prototype**
**Object.getPrototypeOf() 方法返回指定对象的原型**

所以只要跟Array的原型比较即可

```abnf
let arr = [];
console.log(Object.getPrototypeOf(arr) === Array.prototype); // true
```

#### **⑤Object.prototype.toString**

**用法：Object.prototype.toString.call(arr) === '[object Array]'**

虽然Array也继承自Object，但js在Array.prototype上重写了toString，而我们通过toString.call(arr)实际上是通过原型链调用了。

```javascript
let arr = [];
console.log(Object.prototype.toString.call(arr) === '[object Array]'); // true
```

#### **⑥Array.isArray**

**用法：Array.isArray(arr)**
**ES5中新增了Array.isArray方法,IE8及以下不支持**

Array.isArray ( arg )
isArray 函数需要一个参数 arg，如果参数是个对象并且 class 内部属性是 "Array", 返回布尔值 true；否则它返回 false。采用如下步骤：
      如果 Type(arg) 不是 Object, 返回 false。
      如果 arg 的 [[Class]] 内部属性值是 "Array", 则返回 true。
      返回 false.

```reasonml
let arr = [];
console.log(Array.isArray(arr)); // true
```



## 22 CSS实现垂直水平居中

### 「水平居中的方法」

- 元素为行内元素，设置父元素`text-align:center`
- 如果元素宽度固定，可以设置左右`margin`为`auto`;
- 绝对定位和移动: `absolute + transform`
- 使用`flex-box`布局，指定`justify-content`属性为center
- `display`设置为`tabel-ceil`



### 「垂直居中的方法」

- 将显示方式设置为表格，`display:table-cell`,同时设置`vertial-align：middle`
- 使用`flex`布局，设置为`align-item：center`
- 绝对定位中设置`bottom:0,top:0`,并设置`margin:auto`
- 绝对定位中固定高度时设置`top:50%，margin-top`值为高度一半的负值
- 文本垂直居中设置`line-height`为`height`值

- 如果是单行文本, line-height 设置成和 height 值

```css
.vertical {
    height: 100px;
    line-height: 100px;
  }
```

- 已知高度的块级子元素，采用绝对定位和负边距

```css
.container {
  position: relative;
}
.vertical {
  height: 300px;  /*子元素高度*/
  position: absolute;
  top:50%;  /*父元素高度50%*/
  margin-top: -150px; /*自身高度一半*/
}
```

- 未知高度的块级父子元素居中，模拟表格布局
- 缺点：IE67不兼容，父级 overflow：hidden 失效

```css
.container {
    display: table;
  }
  .content {
    display: table-cell;
    vertical-align: middle;
  }
```

- 新增 inline-block 兄弟元素，设置 vertical-align
  - 缺点：需要增加额外标签，IE67不兼容

```css
.container {
  height: 100%;/*定义父级高度，作为参考*/
}
.extra .vertical{
  display: inline-block;  /*行内块显示*/
  vertical-align: middle; /*垂直居中*/
}
.extra {
  height: 100%; /*设置新增元素高度为100%*/
}
```

- 绝对定位配合 CSS3 位移

```css
.vertical {
  position: absolute;
  top:50%;  /*父元素高度50%*/
  transform:translateY(-50%, -50%);
}
```

- CSS3弹性盒模型

```css
.container {
  display:flex;
  justify-content: center; /*子元素水平居中*/
  align-items: center; /*子元素垂直居中*/
}
```



## 23 跨域问题及解决

所谓同源是指"**协议+域名+端口**"三者相同，即便两个不同的域名指向同一个ip地址，也非同源

目前，如果非同源，共有三种行为受到限制。

> （1） Cookie、LocalStorage 和 IndexDB 无法读取。
>
> （2） DOM 无法获得。
>
> （3） AJAX 请求不能发送。

​		重用的有 `jsonp`、`iframe`、`cors`、`img`、`HTML5 postMessage`等等。其中用到 `html` 标签进行跨域的原理就是 `html` 不受同源策略影响。但只是接受 `Get` 的请求方式，这个得清楚。

**跨域解决方法：**

https://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html

![image-20211004210706885](https://gitee.com/wexia/my_pic_bed/raw/master/pics/20211006110809.png)



### **「解决跨域问题」**

> **总结：**

​		`jsonp`（只支持get请求，支持老的IE浏览器）适合加载不同域名的js、css，img等静态资源；`CORS`（支持所有类型的HTTP请求，但浏览器IE10以下不支持）适合做ajax各种跨域请求；`Nginx代理跨域`和`nodejs中间件`跨域原理都相似，都是搭建一个服务器，直接在服务器端请求HTTP接口，这适合前后端分离的前端项目调后端接口。`document.domain+iframe`适合主域名相同，子域名不同的跨域请求。`postMessage、websocket`都是HTML5新特性，兼容性不是很好，只适用于主流浏览器和IE10+。

- **`通过jsonp跨域`**
  - **jsonp**的原理就是利用`<script>`标签没有跨域限制，通过`<script>`标签src属性，发送带有callback参数的**GET请求**，服务端将接口返回数据拼凑到callback函数中，返回给浏览器，浏览器解析执行，从而前端拿到callback函数返回的数据。
  
  > 1）原生js实现
  
  ```
  // 原生js实现
  <script>
      var script = document.createElement('script');
      script.type = 'text/javascript';
      // 传参一个回调函数名给后端，方便后端返回时执行这个在前端定义的回调函数
      script.src = 'http://www.domain2.com:8080/login?user=admin&callback=handleCallback';
      document.head.appendChild(script);
      // 回调执行函数
      function handleCallback(res) {
          alert(JSON.stringify(res));
      }
   </script>
  ```
  
  服务端返回如下（返回时即执行全局函数）：
  
  ```javascript
  handleCallback({"success": true, "user": "admin"})
  ```
  
  > 2）Vue axios实现：
  
  ```javascript
  this.$http = axios;
  this.$http.jsonp('http://www.domain2.com:8080/login', {
      params: {},
      jsonp: 'handleCallback'
  }).then((res) => {
      console.log(res); 
  })
  ```
  
  后端node.js代码：
  
  ```javascript
  var querystring = require('querystring');
  var http = require('http');
  var server = http.createServer();
  server.on('request', function(req, res) {
      var params = querystring.parse(req.url.split('?')[1]);
      var fn = params.callback;
      // jsonp返回设置
      res.writeHead(200, { 'Content-Type': 'text/javascript' });
      res.write(fn + '(' + JSON.stringify(params) + ')');
      res.end();
  });
  server.listen('8080');
  console.log('Server is running at port 8080...');
  ```
  
  
  
  - **html中允许跨域的标签**：script、link、img、video、audio、frame、iframe、embed等有src属性的标签
  - 它只支持GET请求而不支持POST等其它类型的HTTP请求，JSONP 是一种【请求一段 JS 脚本，把执行这段脚本的结果当做数据】的方法，JSONP的实现原理就是创建一个script标签, 再把需要请求的api地址放到src里，没地方设置请求格式，所以只能是GET方法。
  - 它只支持跨域HTTP请求这种情况，不能解决不同域的两个页面之间如何进行JavaScript调用的问题。
  - jsonp在调用失败的时候不会返回各种HTTP状态码。
  - 缺点是安全性。万一假如提供jsonp的服务存在页面注入漏洞，即它返回的javascript的内容被人控制的。
  
- **`nginx代理跨域`**
  - nginx代理跨域，实质和CORS跨域原理一样，通过配置文件设置请求响应头`Access-Control-Allow-Origin…`等字段。
  
- **`nodejs中间件代理跨域`**
  - node中间件实现跨域代理，原理大致与nginx相同，都是通过启一个代理服务器，实现数据的转发，也可以通过设置`cookieDomainRewrite`参数修改响应头中cookie中域名，实现当前域的cookie写入，方便接口登录认证。
  
- **`document.domain + iframe跨域`**
  - 
    此方案仅限主域相同，子域不同的跨域应用场景。实现原理：两个页面都通过js强制设置document.domain为基础主域，就实现了同域
  
- **`location.hash + iframe跨域`**
  - 实现原理： a欲与b跨域相互通信，通过中间页c来实现。 三个页面，不同域之间利用iframe的location.hash传值，相同域之间直接js访问来通信。
  - 具体实现：A域：a.html -> B域：b.html -> A域：c.html，a与b不同域只能通过hash值单向通信，b与c也不同域也只能单向通信，但c与a同域，所以c可通过parent.parent访问a页面所有对象。
  
- **`window.name + iframe跨域`**
  - window.name属性的独特之处：name值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）
  
- **`postMessage跨域`**
  - postMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题：
    - 页面和其打开的新窗口的数据传递
    - 多窗口之间消息传递
    - 页面与嵌套的iframe消息传递
    - 上面三个场景的跨域数据传递
  
- **`WebSocket协议跨域`**
  - WebSocket protocol是HTML5一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯，是server push技术的一种很好的实现。
    原生WebSocket API使用起来不太方便，我们使用Socket.io，它很好地封装了webSocket接口，提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容。



#### 跨域资源共享（CORS）

- **CORS**是一个W3C标准，全称是"跨域资源共享"（Cross-origin resource sharing）。
  它允许浏览器向跨源服务器，发出`XMLHttpRequest`请求，从而克服了AJAX只能同源使用的限制。
  CORS需要浏览器和服务器同时支持。

- **CORS**背后的基本思想是使用自定义的HTTP头部允许浏览器和服务器相互了解对方，从而决定请求或响应成功与否。

- **CORS**跨域实际发起了两个http请求，第一个先发送CORS请求，就是在头信息之中，增加一个Origin字段

- 为了支持**CORS**跨域访问，常在过滤器或者拦截器中添加的配置如下：

  > response.setHeader("Access-Control-Allow-Origin", "*");   // 表示接受任意域名的请求。
  >
  > response.setHeader("Access-Control-Allow-Methods", "POST,OPTIONS,GET");      // 设置服务器支持的跨域请求的方法
  >
  > response.setHeader("Access-Control-Allow-Headers", "accept,x-requested-with,Content-Type,X-Custom-Header");   // 可选字段，CORS请求时默认支持6个基本字段，
  >
  > response.setHeader("Access-Control-Allow-Credentials", "true");  //  可选字段，布尔值类型，表示是否允许发送Cookie。
  >
  > response.setHeader("Access-Control-Max-Age", "3600");  //  可选字段，用来指定预检请求的有效期，单位为秒，在此期间不用发出另一条预检请求，不指定时即使用默认值，Chrome默认5秒

  

  跨域资源共享(`CORS`)是一种机制，是W3C标准。它允许浏览器向跨源服务器，发出`XMLHttpRequest`或`Fetch`请求。并且整个`CORS`通信过程都是浏览器自动完成的，不需要用户参与。

  而使用这种`跨域资源共享`的前提是，浏览器必须支持这个功能，并且服务器端也必须同意这种`"跨域"`请求。因此实现`CORS`的关键是服务器需要服务器。通常是有以下几个配置：
  
  - **Access-Control-Allow-Origin**
  - **Access-Control-Allow-Methods**
  - **Access-Control-Allow-Headers**
  - **Access-Control-Allow-Credentials**
  - **Access-Control-Max-Age**

  过程分析：

  **简单回答**：
  
  - 当我们发起跨域请求时，**如果是非简单请求**，浏览器会帮我们自动触发预检请求，也就是 OPTIONS 请求，用于确认目标资源是否支持跨域。**如果是简单请求，则不会触发预检，直接发出正常请求。**
  - 浏览器会根据服务端响应的 header 自动处理剩余的请求，如果响应支持跨域，则继续发出正常请求，如果不支持，则在控制台显示错误。

  **详细回答**：
  
  - 浏览器先根据同源策略对前端页面和后台交互地址做匹配，若同源，则直接发送数据请求；若不同源，则发送跨域请求。
  - 服务器收到浏览器跨域请求后，根据自身配置返回对应文件头。若未配置过任何允许跨域，则文件头里不包含 `Access-Control-Allow-origin` 字段，若配置过域名，则返回 `Access-Control-Allow-origin + 对应配置规则里的域名的方式`。
  - 浏览器根据接受到的 响应头里的 `Access-Control-Allow-origin` 字段做匹配，若无该字段，说明不允许跨域，从而抛出一个错误；若有该字段，则对字段内容和当前域名做比对，如果同源，则说明可以跨域，浏览器接受该响应；若不同源，则说明该域名不可跨域，浏览器不接受该响应，并抛出一个错误。

  在`CORS`中有`简单请求`和`非简单请求`，简单请求是不会触发`CORS`的预检请求的，而非简单请求会。
  
  `“需预检的请求”`要求必须首先使用 [`OPTIONS` (opens new window)](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/OPTIONS)方法发起一个预检请求到服务器，以获知服务器是否允许该实际请求。"预检请求“的使用，可以避免跨域请求对服务器的用户数据产生未预期的影响。

##### CORS的哪些是简单请求？

> 简单请求不会触发`CORS`的预检请求，若请求满足所有下述条件，则该请求可视为“简单请求”：

**简单回答**：

- 只能使用`GET`、`HEAD`、`POST`方法。使用`POST`方法向服务器发送数据时，`Content-Type`只能使用`application/x-www-form-urlencoded`、`multipart/form-data`或`text/plain`编码格式。
- 请求时不能使用自定义的`HTTP Headers`

**详细回答**：

- (一) 使用下列方法之一
  - `GET`
  - `HEAD`
  - `POST`
- (二) 只能设置以下集合中的请求头
  - `Accept`
  - `Accept-Language`
  - `Content-Language`
  - `Content-Type`(但是有限制)
  - `DPR`
  - `Downlink`
  - `Save-Data`
  - `Viewport-Width`
  - `Width`
- (三) `Content-Type`的值仅限于下面的三者之一
  - `text/plain`
  - `multipart/form-data`
  - `application/x-www-form-urlencoded`
- 请求中的任意[`XMLHttpRequestUpload` (opens new window)](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequestUpload)对象均没有注册任何事件监听器；[`XMLHttpRequestUpload` (opens new window)](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequestUpload)对象可以使用 [`XMLHttpRequest.upload` (opens new window)](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/upload)属性访问。
- 请求中没有使用 [`ReadableStream` (opens new window)](https://developer.mozilla.org/zh-CN/docs/Web/API/ReadableStream)对象。

除了上面这些请求外，都是非简单请求。

##### CORS的预检请求具体是怎样的？

若是跨域的非简单请求的话，浏览器会首先向服务器发送一个预检请求，以获知服务器是否允许该实际请求。

整个过程大概是：

- 浏览器给服务器发送一个

  ```
  OPTIONS
  ```

  方法的请求，该请求会携带下面两个首部字段：

  - `Access-Control-Request-Method`: 实际请求要用到的方法
  - `Access-Control-Request-Headers`: 实际请求会携带哪些首部字段

- 若是服务器接受后续请求，则这次预请求的响应体中会携带下面的一些字段：

  - `Access-Control-Allow-Methods`: 服务器允许使用的方法
  - `Access-Control-Allow-Origin`: 服务器允许访问的域名
  - `Access-Control-Allow-Headers`: 服务器允许的首部字段
  - `Access-Control-Max-Age`: 该响应的有效时间(s),在有效时间内浏览器无需再为同一个请求发送预检请求

- 预检请求完毕之后，再发送实际请求

这里有两点要注意：

- `Access-Control-Request-Method`没有`s`
- `Access-Control-Allow-Methods`有`s`
- 关于`Access-Control-Max-Age`，浏览器自身也有维护一个最大有效时间，如果该首部字段的值超过了最大有效时间，将不会生效，而是以最大有效时间为主。

##### 为什么简单请求不需要预检？

因为简单请求虽然是一种定义，不过它定义是有一定理由的，浏览器可能觉得这类请求预检的安全性没有那么大必要，不预检带来性能方面收益更大。

##### 复杂请求预检检查什么东西？

> 预检请求的使用，可以避免跨域请求对服务器的用户数据产生未预期的影响。例如，我某个请求只支持 `headers ,cc`，你发送了一个 `dd 的headers`， 那么 `options` 可以有效拦截，不会发出实体的请求，避免了一些安全问题。

##### 如果CORS附带身份凭证要怎样做？

对于跨域 [`XMLHttpRequest` (opens new window)](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest)或 [Fetch (opens new window)](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)请求，浏览器**不会**发送身份凭证信息。如果要发送凭证信息，需要设置 `XMLHttpRequest`的某个特殊标志位。

例如我们想要在跨域请求中带上`cookie`，需要满足3个条件：

- web（浏览器）请求设置`withCredentials`为`true`
- 服务器设置首部字段`Access-Control-Allow-Credentials`为`true`
- 服务器的`Access-Control-Allow-Origin`不能为`*`

##### 如何减少CORS预请求的次数？

> 服务端设置`Access-Control-Max-Age`字段，在有效时间内浏览器无需再为同一个请求发送预检请求。但是它有局限性：只能为同一个请求缓存，无法针对整个域或者模糊匹配 URL 做缓存。















## 24  浏览器从发送请求到渲染页面过程

![img](http://img-repo.poetries.top/images/20210504134355.png)

**HTTP缓存常考考点：**

**![img](http://img-repo.poetries.top/images/20210504135417.png)**



按照渲染的时间顺序，流水线可分为如下几个子阶段：构建 DOM 树、样式计算、布局阶段、分层、栅格化和显示。如图：

![img](http://img-repo.poetries.top/images/20210504135549.png)

### 「浏览器渲染流程」

- DOM Tree： 浏览器将HTML解析成树形的数据结构。
- CSS Rule Tree：浏览器将CSS解析成树形的数据结构。
- Render Tree：DOM树和CSS规则树合并后生产Render树。
- layout：有了Render Tree，浏览器已经能知道网页中有哪些节点、各个节点的CSS定义以及他们的从属关系，从而去计算出每个节点在屏幕中的位置。
- painting: 按照算出来的规则，通过显卡，把内容画到屏幕上。
- reflow（回流）：当浏览器发现某个部分发生了点变化影响了布局，需要倒回去重新渲染，内行称这个回退的过程叫 `reflow`。reflow 会从 <html> 这个 root frame 开始递归往下，依次计算所有的结点几何尺寸和位置。reflow 几乎是无法避免的。现在界面上流行的一些效果，比如树状目录的折叠、展开（实质上是元素的显 示与隐藏）等，都将引起浏览器的 reflow。鼠标滑过、点击……只要这些行为引起了页面上某些元素的占位面积、定位方式、边距等属性的变化，都会引起它内部、周围甚至整个页面的重新渲 染。通常我们都无法预估浏览器到底会 reflow 哪一部分的代码，它们都彼此相互影响着。
- repaint（重绘）：改变某个元素的背景色、文字颜色、边框颜色等等不影响它周围或内部布局的属性时，屏幕的一部分要重画，但是元素的几何尺寸没有变。

> **浏览器内核拿到响应报文之后，渲染大概分为以下步骤:**

1. 解析html生产DOM树。
2. 解析CSS规则。
3. 根据DOM Tree和CSS Tree生成Render Tree。
4. 根据Render树进行layout，负责各个元素节点的尺寸、位置计算。
5. 绘制Render树(painting)，绘制页面像素信息。
6. 浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显示在屏幕上。

![preview](https://segmentfault.com/img/bV23Wc?w=900&h=352/view)

​		由图中可以看出，css在加载过程中**不会影响到DOM树**的生成，但是会**影响到Render树**的生成，进而影响到layout，所以一般来说，style的link标签需要尽量放在head里面，因为在解析DOM树的时候是自上而下的，而css样式又是通过异步加载的，这样的话，解析DOM树下的body节点和加载css样式能尽可能的并行，加快Render树的生成的速度，当然，如果css是通过js动态添加进来的，会引起页面的重绘或重新布局。



![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c1e8e168d9f249788c74c5b50e0528e2~tplv-k3u1fbpfcp-watermark.awebp)

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/48cd77d608714c298366f4dac77f33fb~tplv-k3u1fbpfcp-watermark.awebp)

![image-20211005160244376](https://gitee.com/wexia/my_pic_bed/raw/master/pics/20211006111630.png)





### 「TCP拥塞控制方法」

滑动窗口机制、慢启动机制、拥塞避免机制、快速重传与恢复。

**慢启动（指数级）---  到达ssthresh 进行 拥塞避免机制（线性） ----  堵塞 ---   快重传和快恢复 **

![img](https://img-blog.csdnimg.cn/20181128224755708.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI2ODk2MjEz,size_16,color_FFFFFF,t_70)

### 「TCP三次握手、四次挥手」

三次握手是指建立TCP连接协议时，需要在客户端和服务器之间发送三个包，握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/55a81db348584e57abdd01c9555f1d5f~tplv-k3u1fbpfcp-watermark.awebp)

**第一次握手**：客户端发送第一个包，其中SYN标志位为1, ACK=0，发送顺序号sequence=X(随机int)。客户端进入SYN发送状态，等待服务器确认。

![img](https://img-blog.csdn.net/20160613142904123?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

**第二次握手**：服务器收到这个包后发送第二个包，其中包SYN、ACK标志位为1，发送顺序号seq=Y(随机int)，接收顺序号ACK=X+1，此时服务器进入SYN接收状态。

**第三次握手**：客户端收到服务器传来的包后，向服务器发送第三个包，SYN=0, ACK=1，接收顺序号ACK = Y+1,发送顺序号seq=X+1。此包发送完毕，客户端和服务器进入ESTABLISHED建立成功状态，完成三次握手。



![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a4190d0d324b427cb63154d3f84e47bc~tplv-k3u1fbpfcp-watermark.awebp)



**四次挥手是指终止TCP连接协议时，需要在客户端和服务器之间发送四个包**

1. 第一次挥手：主动关闭方发送第一个包，其中FIN标志位为1，发送顺序号seq为X。
2. 第二次挥手：被动关闭方收到FIN包后发送第二个包，其中发送顺序号seq为Z，接收顺序号ack为X+1。
3. 第三次挥手：被动关闭方再发送第三个包，其中FIN标志位为1，发送顺序号seq为Y，接收顺序号ack为X。
4. 第四次挥手：主动关闭方发送第四个包，其中发送顺序号为X，接收顺序号为Y。至此，完成四次挥手。

​		超时重传指的是，发送数据包在一定的时间周期内没有收到相应的ACK，等待一定的时间，超时之后就认为这个数据包丢失，就会重新发送。这个等待时间被称为RTO.  



**1、为什么建立连接协议是三次握手，而关闭连接却是四次握手呢？**

   建立连接时，ACK和SYN可以放在一个报文里来发送。而关闭连接时，被动关闭方可能还需要发送一些数据后，再发送FIN报文表示同意现在可以关闭连接了，所以它这里的ACK报文和FIN报文多数情况下都是分开发送的。

**那为什么需要四次挥手呢？**

> 因为当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，“你发的FIN报文我收到了”。只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送，故需要四次挥手。

 

**2、为什么TIME_WAIT状态还需要等2MSL后才能返回到CLOSED状态？**

   两个存在的理由：1、无法保证最后发送的ACK报文会一定被对方收到，所以需要重发可能丢失的ACK报文。2、关闭链接一段时间后可能会在相同的IP地址和端口建立新的连接，为了防止旧连接的重复分组在新连接已经终止后再现。2MSL足以让分组最多存活msl秒被丢弃。

**3、为什么必须是三次握手，不能用两次握手进行连接？**

​    记住服务器的资源宝贵不能浪费! 如果在断开连接后，第一次握手请求连接的包才会使服务器打开连接，占用资源而且容易被恶意攻击！防止攻击的方法，缩短服务器等待时间。两次握手容易死锁。如果服务器的应答分组在传输中丢失，将不知道S建立什么样的序列号，C认为连接还未建立成功，将忽略S发来的任何数据分组，只等待连接确认应答分组。而S在发出的分组超时后，重复发送同样的分组。这样就形成了死锁。

![image-20211006111718824](https://gitee.com/wexia/my_pic_bed/raw/master/pics/20211006111720.png)

![image-20211006111735837](https://gitee.com/wexia/my_pic_bed/raw/master/pics/20211006111736.png)



## 25  cookies，sessionStorage和 localStorage 的区别？

- `cookie`是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）
- cookie数据始终在同源的http请求中携带（即使不需要），只会在浏览器和服务器间来回传递
- `sessionStorage`和`localStorage`不会自动把数据发给服务器，仅在本地保存
- 存储大小：
  - `cookie`数据大小不能超过4k
  - `sessionStorage`和`localStorage`虽然也有存储大小的限制，但比`cookie`大得多，可以达到`5M`或更大, 存储大小一般为`5M`
- 有期时间：
  - `localStorage` 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据
  - `sessionStorage` 数据在当前浏览器窗口关闭后自动删除
  - `cookie` 设置的`cookie`过期时间之前一直有效，即使窗口或浏览器关闭

目前，如果非同源，共有三种行为受到限制。

> （1） Cookie、LocalStorage 和 IndexDB 无法读取。
>
> （2） DOM 无法获得。
>
> （3） AJAX 请求不能发送。

Cookie是存储在**`客户端方`**，Session是存储在**`服务端方`**，客户端只存储`SessionId`。

> **Cookie同源解决**

​		在同源策略的要求下，二级域名是不能相互共享cookie的，但是两个网页一级域名相同，只是二级域名不同，浏览器允许通过设置`document.domain`共享 Cookie。

​		举例来说，A网页是`http://w1.example.com/a.html`，B网页是`http://w2.example.com/b.html`，那么只要设置相同的`document.domain`，两个网页就可以共享Cookie。

```javascript
document.domain = 'example.com';

document.cookie = "test1=hello";  // A 网页设置

var allCookie = document.cookie;  // B 网页读取
```

另外，服务器也可以在设置Cookie的时候，指定Cookie的所属域名为一级域名，比如`.example.com`

```http
Set-Cookie: key=value; domain=.example.com; path=/
//这样的话，二级域名和三级域名不用做任何设置，都可以读取这个Cookie。
```

![彻底搞懂Token、Session和Cookie](http://www.fairysoftware.com/ad_images/token_session_cookie.html1.jpg)

![image-20211004205403943](https://gitee.com/wexia/my_pic_bed/raw/master/pics/20211006110614.png)

![image-20211004205410989](https://gitee.com/wexia/my_pic_bed/raw/master/pics/20211006110619.png)



### 「cookie有哪些属性」

|    属性    | 说明                                                         |
| :--------: | :----------------------------------------------------------- |
| Name=Value | 键值对，可以设置要保存的 Key/Value                           |
|   Domain   | 域名，默认是当前域名，决定Cookie在哪个域是有效的，**Domain**参数必须以点(".")开始。 |
|  Max-age   | 最大失效时间(毫秒),设置在多少后失效                          |
|   Secure   | 当 secure 值为 true 时，cookie 在 HTTP 中是无效，在 HTTPS 中才有效 |
|    Path    | 表示 cookie 影响到的路径，如 path=/。如果路径不能匹配时，浏览器则不发送这个Cookie |
|  Expires   | 过期时间(秒)，在设置的某个时间点后该 Cookie 就会失效，如 expires=Money, 05-Dec-11 11:11:11 GMT |
|  HttpOnly  | 如果在COOKIE中设置了httpOnly属性，则通过程序(JS脚本)将无法读取到COOKIE信息，防止XSS攻击产生 |
|    Size    | 此Cookie的大小。在所有浏览器中，任何cookie大小超过限制都被忽略，且永远不会被设置。各个浏览器对Cookie的最大值和最大数目有不同的限制。 |
|  Priority  | 优先级，chrome的提案，定义了三种优先级，Low/Medium/High，当cookie数量超出时，低优先级的cookie会被优先清除。 |
|  Samesite  | **SameSite**用来限制第三方 Cookie，从而减少安全风险。它有3个属性，分别是：strict、lax、none |

**Name和Value**
Name和Value是一个键值对。Name是Cookie的名称，Cookie一旦创建，名称便不可更改，一般名称不区分大小写；Value是该名称对应的Cookie的值，如果值为Unicode字符，需要为字符编码。如果值为二进制数据，则需要使用BASE64编码。
 

**Domain**
Domain决定Cookie在哪个域是有效的，也就是决定在向该域发送请求时是否携带此Cookie，Domain的设置是对子域生效的，如Doamin设置为 .a.com,则b.a.com和c.a.com均可使用该Cookie，但如果设置为b.a.com,则c.a.com不可使用该Cookie。Domain参数必须以点(".")开始。
 

**Path**
Path是Cookie的有效路径，和Domain类似，也对子路径生效，如Cookie1和Cookie2的Domain均为a.com，但Path不同，Cookie1的Path为 /b/,而Cookie的Path为 /b/c/,则在a.com/b页面时只可以访问Cookie1，在a.com/b/c页面时，可访问Cookie1和Cookie2。Path属性需要使用符号“/”结尾。
 

**Expires/Max-age**
Expires和Max-age均为Cookie的有效期，Expires是该Cookie被删除时的时间戳，格式为GMT,若设置为以前的时间，则该Cookie立刻被删除，并且该时间戳是服务器时间，不是本地时间！若不设置则默认页面关闭时删除该Cookie。
Max-age也是Cookie的有效期，但它的单位为秒，即多少秒之后失效，若Max-age设置为0，则立刻失效，设置为负数，则在页面关闭时失效。Max-age默认为 -1。
 

**Size**
Szie是此Cookie的大小。在所有浏览器中，任何cookie大小超过限制都被忽略，且永远不会被设置。各个浏览器对Cookie的最大值和最大数目有不同的限制，整理为下表(数据来源网络，未测试)：

| 浏览器  | Cookie最大条数 | Cookie最大长度/单位：字节 |
| ------- | -------------- | ------------------------- |
| IE      | 50             | 4095                      |
| Chrome  | 150            | 4096                      |
| FireFox | 50             | 4097                      |
| Opera   | 30             | 4096                      |
| Safari  | 无限           | 4097                      |

**HttpOnly**
HttpOnly值为 true 或 false,若设置为true，则不允许通过脚本document.cookie去更改这个值，同样这个值在document.cookie中也不可见，但在发送请求时依旧会携带此Cookie。

**Secure**
Secure为Cookie的安全属性，若设置为true，则浏览器只会在HTTPS和SSL等安全协议中传输此Cookie，不会在不安全的HTTP协议中传输此Cookie。

**SameSite**
SameSite用来限制第三方 Cookie，从而减少安全风险。它有3个属性，分别是：

- Strict
  Scrict最为严格，完全禁止第三方Cookie，跨站点时，任何情况下都不会发送Cookie

- Lax
  Lax规则稍稍放宽，大多数情况也是不发送第三方 Cookie，但是导航到目标网址的 Get 请求除外。

- None
  网站可以选择显式关闭SameSite属性，将其设为None。不过，前提是必须同时设置Secure属性（Cookie 只能通过 HTTPS 协议发送），否则无效。

-  关闭SameSite的方法

  ​        操作方法谷歌浏览器地址栏输入：chrome://flags/
  ​        找到：SameSite by default cookies、Cookies without SameSite must be secure设置上面这两项设 置成 Disable

**Priority**
优先级，chrome的提案，定义了三种优先级，Low/Medium/High，当cookie数量超出时，低优先级的cookie会被优先清除。
在360极速浏览器和FireFox中，不存在Priority属性，不清楚在此类浏览器中设置该属性后是否生效。

FireFox浏览器的Cookie

![FireFox](https://img-blog.csdnimg.cn/20200805171202619.png)

360极速浏览器的Cookie

![360极速浏览器](https://img-blog.csdnimg.cn/2020080517050835.png)



> **总结：** 服务器端可以使用 Set-Cookie 的响应头部来配置 cookie 信息。一条cookie 包括了5个属性值 expires、domain、path、secure、HttpOnly。其中 expires 指定了 cookie 失效的时间，domain 是域名、path是路径，domain 和 path 一起限制了 cookie 能够被哪些 url 访问。secure 规定了 cookie 只能在确保安全的情况下传输，HttpOnly 规定了这个 cookie 只能被服务器访问，不能使用 js 脚本访问。


​	

### 「Token」

**Token的定义**：Token是服务端生成的一串字符串，以作客户端进行请求的一个令牌，当第一次登录后，服务器生成一个Token便将此Token返回给客户端，以后客户端只需带上这个Token前来请求数据即可，无需再次带上用户名和密码

基于Token的身份验证的过程如下:

1. 用户通过用户名和密码发送请求。
2. 程序验证。
3. 程序返回一个签名的token 给客户端。
4. **客户端**储存token,并且每次用于每次发送请求。
5. **服务端**验证token并返回数据。



### 「判断localStorage是否存满」

用`JSON.stringify(localStorage).length`，和最大容量比较下

同一个域名（`document.domain`）共享同一个` localStorage`，`a.meituan.com` 和 `b.meituan.com` 是两个域名，所以不能共享





### 「web项目用户登录具体流程」

1、前端发送公钥的请求。

2、后台生产公钥私钥对，将公钥返回前端，私钥保存到session中。

3、前端拿到公钥后，对用户输入的密码进行md5加密，然后在对（md5加密后的密码+密码）进行rsa加密，发起登录请求，将用户名和加密后的密码传入后台进行校验。

4、后台接受到加密后的密码首先利用私钥对密码进行解密

5、对密码进行完整的校验即采用前32位的MD5码与原始密码(32位之后的值即为密码)进行MD5加密后进行比较。

6、验证通过后采用shiro的subject.login()将登陆验证的工作转交给shiro进行。

7、通过判断shiro返回的异常信息来获取校验未成功的原因。

8、验证通过检查此用户在其他地方时候登陆。方法为自定义一个session的缓存将登录过的session与用户名存入map中，从缓存中获取此用户名对应的缓存判断sessionid是否一致，若不一致说明此次是重复登录，将之前的session通过shiroSessionManager.getSessionDAO().delete(session)进行剔除。

9、返回登录结果到前端。



### 「cookie和token的五点区别」

①：token和cookie一样都是首次登陆时，由服务器下发，都是当交互时进行验证的功能，作用都是为无状态的HTTP提供的持久机制。

②：token存在哪儿都行，localstorage或者cookie。

③：token和cookie举例，token就是说你告诉我你是谁就可以。

④：对于token而言，服务器不需要去查看你是谁，不需要保存你的会话。当用户logout的时候cookie和服务器的session都会注销；但是当logout时候token只是注销浏览器信息，不查库。

⑤：token优势在于，token由于服务器端不存储会话，所以可扩展性强，token还可用于APP中。

```gauss
Token 完全由应用管理，所以它可以避开同源策略
Token 可以避免 CSRF 攻击
Token 可以是无状态的，可以在多个服务间共享
```



###  cookie 和 token 都存放在 header 中，为什么不会劫持 token？

- 攻击者通过 xss 拿到用户的 cookie 然后就可以伪造 cookie 了
- 或者通过 csrf 在同个浏览器下面通过浏览器会自动带上 cookie 的特性在通过 用户网站-攻击者网站-攻击者请求用户网站的方式 浏览器会自动带上cookie
- 但是 token。不会被浏览器带上 问题 2 解决
- token 是放在 jwt 里面下发给客户端的 而且不一定存储在哪里 不能通过document.cookie 直接拿到，通过 jwt+ip 的方式 可以防止 被劫持 即使被劫持也是无效的 jwt

### 介绍下如何实现 token 加密

- jwt 举例：
  - 需要一个 secret（随机数）
  - 后端利用 secret 和加密算法(如：HMAC-SHA256)对 payload(如账号密码) 生成一个字符串(token)，返回前端
  - 前端每次 request 在 header 中带上 token
  - 后端用同样的算法解密









## 26 BFC块级格式化上下文

**`BFC 即 Block Formatting Contexts (块级格式化上下文)`**，是一个独立的渲染区域，让处于 BFC 内部的元素**与外部的元素相互隔离**，使内外元素的定位不会相互影响

https://zhuanlan.zhihu.com/p/25321647

**触发条件（满足一个就会触发）：**

- `float`的值不为`none`
- `overflow`的值除了`visible`以外的值，`(hidden、auto、scroll)`
- `display`的值为`table-cell`、`tabble-caption`和`inline-block`之一
- `position`的值为`absolute`、`fixed`

**应用:**

- 阻止`margin`重叠(处于同一个 BFC 容器下, 第一个下边距和第二个的上边距发生了重叠 )
- 可以包含浮动元素 —— 清除内部浮动(清除浮动的原理是两个`div`都位于同一个 `BFC` 区域之中)
- 自适应两栏布局
- 可以阻止元素被浮动元素覆盖

**规则:**

- 属于同一个 `BFC` 的两个相邻 `Box` 垂直排列
- 属于同一个 `BFC` 的两个相邻 `Box` 的 `margin` 会发生重叠
- `BFC` 中子元素的 `margin box` 的左边， 与包含块 (BFC) `border box`的左边相接触 (子元素 `absolute` 除外)
- `BFC` 的区域不会与 `float` 的元素区域重叠
- 计算 `BFC` 的高度时，浮动子元素也参与计算
- 文字层不会被浮动层覆盖，环绕于周围



## 27 懒加载的原理

- 懒加载就是将不关键的资源延后加载

> 懒加载的原理就是只加载自定义区域（通常是可视区域，但也可以是即将进入可视区域）内需要加载的东西。对于图片来说，先设置图片标签的 `src` 属性为一张占位图，将真实的图片资源放入一个自定义属性中，当进入自定义区域时，就将自定义属性替换为 `src` 属性，这样图片就会去下载资源，实现了图片懒加载

- 懒加载不仅可以用于图片，也可以使用在别的资源上。比如进入可视区域才开始播放视频等
- 实现懒加载有四个步骤，如下：
  - 1.加载loading图片
  - 2.判断哪些图片要加载【重点】
  - 3.隐形加载图片
  - 4.替换真图片

#### 懒加载与预加载的区别

这两种方式都是提高网页性能的方式，两者主要区别是一个是提前加载，一个是迟缓甚至不加载。懒加载对服务器前端有一定的缓解压力作用，预加载则会增加服务器前端压力。

- **懒加载也叫延迟加载，指的是在长网页中延迟加载图片的时机，当用户需要访问时，再去加载**，这样可以提高网站的首屏加载速度，提升用户的体验，并且可以减少服务器的压力。它适用于图片很多，页面很长的电商网站的场景。懒加载的实现原理是，将页面上的图片的 src 属性设置为空字符串，将图片的真实路径保存在一个自定义属性中，当页面滚动的时候，进行判断，如果图片进入页面可视区域内，则从自定义属性中取出真实路径赋值给图片的 src 属性，以此来实现图片的延迟加载。
- **预加载指的是将所需的资源提前请求加载到本地，这样后面在需要用到时就直接从缓存取资源。** 通过预加载能够减少用户的等待时间，提高用户的体验。我了解的预加载的最常用的方式是使用 js 中的 image 对象，通过为 image 对象来设置 scr 属性，来实现图片的预加载。





## 28  事件（代理）委托

**原理**：

> 实现事件委托是利用了**事件的冒泡原理**实现的。当我们为最外层的节点添加点击事件，那么里面的`ul`、`li`、`a`的点击事件都会冒泡到最外层节点上，委托它代为执行事件

  **使用场景：**

​		很多商品放在一个ul下面的li标签里面，点击添加或删除商品，就可以绑定商品的父元素ul标签，通过事件代理去找到要点击的商品，完成添加删除事件



## 29  ES6、7、8新增属性

> **ES6：**

`let、const、解构赋值、模板字符串、展开符、Symbol、Promise、Set、Map、class类`

> **ES7**：新增 `Array.prototype.includes`、`indexOf()`

> **ES8: **新增`async`和`await`

#### 	「async的实现原理」

async 函数的实现原理就是将 Generator 函数和自动执行器包装在一个函数里。

async 函数本质还是 Generator 函数，是通过不断执行遍历器对象的 next 方法来执行函数。当遍历器对象遍历完毕，就**将最后遍历 (return) 的值 resolve 出来传递给成功回调**。

await 有两个作用：

1. **和 yield 一样，可以将函数的执行进行切割和分步**。
2. **可以将 await 后面的值转化为 promise 实例，然后指定它的回调**。所以通过将 async 函数的下一步执行指定为这个 promise 实例的回调，就可以实现 async 的自动执行。

   Generator 函数遍历器的 next 方法的参数，会作为上一个 yield 的返回值。而 await 会指定其后 promise 的成功回调执行遍历器对象的 next 方法，我们再**把 promise 的成功返回值作为 next 方法的参数，这个值就会成为 await 的返回值**。



## 30  JavaScript中new操作

1. 创建一个新对象
2. 对象连接到构造函数原型上，并绑定 `this`（this 指向新对象）
3. 执行构造函数代码（为这个新对象添加属性）
4. 返回新对象

> new 关键词执行之后总是会返回一个对象，要么是实例对象，要么是 return 语句指定的对象





## 31 HTML5新特性

- `HTML5` 现在已经不是 `SGML` 的子集，主要是关于图像，位置，存储，多任务等功能的增加
  - 新增选择器 `document.querySelector`、`document.querySelectorAll`
  - 拖拽释放(`Drag and drop`) API
  - 媒体播放的 `video` 和 `audio`
  - 本地存储 `localStorage` 和 `sessionStorage`
  - 离线应用 `manifest`
  - 桌面通知 `Notifications`
  - 语义化标签 `article`、`footer`、`header`、`nav`、`section`
  - 增强表单控件 `calendar`、`date`、`time`、`email`、`url`、`search`
  - 地理位置 `Geolocation`
  - 多任务 `webworker`
  - 全双工通信协议 `websocket`
  - 历史管理 `history`
  - 跨域资源共享(CORS) `Access-Control-Allow-Origin`
  - 页面可见性改变事件 `visibilitychange`
  - 跨窗口通信 `PostMessage`
  - `Form Data` 对象
  - 绘画 `canvas`
- 移除的元素：
  - 纯表现的元素：`basefont`、`big`、`center`、`font`、 `s`、`strike`、`tt`、`u`
  - 对可用性产生负面影响的元素：`frame`、`frameset`、`noframes`
- 支持`HTML5`新标签：
  - `IE8/IE7/IE6`支持通过`document.createElement`方法产生的标签
  - 可以利用这一特性让这些浏览器支持`HTML5`新标签
  - 浏览器支持新标签后，还需要添加标签默认的样式
- 当然也可以直接使用成熟的框架、比如`html5shim`

**如何区分 HTML 和 HTML5**

- `DOCTYPE`声明、新增的结构元素、功能元素
- ![image-20211008201023296](https://gitee.com/wexia/my_pic_bed/raw/master/pics/20211008201024.png)

#### 「Doctype作用? 严格模式与混杂模式如何区分？它们有何意义?」

- 页面被加载的时，`link`会同时被加载，而`@imort`页面被加载的时，`link`会同时被加载，而`@import`引用的`CSS`会等到页面被加载完再加载 `import`只在`IE5`以上才能识别，而`link`是`XHTML`标签，无兼容问题 `link`方式的样式的权重 高于`@import`的权重
- `<!DOCTYPE>` 声明位于文档中的最前面，处于 `<html>` 标签之前。告知浏览器的解析器， 用什么文档类型 规范来解析这个文档
- 严格模式的排版和 `JS` 运作模式是 以该浏览器支持的最高标准运行
- 在混杂模式中，页面以宽松的向后兼容的方式显示。模拟老式浏览器的行为以防止站点无法工作。 `DOCTYPE`不存在或格式不正确会导致文档以混杂模式呈现
- `<!doctype html>` 的作用就是让浏览器进入标准模式，使用最新的 `HTML5` 标准来解析渲染页面；如果不写，浏览器就会进入混杂模式，我们需要避免此类情况发生。

####  「语义化的理解」

- 用正确的标签做正确的事情！
- `HTML`语义化就是让页面的**内容结构化**，便于对浏览器、搜索引擎解析；
- 在没有样式`CSS`情况下也以一种文档格式显示，并且是容易阅读的。
- 搜索引擎的爬虫依赖于标记来确定上下文和各个关键字的权重，利于 `SEO`。
- 使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解



## 32  事件循环机制event loop

> 首先，`js`是单线程的，主要的任务是处理用户的交互，而用户的交互无非就是响应`DOM`的增删改，使用事件队列的形式，一次事件循环只处理一个事件响应，使得脚本执行相对连续，所以有了事件队列，用来储存待执行的事件，那么事件队列的事件从哪里被`push`进来的呢。那就是另外一个线程叫事件触发线程做的事情了，他的作用主要是在定时触发器线程、异步`HTTP`请求线程满足特定条件下的回调函数`push`到事件队列中，等待`js`引擎空闲的时候去执行，当然js引擎执行过程中有优先级之分，首先js引擎在一次事件循环中，会先执行js线程的主任务，然后会去查找是否有微任务`microtask（promise）`，如果有那就优先执行微任务，如果没有，在去查找宏任务`macrotask（setTimeout、setInterval）`进行执行

- `JS` 在执行的过程中会产生执行环境，这些执行环境会被顺序的加入到执行栈中。如果遇到异步的代码，会被挂起并加入到 `Task`（有多种 `task`） 队列中。一旦执行栈为空，`Event` `Loop` 就会从 `Task` 队列中拿出需要执行的代码并放入执行栈中执行，所以本质上来说 `JS` 中的异步还是同步行为

![img](https://poetries1.gitee.io/img-repo/2020/09/101.png)



**所以正确的一次 Event loop 顺序是这样的**

- 执行同步代码，这属于宏任务
- 执行栈为空，查询是否有微任务需要执行
- 执行所有微任务
- 必要的话渲染 UI
- 然后开始下一轮 `Event loop`，执行宏任务中的异步代码

> 通过上述的 `Event loop` 顺序可知，如果宏任务中的异步代码有大量的计算并且需要操作 `DOM` 的话，为了更快的响应界面响应，我们可以把操作 `DOM` 放入微任务中

#### **「面试中的回答」**

- 首先js 是单线程运行的，在代码执行的时候，通过将不同函数的执行上下文压入执行栈中来保证代码的有序执行
- 在执行同步代码的时候，如果遇到了异步事件，js 引擎并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务
- 当同步事件执行完毕后，再将异步事件对应的回调加入到与当前执行栈中不同的另一个任务队列中等待执行
- 任务队列可以分为宏任务队列和微任务队列，当当前执行栈中的事件执行完毕后，js 引擎首先会判断微任务队列中是否有任务可以执行，如果有就将微任务队首的事件压入栈中执行
- 当微任务队列中的任务都执行完成后再去判断宏任务队列中的任务。



## 33  闭包

**闭包**

- 闭包就是能够读取其他函数内部变量的函数
- 闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是`在一个函数内创建另一个函数`，通过另一个函数访问这个函数的局部变量,利用闭包可以突破作用链域
- 闭包的特性：
  - 函数内再嵌套函数
  - 内部函数可以引用外层的参数和变量
  - 参数和变量不会被垃圾回收机制回收

**说说你对闭包的理解**

- 使用闭包主要是为了设计私有的方法和变量。闭包的优点是可以避免全局变量的污染，缺点是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。在js中，函数即闭包，只有函数才会产生作用域的概念
- 闭包 的最大用处有两个，一个是可以读取函数内部的变量，另一个就是让这些变量始终保持在内存中
- 闭包的另一个用处，是封装对象的私有属性和私有方法
- **好处**：能够实现封装和缓存等；
- **坏处**：就是消耗内存、不正当使用会造成内存溢出的问题

**使用闭包的注意点**

- 由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致`内存泄露`
- 解决方法是，在退出函数之前，将不使用的局部变量全部删除





## 34  原型/原型链

- **原型：**
  - `JavaScript`的所有对象中都包含了一个 `[__proto__]` 内部属性，这个属性所对应的就是该对象的原型
  - JavaScript的函数对象，除了原型 `[__proto__]` 之外，还预置了 `prototype` 属性
  - 当函数对象作为构造函数创建实例时，该 prototype 属性值将被作为实例对象的原型 `[__proto__]`。
- **原型链：**
  - 当一个对象调用的属性/方法自身不存在时，就会去自己 `[__proto__]` 关联的前辈 `prototype` 对象上去找
  - 如果没找到，就会去该 `prototype` 原型 `[__proto__]` 关联的前辈 `prototype` 去找。依次类推，直到找到属性/方法或 `undefined` 为止。从而形成了所谓的“原型链”

![img](https://poetries1.gitee.io/img-repo/2020/09/112.png)



## 35 http1.0、1.1、2.0及https的区别

### HTTP请求报文组成

请求报⽂有4部分组成:

- 请求⾏
- 请求头部
- 空⾏
- 请求体

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4fb5bb2cb1664850b52e32d57af74f2f~tplv-k3u1fbpfcp-watermark.awebp) **其中：** （1）请求⾏包括：请求⽅法字段、URL字段、HTTP协议版本字段。它们⽤空格分隔。例如，GET /index.html HTTP/1.1。 （2）请求头部:请求头部由关键字/值对组成，每⾏⼀对，关键字和值⽤英⽂冒号“:”分隔

- User-Agent：产⽣请求的浏览器类型。
- Accept：客户端可识别的内容类型列表。
- Host：请求的主机名，允许多个域名同处⼀个IP地址，即虚拟主机。

（3）请求体: post put等请求携带的数据 ![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eacc55d7152149e99730346f1edfc9ab~tplv-k3u1fbpfcp-watermark.awebp)

### HTTP响应报文组成

请求报⽂有4部分组成:

- 响应⾏
- 响应头
- 空⾏
- 响应体

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1b0183eb91ce451aa17bd515d047062d~tplv-k3u1fbpfcp-watermark.awebp)

- 响应⾏：由网络协议版本，状态码和状态码的原因短语组成，例如 HTTP/1.1 200 OK 。
- 响应头：响应部⾸组成
- 响应体：服务器响应的数据



HTTP1.1 是目前使用最为广泛的协议版本

> **HTTP1.0和HTTP1.1的一些区别**

HTTP1.0最早在网页中使用是在1996年，那个时候只是使用一些较为简单的网页上和网络请求上，而HTTP1.1则在1999年才开始广泛应用于现在的各大浏览器网络请求中，同时HTTP1.1也是当前使用最为广泛的HTTP协议。 主要区别主要体现在：

1. **缓存处理**，在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。
2. **带宽优化及网络连接的使用**，HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。
3. **错误通知的管理**，在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。
4. **Host头处理**，在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。
5. **长连接**，HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。



> **HTTP2.0和HTTP1.X相比的新特性**

- **新的二进制格式**（Binary Format），HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。
- **多路复用**（MultiPlexing），即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。
- **header压缩**，如上文中所言，对前面提到过HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。
- **服务端推送**（server push），同SPDY一样，HTTP2.0也具有server push功能。



![image-20211005140617856](https://gitee.com/wexia/my_pic_bed/raw/master/pics/20211006112959.png)



> **HTTPS与HTTP的一些区别**

- ![img](https://pic2.zhimg.com/80/v2-41d21dc187d46adca28f041f46741791_720w.jpg)
- `SSL/TLS ==> secure socket layer / transport layer security`
- HTTPS协议需要到CA申请证书，一般免费证书很少，需要交费。
- HTTP协议运行在TCP之上，所有传输的内容都是明文，HTTPS运行在SSL/TLS之上，SSL/TLS运行在TCP之上，所有传输的内容都经过加密的。
- HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是`80`，后者是`443`。
- HTTPS可以有效的防止运营商劫持，解决了防劫持的一个大问题。



### **「ssl 加密方式及过程」**

SSL英文全称Secure Socket Layer，安全套接层，是一种为网络通信提供安全以及数据完整性的安全协议，它在传输层对网络进行加密。它主要是分为两层：

- SSL记录协议：为高层协议提供安全封装、压缩、加密等基本功能
- SSL握手协议：用于在数据传输开始前进行通信双方的身份验证、加密算法的协商、交换密钥
  OpenSSL是SSL的开源实现，它是作为密码学的安全开发包，提供相当强大全面的功能，囊括了主要的密码算法、常用的密钥和证书封装管理功能以及SSL协议，并提供了丰富的应用程序供测试或其它目的使用。它一共提供了8中对称加密算法和4中非对称加密算法。

**`对称加密与非对称加密`**

​		对称加密实质加密和解密都使用同一个密钥，对称加密只有一个密钥，作为私钥。常用的对称加密算法有**DES和AES**等

​		非对称加密是指加密和解密用的是不同密钥，并且是成对存在的。一把称为公钥，能够放心的交给别人，一把是私钥，只能自己保存。其中用公钥加密的信息只能用私钥解密，用私钥加密的信息只能用公钥解密。

![在这里插入图片描述](https://img-blog.csdn.net/20180921005417597?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMTQ5NjEy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

​		常用的非对称加密算法有：**RSA，DH，DSA三种**

但是仍然存在不安全的因素，即`无法判断公钥的所有者`，所以就有了`数字证书`的概念

简单来说数字证书就是一段信息，他内部的信息包括：

- 签发证书的机构
- 加密算法
- Hash算法
- 公钥
- 证书到期时间等

为了防止证书颁发的过程中被人修改，又出现了一个数字签名的概念，所谓数字签名就是把证书内容做了一个hash操作生成固定长度的数据发送给服务端B，服务端就能通过自己hash一遍对比发过来的hash来判断内容是否被修改。然而这还是可能被人截取修改内容重新生成hash再发给服务端B，这怎么办呢？出于这个考虑，CA机构在颁发时又会用一个私钥将这个hash加密，这样就防止了证书被修改了。
![在这里插入图片描述](https://img-blog.csdn.net/20180921160256976?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMTQ5NjEy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)



`ssl加密的具体过程`，其中具体的过程如下：

- 第一步 客户端A给出 支持的SSL版本+一个随机数+自己支持的加密方式
- 第二步 服务端B接收到这些信息后确认加密方式+自己的安全证书+一个随机数发给A
- 第三步 客户端A确认数字证书有效性（验证方法上面已经说明），然后生成一个随机数，并将这个随机数用B的数字证书公钥加密后发送给A。
- 第四步 服务端B使用自己的私钥解密这个随机数
- 第五步 A和B通过第二步确定的加密方法将前三个随机数生成一个对话密钥 用来接下来的通信（个人感觉不需要三个随机数，只用最后一个就够了，这样做可能是为了更安全）

![在这里插入图片描述](https://img-blog.csdn.net/20180921165828285?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMTQ5NjEy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

## 36  JavaScript垃圾回收方法

### 「标记清除(mark and sweep)」

> - 这是JavaScript最常见的垃圾回收方式，当变量进入执行环境的时候，比如函数中声明一个变量，垃圾回收器将其标记为“进入环境”，当变量离开环境的时候（函数执行结束）将其标记为“离开环境”
> - 垃圾回收器会在运行的时候给存储在内存中的所有变量加上标记，然后去掉环境中的变量以及被环境中变量所引用的变量（闭包），在这些完成之后仍存在标记的就是要删除的变量了

### **「引用计数(reference counting)」**

> 在低版本IE中经常会出现内存泄露，很多时候就是因为其采用`引用计数方式`进行垃圾回收。引用计数的策略是跟踪记录每个值被使用的次数，当声明了一个 变量并将一个引用类型赋值给该变量的时候这个值的引用次数就加1，如果该变量的值变成了另外一个，则这个值得引用次数减1，当这个值的引用次数变为0的时 候，说明没有变量在使用，这个值没法被访问了，因此可以将其占用的空间回收，这样垃圾回收器会在运行的时候清理掉引用次数为0的值占用的空间



## 37  虚拟DOM的概念及比较

首次加载 由于多了一层 虚拟dom 的计算，所以运行效率会比innerhtml 慢一些

### 「虚拟DOM原理」

浏览器内核拿到html文件后，大致分为一下5个步骤：

- 解析html元素，构建dom 树

- 解析CSS，生成页面css规则树（Style Rules）

- 将dom树 和 css规则树关联起来，生成render树

- 布局（layout/ reflow），浏览器会为Render树上的每个节点确定在屏幕上的尺寸、位置

- 绘制Render树，绘制页面像素信息到屏幕上，这个过程叫paint

​        当你用原生js 或jquery等库去操作DOM时，浏览器会从`构建DOM树开始将整个流程执行一遍`，所以频繁操作DOM会引起不需要的计算，导致页面卡顿，影响用户体验。而Virtual DOM能很好的解决这个问题。它用javascript对象表示`virtual node(VNode)`，根据`VNode 计算出真实DOM需要做的最小变动`，然后再操作`真实DOM节点`，提高渲染效率。-------->   `diff 算法`

**`虚拟DOM流程：`**

1. 用JavaScript模拟DOM树，并渲染这个DOM树
2. 比较新老DOM树，得到比较的差异对象
3. 把差异对象应用到渲染的DOM树。

![image-20210914152908543](https://gitee.com/wexia/my_pic_bed/raw/master/pics/20210915114702.png)





### 「虚拟DOM树跟真实DOM的区别」

- 虚拟DOM不会进行排版与重绘操作


- 虚拟DOM进行频繁修改，然后`一次性比较并修改真实DOM中需要改的部分`（注意！），最后并在真实DOM中进行排版与重绘，减少过多DOM节点排版与重绘损耗


- 真实DOM频繁排版与重绘的效率是相当低的


- 虚拟DOM有效降低`大面积（真实DOM节点）的重绘与排版`，因为最终与真实DOM比较差异，可以只渲染局部（同2）
  

**总之，一切为了减弱频繁的大面积重绘引发的性能问题，不同框架不一定需要虚拟DOM，关键看框架是否频繁会引发大面积的DOM操作**



## 38  Element-UI用到的组件

> **`icon、button、Cascader级联选择器、form表单、tag标签、progress进度条、pagination分页、message消息提示、breadcrumb面包屑导航、dialog对话框，card卡片`**

### 「slot、slot-scope与v-slot替换 」

​	slot、slot-scope已经被弃用，所以推荐使用v-slot进行替换

### 「加载服务器图片预览问题」

查看 API接口返回的数据时可以看到：

![image-20210623112247221](https://gitee.com/wexia/my_pic_bed/raw/master/pics/20210623112247.png)

所以在处理图片预览效果的时候，应该是将 url 的地址 赋值给 previewPath，然后加载一个对话框进行img 展示

```
// 处理图片预览效果
handlePreview(file) {
  this.previewPath = file.response.data.url
  console.log(this.previewPath)
  this.previewVisible = true
},
```

```
<!--图片预览模块对话框-->
<el-dialog title="图片预览" :visible.sync="previewVisible" width="50%">
  <img :src="previewPath" alt="" class="previewImg" />
  <span slot="footer" class="dialog-footer"> </span>
</el-dialog>
```

但是在实操过程中，发现http://127.0.0.1:8888/tmp_uploads/39f29fc416152e0d0be325e263bcb747.png 无法打开，这里需要明确 的一点是，` 127.0.0.1` 其实等同于` locahost:`，所以其实他这里是在自己的电脑上布了后端接口，所以相当于他是在访问自己电脑上的一个8888端口的后端数据，我们因为没有布后台，所以肯定是访问不了的，所以这里我们考虑直接 用 `file.url` 来访问。

```
// 处理图片预览效果
handlePreview(file) {
  console.log(file)
  this.previewPath = file.url
  console.log(this.previewPath)
  this.previewVisible = true
},
```

但是我们把这个网址前面的 `http://127.0.0.1 `换成 http://www.ysqorz.top:8888/tmp_uploads/39f29fc416152e0d0be325e263bcb747.png  是可以发现 图片其实 存到远程的服务器数据库里了。

**补充知识点**：`url: "blob:http://localhost:8080/d3234d52-cea0-4a58-bef6-f4c7b0158a1d"`

##### blob (binary large object):二进制大对象

​		服务器一般存储图片的方式，是上传图片到服务器，服务器`返回一个图片在服务器中的 url 地址`，前端取用图片的时直接将`存储路径赋值给src属性`即可轻松显示，

​		但是 blob 是把图片转换成 blob，直接`存储到数据库的 image 类型字段中`(不过这种方式负担很大 不建议使用)，因为每次 `存读取` 都得进行`二进制流`转换。

​		Blob URL只能由浏览器在内部生成。这些URL只能在浏览器的单个实例中和同一个会话中（即页面/文档的生命周期）在本地使用。Blob URL / Object URL是一种伪协议，允许Blob和File对象用作图像，下载二进制数据链接等的URL源。可以通过文件读取器API创建Blob并获取File对象，尽管BLOB只是意味着Binary Large对象并以字节数组的形式存储。客户端可以请求数据以ArrayBuffer或Blob的形式发送。服务器应该将数据作为纯二进制数据发送。数据库通常也使用Blob来描述二进制对象，实际上我们基本上是在谈论字节数组。需要将二进制数据封装为BLOB对象，然后使用它`URL.createObjectURL()`为其生成本地URL

​		不过 element-ui 好像都集成好了，拿来直接访问调用就行 ，还是有一点点没搞懂，到时候再看一下

### 「vuecli3.0+ element-ui 图标不显示」

​	icon不显示发现是路径不对，请求路径是/dist/static/css/static/fonts/732389de.element-icons.ttf，多了css/static。正确路径应该是/dist/static/fonts/732389de.element-icons.ttf

​		在 vue-cli3.0 中不能进行 build 的配置，我们只能通过 vue.config.js 中的 publicPath 进行配置，配置里面加入publicPath: ‘./’，





## 39  Object.defineProperty()和Proxy区别

> **总结：**

- `Proxy`使用上比`Object.defineProperty`方便的多。

- `Proxy`代理整个对象，`Object.defineProperty`只代理对象上的某个属性。

- vue中，`Proxy`在调用时递归，`Object.defineProperty`在一开始就全部递归，`Proxy`性能优于`Object.defineProperty`。

- 对象上**定义新属性**时，Proxy可以监听到，`Object.defineProperty`监听不到。

- 数组**新增删除修改**时，Proxy可以监听到，`Object.defineProperty`监听不到。

- Proxy不兼容IE，`Object.defineProperty`不兼容IE8及以下。
  

## 40  css3新特性

- 新增选择器 `p:nth-child(n){color: rgba(255, 0, 0, 0.75)}`
- 弹性盒模型 `display: flex;`
- 多列布局 `column-count: 5;`
- 媒体查询 `@media (max-width: 480px) {.box: {column-count: 1;}}`
- 个性化字体 `@font-face{font-family: BorderWeb; src:url(BORDERW0.eot);}`
- 颜色透明度 `color: rgba(255, 0, 0, 0.75);`
- 圆角 `border-radius: 5px;`
- 渐变 `background:linear-gradient(red, green, blue);`
- 阴影 `box-shadow:3px 3px 3px rgba(0, 64, 128, 0.3);`
- 倒影 `box-reflect: below 2px;`
- 文字装饰 `text-stroke-color: red;`
- 文字溢出 `text-overflow:ellipsis;`
- 背景效果 `background-size: 100px 100px;`
- 边框效果 `border-image:url(bt_blue.png) 0 10;`
- 转换
  - 旋转 `transform: rotate(20deg);`
  - 倾斜 `transform: skew(150deg, -10deg);`
  - 位移 `transform: translate(20px, 20px);`
  - 缩放 `transform: scale(.5);`
- 平滑过渡 `transition: all .3s ease-in .1s;`
- 动画 `@keyframes anim-1 {50% {border-radius: 50%;}} animation: anim-1 1s;`

**CSS3新增伪类有那些？**

- `p:first-of-type` 选择属于其父元素的首个`<p>`元素的每个`<p>` 元素。
- `p:last-of-type` 选择属于其父元素的最后 `<p>` 元素的每个`<p>` 元素。
- `p:only-of-type` 选择属于其父元素唯一的 `<p>`元素的每个 `<p>` 元素。
- `p:only-child` 选择属于其父元素的唯一子元素的每个 `<p>` 元素。
- `p:nth-child(2)` 选择属于其父元素的第二个子元素的每个 `<p>` 元素。
- `:after` 在元素之前添加内容,也可以用来做清除浮动。
- `:before` 在元素之后添加内容。
- `:enabled` 已启用的表单元素。
- `:disabled` 已禁用的表单元素。
- `:checked` 单选框或复选框被选中。

![image-20211008201218667](https://gitee.com/wexia/my_pic_bed/raw/master/pics/20211008201219.png)

**transition和animation的区别**

> `Animation`和`transition`大部分属性是相同的，他们都是随时间改变元素的属性值，他们的主要区别是`transition`需要触发一个事件才能改变属性，而`animation`不需要触发任何事件的情况下才会随时间改变属性值，并且`transition`为2帧，从`from .... to`，而`animation`可以一帧一帧的



## 41  使用Nginx部署网站

https://www.cnblogs.com/xiaohuochai/p/9093819.html

**主机配置**（端口配置、主机名配置）

**路径配置**（location、根目录设置、别名设置、首页设置、重定向页面设置、try_files设置）

**反向代理**（负载均衡设置、反向代理设置）

**HTTPS设置**、**gzip设置**、**缓存配置**

**CSP配置**：跨域脚本攻击 XSS 是最常见、危害最大的网页安全漏洞。为了防止它们，要采取很多编程措施，非常麻烦。很多人提出，能不能根本上解决问题，浏览器自动禁止外部注入恶意脚本？这就是"网页安全政策"（Content Security Policy，缩写 CSP）的来历

　　CSP 的实质就是白名单制度，开发者明确告诉客户端，哪些外部资源可以加载和执行，等同于提供白名单。它的实现和执行全部由浏览器完成，开发者只需提供配置

**隐藏信息：**在请求响应头中，有这么一行 `server: nginx`，说明用的是 Nginx 服务器，但并没有具体的版本号。由于某些 Nginx 漏洞只存在于特定的版本，隐藏版本号可以提高安全性。这只需要在配置里加上这个就可以了：

**配置流程**、**后端项目**、**后台项目**、**前台项目**、**SSR项目**



###  正向代理和反向代理的区别

- **正向代理：**

客户端想获得一个服务器的数据，但是因为种种原因无法直接获取。于是客户端设置了一个代理服务器，并且指定目标服务器，之后代理服务器向目标服务器转交请求并将获得的内容发送给客户端。这样本质上起到了对真实服务器隐藏真实客户端的目的。实现正向代理需要修改客户端，比如修改浏览器配置。

- **反向代理：**

服务器为了能够将工作负载分不到多个服务器来提高网站性能 (负载均衡)等目的，当其受到请求后，会首先根据转发规则来确定请求应该被转发到哪个服务器上，然后将请求转发到对应的真实服务器上。这样本质上起到了对客户端隐藏真实服务器的作用。 一般使用反向代理后，需要通过修改 DNS 让域名解析到代理服务器 IP，这时浏览器无法察觉到真正服务器的存在，当然也就不需要修改配置了。

两者区别如图示： ![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/97e92248f2654185808f80b65f3ca0f6~tplv-k3u1fbpfcp-watermark.awebp) 

正向代理和反向代理的结构是一样的，都是 client-proxy-server 的结构，它们主要的区别就在于中间这个 proxy 是哪一方设置的。在正向代理中，proxy 是 client 设置的，用来隐藏 client；而在反向代理中，proxy 是 server 设置的，用来隐藏 server。





## 42  前端监控与前端埋点方案

https://blog.csdn.net/sinat_36521655/article/details/114650138

​		用户行为数据可以通过**前端数据监控**的方式获得，除此之外，前端还需要实现**性能监控和异常监控。**性能监控包括首屏加载时间、白屏时间、http请求时间和http响应时间。异常监控包括前端脚本执行报错等。

**前端监控的目的是：**

> **获取用户行为以及跟踪产品在用户端的使用情况，并以监控数据为基础指明产品优化的方向**。

前端监控可以分为三类：数据监控、性能监控和异常监控。

### 「前端监控的种类」

#### (1) 数据监控

数据监控，顾名思义就是监听用户的行为。常见的数据监控包括：

- PV/UV:PV(page view)，即页面浏览量或点击量。UV:指访问某个站点或点击某条新闻的不同IP地址的人数
- 用户在每一个页面的停留时间
- 用户通过什么入口来访问该网页
- 用户在相应的页面中触发的行为

统计这些数据是有意义的，比如我们知道了用户来源的渠道，可以促进产品的推广，知道用户在每一个页面停留的时间，可以针对停留较长的页面，增加广告推送等等。

#### (2) 性能监控

性能监控指的是监听前端的性能，主要包括监听网页或者说产品在用户端的体验。常见的性能监控数据包括：

- 不同用户，不同机型和不同系统下的首屏加载时间
- 白屏时间
- http等请求的响应时间
- 静态资源整体下载时间
- 页面渲染时间
- 页面交互动画完成时间

这些性能监控的结果，可以展示前端性能的好坏，根据性能监测的结果可以进一步的去优化前端性能，比如兼容低版本浏览器的动画效果，加快首屏加载等等。

#### (3) 异常监控

此外，产品的前端代码在执行过程中也会发生异常，因此需要引入异常监控。及时的上报异常情况，可以避免线上故障的发上。虽然大部分异常可以通过try catch的方式捕获，但是比如内存泄漏以及其他偶现的异常难以捕获。常见的需要监控的异常包括：

- Javascript的异常监控
- 样式丢失的异常监控





### 「前端埋点方案」

> **实现前端监控的步骤**为：**前端埋点和上报、数据处理和数据分析。**首要的步骤就是前端埋点和上报，也就是数据的收集阶段。数据收集的丰富性和准确性会影响对产品线上效果的判别结果。

​		埋点，它的学名是**事件追踪（Event Tracking）**，主要是针对特定用户行为或业务过程进行捕获、处理和发送的相关技术及实施过程。埋点是数据领域的一个专业术语，也是互联网领域的一个俗称。

​		埋点是**产品数据分析的基础**，一般用于推荐系统的反馈、用户行为的监控和分析、新功能或者运营活动效果的统计分析等。

​		埋点包含两个重要概念：**事件（event），属性（param）**

- 事件（event）：应用中发生了什么，例如用户操作、系统事件或系统错误。以你拍一产品为例，包含以下事件：enter_page（进入页面）、leave_page（离开页面）	
- 属性（param）：为了描述用户群细分而定义的属性，例如语言偏好或地理位置。以“进入课后练习”事件为例，它包含如下事件属性：enter_from（从哪个页面来），class_id（课程id）等。	
- 属性值（value）：属性的维度，即行为触发时的具体维度。例如：enter_from：home（主页）、system（系统）等。



#### **常见埋点事件**

| 事件     | 上报时机                   | 描述                                   |
| -------- | -------------------------- | -------------------------------------- |
| 页面停留 | 当前页面切换或者页面卸载时 | 记录前一页浏览时间                     |
| pv       | 进入页面时                 | 页面访问次数，uv只需要根据deviceId过滤 |
| 交互事件 | 用户交互事件触发时         | 比如点击、长按等                       |
| 逻辑事件 | 符合逻辑条件时             | 比如登陆、跳转页面等                   |

#### 常见埋点属性

| 属性       | 描述                                                         |
| ---------- | ------------------------------------------------------------ |
| uid        | 用户id，若用户未登陆，则返回特定标识id                       |
| url        | 当前事件触发页面的url                                        |
| eventTime  | 触发埋点的时间戳                                             |
| localTime  | 触发埋点时的用户本地时间，使用标准YYYY-MM-DD HH:mm:ss格式表示，方便后期直接使用字符串查询 |
| deviceType | 当前用户使用的设备类型，比如apple、三星、chrome等            |
| deviceId   | 当前用户使用的设备id                                         |
| osType     | 当前用户使用的系统类型，比如windows、macos、ios、android等   |
| osVersion  | 当前用户使用的系统版本                                       |
| appVersion | 当前应用版本                                                 |
| appId      | 当前应用id                                                   |
| extra      | 自定义数据，一般是序列化的字符串，且数据结构应保持稳定       |



​		目前常见的前端埋点方法分为三种：代码埋点、可视化埋点和无痕埋点。

#### (1) 代码埋点

​		代码埋点，就是以嵌入代码的形式进行埋点，比如需要监控用户的点击事件，会选择在用户点击时，插入一段代码，保存这个监听行为或者直接将监听行为以某一种数据格式直接传递给server端。此外比如需要统计产品的PV和UV的时候，需要在网页的初始化时，发送用户的访问信息等。

代码埋点的优点：

- 可以在任意时刻，精确的发送或保存所需要的数据信息。

缺点：

- 工作量较大，每一个组件的埋点都需要添加相应的代码

#### (2) 可视化埋点

​		通过可视化交互的手段，代替代码埋点。将业务代码和埋点代码分离，提供一个可视化交互的页面，输入为业务代码，通过这个可视化系统，可以在业务代码中自定义的增加埋点事件等等，最后输出的代码耦合了业务代码和埋点代码。

​		可视化埋点听起来比较高大上，实际上跟代码埋点还是区别不大。也就是用一个系统来实现手动插入代码埋点的过程。

缺点：

- 可视化埋点可以埋点的控件有限，不能手动定制。

#### (3) 无埋点

​		无埋点并不是说不需要埋点，而是全部埋点，前端的任意一个事件都被绑定一个标识，所有的事件都别记录下来。通过定期上传记录文件，配合文件解析，解析出来我们想要的数据，并生成可视化报告供专业人员分析因此实现“无埋点”统计。

​	从语言层面实现无埋点也很简单，比如从页面的js代码中，找出dom上被绑定的事件，然后进行全埋点。

无埋点的优点：

- 由于采集的是全量数据，所以产品迭代过程中是不需要关注埋点逻辑的，也不会出现漏埋、误埋等现象

缺点：

- 无埋点采集全量数据，给数据传输和服务器增加压力
- 无法灵活的定制各个事件所需要上传的数据



### 「性能数据采集方案」

目前性能指标数据大部分来源于 [window.performance](https://developer.mozilla.org/zh-CN/docs/Web/API/Performance) API。

#### Performance.timing

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210311002120285.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzM2NTIxNjU1,size_16,color_FFFFFF,t_70)

#### 常见性能指标

| 指标名 | 描述                                             |
| :----: | ------------------------------------------------ |
|   FP   | 页面首次绘制时间                                 |
|  FCP   | 页面首次有内容绘制的时间                         |
|  FMP   | 页面首次有效绘制时间，FMP >= FCP                 |
|  TTI   | 页面完全可交互时间                               |
|  FID   | 页面加载阶段，用户首次交互操作的延时时间         |
| MPFID  | 页面加载阶段，用户交互操作可能遇到的最大延时时间 |
|  LOAD  | 页面完全加载的时间（load 事件发生的时间）        |



## 43  css的两种盒子模型

设一个类名为box的盒子固定宽高 width:100px hight:100px
	边框为1px 实线 黑色 border : 1px solid black
	内填充 padding：10px
	外边距 margin：50px

### 1.W3C盒模型（正常盒模型）

**box-sizing: content-box**
此刻类名为box盒子
		宽 width=122px
		高 hight=122px
此刻盒子的宽 width=content（100px）+左右padding（2 x 10px = 20px）+ 左右border（2 x 1px = 2px）
盒子的高同理
padding和border加在了盒子外（可以撑大盒子）
		具体盒模型的则还需要加上margin的值

### 2.IE盒模型（怪异盒模型）

**box-sizing:border-box**
此刻类名为box盒子
		宽 width=100px
		高 hight=100px
此刻盒子的宽 width= content(78px) + 左右padding（20px）+ 左右border（2px）
		盒子的高同理
“可理解成固定了宽高” padding和border是加在了盒子里面
		具体盒模型的则还需要加上margin的值





## 44 flex布局的一些属性

#### 「flex:1含义」

flex属性是**flex-grow**, **flex-shrink** 和 **flex-basis**的简写，默认值为**0 1 auto**。后两个属性可选

**`Flex-grow`**

​		flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大

​		如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。

**`Flex-shrink`**

​		flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。

​		如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。

**`Flex-basis`**
		flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。
		它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。

## 45  NodeJS的特点及适用场景

#### 「NodeJS的特点」

1. 它是一个Javascript运行环境
2. 依赖于Chrome V8引擎进行代码解释
3. 事件驱动
4. 非阻塞I/O
5. 轻量、可伸缩，适于实时数据交互应用
6. 单进程，单线程

#### 「NodeJS解决的问题」

##### 	1.并发连接

- 异步、事件驱动模型
   异步机制、事件驱动整个过程没有阻塞新用户的连接，也不需要维护已有用户的连接。
   基于这样的机制，理论上陆续有用户请求连接，NodeJS都可以进行响应，因此NodeJS能支持比Java、PHP程序更高的并发量.虽然维护事件队列也需要成本，再由于NodeJS是单线程，事件队列越长，得到响应的时间就越长，并发量上去还是会力不从心。
    	**NodeJS解决并发连接问题**：更改连接到服务器的方式，每个连接发射（emit）一个在NodeJS引擎进程中运行的事件（Event），放进事件队列当中，而不是为每个连接生成一个新的OS线程（并为其分配一些配套内存）。

  ##### 2. I/O阻塞

  Java、PHP也有办法实现并行请求（子线程），但NodeJS通过回调函数（Callback）和异步机制会做得很自然。

#### 「NodeJS搭建websocket服务器」

> 安装模块，搭建服务端 js文件，搭建客户端js文件、启动 js 

```
//websocket.js
// 搭建websocket服务器
const ws = require("nodejs-websocket");
var _server = ws.createServer(conn => {
	// 接收客户端返回的数据
	conn.on("text", function(str) {
		console.log(str, "接收客户端传过来的值");
		
	});

    //客户端关闭连接
	conn.on("close", function() {
		
	});

	conn.on("error", function(err) {
		//error
		console.log(err, "连接报错");
	});
});
// 定义端口为2002【端口自己随意定义】
const port = 2002;
_server.listen(port, function() {
	
	console.log("连接成功")
	console.log('listening on websocketServer');
})
```

**`客户端`**

```
//建立连接
var ws = new WebSocket("ws://localhost:2002");

ws.onopen = function(evt) {
  console.log("Connection open ...");
  let sendobj={
    id:"0001",
    name:"发送的值"
  }
  console.log(sendobj);
  ws.send(sendobj);
};

ws.onmessage = function(e) {
  console.log(typeof e.data);
  console.log(e);
  ws.close()
};


ws.onclose = function(evt) {
  console.log("Connection closed.");
};

ws.onerror = function(err){
  console.log(err);
}

```

**`启动js`**

```
node websocket.js
```





​		MongoDB 在做硅谷外卖app 的时候，为了快速搭建一个 后端服务器，mongodb非关系型数据库

​		MongoDB提出的是文档、集合的概念，使用BSON（类JSON）作为其数据模型结构，其结构是面向对象的而不是二维表，存储一个用户在MongoDB中是这样子的。所以不需要事先设置数据结构，字段也可以随时加，做api请求更加方便，所以前期快速开发用这个。



## 46  position属性中sticky和fixed的区别

sticky可以使用参数，是位置跟relative使用参数的效果是一致的，都是相对于static的变化；sticky具有“滚动机制”。sticky定位可以被认为是relative和fixed的混合。粘性定位的元素被视为相对定位，直到它超过指定的阈值，此时它被视为固定的，直到它到达其父母的边界。

fixed相对于视口定位，不管视口如何滚动，它的位置始终不变，而sticky则是在目标区域内随着页面的滚动而滚动，超出这个区域后就跟fixed一样不管视口如何滚动位置始终不变。



## 47  HTTP请求方式

​	HTTP/1.1协议中共定义了八种方法（有时也叫“动作”），来表明Request-URL指定的资源不同的操作方式

​	HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。

​	HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法

| 序号 | 方法    | 描述                                                         |
| ---- | ------- | ------------------------------------------------------------ |
| 1    | GET     | 发送请求来获得服务器上的资源，请求体中不会包含请求数据，请求数据放在协议头中。另外get支持快取、缓存、可保留书签等。幂等 |
| 2    | POST    | 和get一样很常见，向服务器提交资源让服务器处理，比如提交表单、上传文件等，可能导致建立新的资源或者对原有资源的修改。提交的资源放在请求体中。不支持快取。非幂等 |
| 3    | HEAD    | 本质和get一样，但是响应中没有呈现数据，而是http的头信息，主要用来检查资源或超链接的有效性或是否可以可达、检查网页是否被串改或更新，获取头信息等，特别适用在有限的速度和带宽下。 |
| 4    | PUT     | 和post类似，html表单不支持，发送资源与服务器，并存储在服务器指定位置，要求客户端事先知道该位置；比如post是在一个集合上（/province），而put是具体某一个资源上（/province/123）。所以put是安全的，无论请求多少次，都是在123上更改，而post可能请求几次创建了几次资源。幂等 |
| 5    | DELETE  | 请求服务器删除某资源。和put都具有破坏性，可能被防火墙拦截。如果是https协议，则无需担心。幂等 |
| 6    | CONNECT | HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。就是把服务器作为跳板，去访问其他网页然后把数据返回回来，连接成功后，就可以正常的get、post了。 |
| 7    | OPTIONS | 获取http服务器支持的http请求方法，允许客户端查看服务器的性能，比如ajax跨域时的预检等。 |
| 8    | TRACE   | 回显服务器收到的请求，主要用于测试或诊断。一般禁用，防止被恶意攻击或盗取信息。 |

![img](https://images2018.cnblogs.com/blog/1418466/201808/1418466-20180812191152326-1393237647.png)

![image-20211116093930495](https://gitee.com/wexia/my_pic_bed/raw/master/pics/20211116093940.png)





### 「简单请求与非简单请求」

​		我们在日常的开发中，经常会遇到跨域资源共享，或者进行跨域接口访问的情况。跨域资源共享（ [CORS](https://link.segmentfault.com/?url=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FGlossary%2FCORS)）机制允许 Web 应用服务器进行跨域访问控制。

> 跨域资源共享标准新增了一组 HTTP 首部字段，允许服务器声明哪些源站通过浏览器有权限访问哪些资源。另外，规范要求，对那些可能对服务器数据产生副作用的 HTTP 请求方法（特别是[`GET`](https://link.segmentfault.com/?url=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FHTTP%2FMethods%2FGET)以外的 HTTP 请求，或者搭配某些 MIME 类型的[`POST`](https://link.segmentfault.com/?url=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FHTTP%2FMethods%2FPOST)请求），浏览器必须首先使用[`OPTIONS`](https://link.segmentfault.com/?url=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FHTTP%2FMethods%2FOPTIONS)方法发起一个预检请求（preflight request），从而获知服务端是否允许该跨域请求。服务器确认允许之后，才发起实际的 HTTP 请求。在预检请求的返回中，服务器端也可以通知客户端，是否需要携带身份凭证（包括[Cookies](https://link.segmentfault.com/?url=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FHTTP%2FCookies)和 HTTP 认证相关数据）。

在涉及到CORS的请求中，我们会把请求分为简单请求和复杂请求。

**`简单请求`**

满足以下条件的请求即为简单请求：

- **1）请求方法是以下三种方法之一：**

  - HEAD
  - GET
  - POST

  **2）HTTP的头信息不超出以下几种字段：**

  - Accept
  - Accept-Language
  - Content-Language
  - Last-Event-ID
  - Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain

  若不满足以上条件，就属于非简单请求了。

- 请求中的任意XMLHttpRequestUpload 对象均没有注册任何事件监听器 `(未验证)`
  - XMLHttpRequestUpload 对象可以使用 XMLHttpRequest.upload 属性访问
  
- 请求中没有使用 ReadableStream 对象 `(未验证)`

**`复杂请求`**

非简单请求即为复杂请求。复杂请求我们也可以称之为在实际进行请求之前，需要发起预检请求的请求。



#### `简单请求`与`复杂请求`的跨域设置

针对简单请求，在进行CORS设置的时候，我们只需要设置

```ada
Access-Control-Allow-Origin:*
// 如果只是针对某一个请求源进行设置的话，可以设置为具体的值
Access-Control-Allow-Origin: 'http://www.yourwebsite.com'
```

针对复杂请求，我们需要设置不同的响应头。因为在预检请求的时候会携带相应的请求头信息

```oxygene
Access-Control-Request-Method: POST
Access-Control-Request-Headers: X-CUSTOMER-HEADER, Content-Type
```

相应的响应头信息为：

```fortran
Access-Control-Allow-Origin: http://foo.example
Access-Control-Allow-Methods: POST, GET, OPTIONS
Access-Control-Allow-Headers: X-PINGOTHER, Content-Type
// 设置max age，浏览器端会进行缓存。没有过期之前真对同一个请求只会发送一次预检请求
Access-Control-Max-Age: 86400
```

如果发送的预检请求被进行了重定向，那大多数的浏览器都不支持对预检请求的重定向。我们可以通过先发送一个简单请求的方式，获取到重定向的url [XHR.responseURL](https://link.segmentfault.com/?url=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FAPI%2FXMLHttpRequest%2FresponseURL)，然后再去请求这个url。

#### 附带身份凭证的请求

一般而言，对于跨域 [`XMLHttpRequest`](https://link.segmentfault.com/?url=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FXMLHttpRequest)或 [Fetch](https://link.segmentfault.com/?url=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FAPI%2FFetch_API) 请求，浏览器**不会**发送身份凭证信息。如果要发送凭证信息，需要设置 [XMLHttpRequest](https://link.segmentfault.com/?url=https%3A%2F%2Fdeveloper.mozilla.org%2Fen%2FDOM%2FXMLHttpRequest) 的某个特殊标志位。
如果在发送请求的时候，给xhr 设置了withCredentials为true，从而向服务器发送 Cookies，如果服务端需要想客户端也发送cookie的情况，需要服务器端也返回`Access-Control-Allow-Credentials: true`响应头信息。

对于附带身份凭证的请求，服务器不得设置 `Access-Control-Allow-Origin`的值为“`*`”。

这是因为请求的首部中携带了`Cookie`信息，如果 `Access-Control-Allow-Origin`的值为“`*`”，请求将会失败。而将 `Access-Control-Allow-Origin`的值设置为 `http://foo.example`（请求源），则请求将成功执行。

![image-20211005094748821](https://gitee.com/wexia/my_pic_bed/raw/master/pics/20211006113037.png)



## 48  CSS单位px，rem，em，vw，vh的区别

**px**:  px就是pixel像素的缩写，相对长度单位，网页设计常用的基本单位。像素px是相对于显示器屏幕分辨率而言的

**em**:  em是相对长度单位。相对于当前对象内文本的字体尺寸（参考物是父元素的font-size）

如当前父元素的字体尺寸未设置，则相对于浏览器的默认字体尺寸

特点：

　　1. em的值并不是固定的；

　　2. em会继承父级元素的字体大小

**rem**:  rem是CSS3新增的一个相对单位，rem是相对于HTML根元素的字体大小（font-size）来计算的长度单位，如果你没有设置html的字体大小，就会以浏览器默认字体大小，一般是16px

优点是，只需要设置根目录的大小就可以把整个页面的成比例的调好

em与rem的区别：

　　rem是相对于根元素（html）的字体大小，而em是相对于其父元素的字体大小

两者使用规则：

- 如果这个属性根据它的font-size进行测量，则使用em``
- 其他的一切事物属性均使用rem

**vw、vh**

vw、vh、vmax、vmin这四个单位都是基于视口

vw是相对视口（viewport）的宽度而定的，长度等于视口宽度的`1/100`

假如浏览器的宽度为200px，那么1vw就等于2px（200px/100）

vh是相对视口（viewport）的高度而定的，长度等于视口高度的`1/100`

假如浏览器的高度为500px，那么1vh就等于5px（500px/100）

vmin和`vmax`是相对于视口的高度和宽度两者之间的`最小值`或`最大值`

**vm**

css3新单位，相对于视口的宽度或高度中较小的那个

其中最小的那个被均分为100单位的vm

比如：浏览器高度900px，宽度1200px，取最小的浏览器高度，1 vm = 900px/100 = 9 px

缺点：兼容性差



## 49  模块化 AMD CMD COMMONJS

https://www.cnblogs.com/echoyya/p/14577243.html

> js 中现在比较成熟的有**四种模块加载方案**：

- **CommonJS 方案**，同步加载模块，它通过 require 来引入模块，通过 module.exports 定义模块的输出接口。这种模块加载方案是服务器端的解决方案，它是以同步的方式来引入模块的，因为在服务端文件都存储在本地磁盘，所以读取非常快，所以以同步的方式加载没有问题。但如果是在浏览器端，由于模块的加载是使用网络请求，因此使用异步加载的方式更加合适。
  - **同步加载**方式，适用于服务端，因为模块都放在服务器端，对于服务端来说模块加载较快，不适合在浏览器环境中使用，因为同步意味着阻塞加载。
  - 所有代码都运行在模块作用域，不会污染全局作用域。
  - 模块可以多次加载，但只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。
  - 模块加载的顺序，按照其在代码中出现的顺序。
- **AMD （Asynchronous Module Definition）方案**，异步模块加载方案，这种方案采用异步加载的方式来加载模块，模块的加载不影响后面语句的执行，所有依赖这个模块的语句都定义在一个回调函数里，等到加载完成后再执行回调函数。require.js 实现了 AMD 规范
  - **AMD允许输出的模块兼容CommonJS**
  - 异步并行加载，不阻塞 DOM 渲染。
  - **`推崇依赖前置`**，也就是提前执行（预执行），在模块使用之前就已经执行完毕。
- **CMD （Common Module Definition）方案**，通用模块加载方法，这种方案和 AMD 方案都是为了解决异步模块加载的问题，sea.js 实现了 CMD 规范。它和require.js的区别在于模块定义时对依赖的处理不同和对依赖模块的执行时机的处理不同。
- 第四种方案是 ES6 提出的方案，使用 import 和 export 的形式来导入导出模块是尽量的静态化，使得`编译时`就能确定模块的依赖关系，以及输入和输出的变量。
  ES6 中，**import**引用模块，使用**export**导出模块。默认情况下，Node.js默认是不支持**import**语法的，通过**babel**项目将 ES6 模块 编译为 ES5 的 CommonJS。因此**Babel**实际上是将**import/export**翻译成Node.js支持的**require/exports**。



|              |          CommonJS           |               AMD                |               CMD                |           ES6            |
| :----------: | :-------------------------: | :------------------------------: | :------------------------------: | :----------------------: |
|   引用模块   |           require           |             require              |             require              |          import          |
|   暴露接口   | module.exports \|\| exports |     define函数返回值 return      |             exports              |          export          |
| **加载方式** |  **运行时加载，同步加载**   | **并行加载，提前执行，异步加载** | **并行加载，按需执行，异步加载** | **编译时加载，异步加载** |
| 实现模块规范 |           NodeJS            |            RequireJS             |              SeaJS               |          原生JS          |
|     适用     |           服务器            |              浏览器              |              浏览器              |      服务器/浏览器       |

引到 require和import的区别



> **ES6 Module和CommonJS模块的区别：**

- CommonJS是对模块的浅拷⻉，ES6 Module是对模块的引⽤，即ES6 Module只存只读，不能改变其值，也就是指针指向不能变，类似const；
- import的接⼝是read-only（只读状态），不能修改其变量值。 即不能修改其变量的指针指向，但可以改变变量内部指针指向，可以对commonJS对重新赋值（改变指针指向），但是对ES6 Module赋值会编译报错。

ES6 Module和CommonJS模块的共同点：

- CommonJS和ES6 Module都可以对引⼊的对象进⾏赋值，即对对象内部属性的值进⾏改变。



而require/exports 和 import/export 本质上的区别，实际上也就是CommonJS规范与ES6模块化的区别

1、浏览器在不做任何处理时，默认是不支持import和require
2、babel会将ES6模块规范转化成Commonjs规范
3、webpack、gulp以及其他构建工具会对Commonjs进行处理，使之支持浏览器环境
它们有三个重大差异。

1. CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。
2. CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。
3. CommonJS 模块的`require()`是`同步`加载模块，ES6 模块的`import`命令是`异步`加载，有一个独立的模块依赖的解析阶段。



> **AMD 和 CMD 规范的区别？**

- 第一个方面是在模块定义时对依赖的处理不同。AMD推崇依赖前置，在定义模块的时候就要声明其依赖的模块。而 CMD 推崇就近依赖，只有在用到某个模块的时候再去 require。
- 第二个方面是对依赖模块的执行时机处理不同。首先 AMD 和 CMD 对于模块的加载方式都是异步加载，不过它们的区别在于模块的执行时机，AMD 在依赖模块加载完成后就直接执行依赖模块，依赖模块的执行顺序和我们书写的顺序不一定一致。而 CMD在依赖模块加载完成后并不执行，只是下载而已，等到所有的依赖模块都加载好后，进入回调函数逻辑，遇到 require 语句的时候才执行对应的模块，这样模块的执行顺序就和我们书写的顺序保持一致了。
- AMD 是**提前执行**，CMD 是**延迟执行**。
- AMD 是**依赖前置**，CMD 是**依赖就近**

```js
// CMD
define(function(require, exports, module) {
  var a = require("./a");
  a.doSomething();
  // 此处略去 100 行
  var b = require("./b"); // 依赖可以就近书写
  b.doSomething();
  // ...
});

// AMD 默认推荐
define(["./a", "./b"], function(a, b) {
  // 依赖必须一开始就写好
  a.doSomething();
  // 此处略去 100 行
  b.doSomething();
  // ...
})
```

- **AMD**：`requirejs` 在推广过程中对模块定义的规范化产出，提前执行，推崇依赖前置
- **CMD**：`seajs` 在推广过程中对模块定义的规范化产出，延迟执行，推崇依赖就近
- **CommonJs**：模块输出的是一个值的 `copy`，运行时加载，加载的是一个对象（`module.exports` 属性），该对象只有在脚本运行完才会生成
- **ES6 Module**：模块输出的是一个值的引用，编译时输出接口，`ES6`模块不是对象，它对外接口只是一种静态定义，在代码静态解析阶段就会生成。





**谈谈对模块化开发的理解**

- 我对模块的理解是，一个模块是实现一个特定功能的一组方法。在最开始的时候，js 只实现一些简单的功能，所以并没有模块的概念，但随着程序越来越复杂，代码的模块化开发变得越来越重要。
- 由于函数具有独立作用域的特点，最原始的写法是使用函数来作为模块，几个函数作为一个模块，但是这种方式容易造成全局变量的污染，并且模块间没有联系。
- 后面提出了对象写法，通过将函数作为一个对象的方法来实现，这样解决了直接使用函数作为模块的一些缺点，但是这种办法会暴露所有的所有的模块成员，外部代码可以修改内部属性的值。
- 现在最常用的是立即执行函数的写法，通过利用闭包来实现模块私有作用域的建立，同时不会对全局作用域造成污染。







## 50  display:none和visibility:hidden的区别?

#### 「重绘和回流」

- **重绘：**当渲染树中的元素外观（如：颜色）发生改变，不影响布局时，产生重绘
- **回流：**当渲染树中的元素的布局（如：尺寸、位置、隐藏/状态状态）发生改变时，产生重绘回流
- 注意：JS获取Layout属性值（如：`offsetLeft`、`scrollTop`、`getComputedStyle`等）也会引起回流。因为浏览器需要通过回流计算最新值
- 回流必将引起重绘，而重绘不一定会引起回流

**如何最小化重绘(repaint)和回流(reflow)**：

- 需要要对元素进行复杂的操作时，可以先隐藏(`display:"none"`)，操作完成后再显示
- 需要创建多个`DOM`节点时，使用`DocumentFragment`创建完后一次性的加入`document`
- 缓存`Layout`属性值，如：`var left = elem.offsetLeft;` 这样，多次使用 `left` 只产生一次回流
- 尽量避免用`table`布局（`table`元素一旦触发回流就会导致table里所有的其它元素回流）
- 避免使用`css`表达式(`expression`)，因为每次调用都会重新计算值（包括加载页面）
- 尽量使用 `css` 属性简写，如：用 `border` 代替 `border-width`, `border-style`, `border-color`
- 批量修改元素样式：`elem.className` 和 `elem.style.cssText` 代替 `elem.style.xxx`

#### 空间占据

display:none 隐藏后的元素**不占据任何空间**，而 visibility:hidden 隐藏的元素**空间依旧存在**。

#### 回流和渲染

> display:none 隐藏产生`回流和重绘（reflow 和 repaint）`，而 visibility:hidden 只产生`重绘`。

#### 株连性

display:none 就是“株连性”明显的声明：一旦父节点元素应用了 **display:none**，父节点及其子孙节点元素**全部不可见**，而且无论其子孙元素如何不屈地挣扎都无济于事。

#### 隐藏失效

若子孙元素应用了 **visibility:visible**，则这个子孙元素不但不会隐藏，而且会显现出来。visibility具有继承性，给父元素设置visibility:hidden;子元素也会继承这个属性。但是如果重新给子元素设置visibility: visible,则子元素又会显示出来。这个和display: none有着质的区别



## 51  移动端自适应适配布局方案

> **基础概念解析：**

**分辨率**：1334pt x 750pt
指的是屏幕上垂直有1334个物理像素，水平有750个物理像素。

**屏幕尺寸**：4.7in
注意英寸是长度单位，不是面积单位。4.7英寸指的是屏幕对角线的长度，1英寸等于2.54cm。

**屏幕像素密度**：326ppi
指的是每英寸屏幕所拥有的像素数，在显示器中，dpi=ppi。dpi强调的是每英寸多少点。同时，**屏幕像素密度**=**分辨率**/**屏幕尺寸**

接着，我们来看一下其他的单位。

**设备独立像素**：设备独立像素，不同于设备像素（物理像素），它是虚拟化的。比如说css像素，我们常说的10px其实指的就是它。需要注意的是，**物理像素**开发者是无法获取的，它是自然存在的一种东西，该是多少就是多少。

**设备像素比**：缩写简称**dpr**，也就是我们经常在谷歌控制台移动端调试顶端会看到的一个值。**设备像素比** = **设备像素** / **css像素**（垂直方向或水平方向）。可以通过JS来获取：`window.devicePixelRatio`

**位图像素：**位图像素是栅格图像（如：png,jpg,gif等）最小的数据单元。每一个位图像素都包含着一些自身的显示信息。（如：显示位置，颜色值，透明度等）



> **视口：**

**布局视口：**在手机上，视口与移动端浏览器屏幕宽度不再相关联，是完全独立的，这个浏览器厂商定的视口被称为**布局视口**。`document.documentElement.clientWidth/Height`返回布局视口的尺寸

```xml
<meta name="viewport" content="width=640">   // 设置布局视口的宽度
```



**视觉视口**：视觉视口是用户正在看到的网页的区域，大小是屏幕中CSS像素的数量。`window.innerWidth/Height`返回视觉视口的尺寸



**理想视口：**布局视口明显对用户是不友好的，完全忽略了手机本身的尺寸。所以苹果引入了理想视口的概念，它是**对设备来说最理想的布局视口尺寸**。理想视口中的网页用户最理想的宽度，用户进入页面的时候不需要缩放。

```
<meta name="viewport" content="width=device-width">  // 设置理想视口
```



> **缩放：**

在下载浏览器中，可以这么算（理想视口与视觉视口的比）：

```pgsql
zoom level = screen.width / window.innerWidth
```

**禁止缩放**

```routeros
<meta name="viewport" content="user-scalable=no">
```

**设置缩放**

```routeros
<meta name="viewport" content="initial-scale=2">
```

使用`initial-scale`有一个副作用：同时也会将布局视口的尺寸设置为缩放后的尺寸。所以`initial-scale=1`与`width=device-width`的效果是一样的。



#### 固定一个某些宽度，使用一个模式，加上少许的媒体查询方案

#### 使用flexbox解决方案：

**flex+vw的布局方式/flex+百分比的布局方式**更受前端开发者的欢迎

#### 使用百分比加媒体查询

```
media queries :主要通过查询不同的宽度来执行不同的css代码，最终以达到界面的配置。
核心语法：
@media screen and(max-width:600px){
	/**
		*/
	html{
	 font-size:32px;
	}
}

```

#### 使用rem + viewport缩放

```
根据屏幕宽度设定rem值，需要适配的元素都使用rem单位，不需要适配的元素还是使用px单位。1em=16px;
```

```
1.根据rem将页面放大dpr倍, 然后viewport设置为1/dpr.

如iphone6 plus的dpr为3, 则页面整体放大3倍, 
1px(css单位)在plus下默认为3px(物理像素) 

然后viewport设置为1/3, 这样页面整体缩回原始大小. 从而实现高清。

```



## 52  如何实现浏览器内多个标签页之间的通信

实现多个标签页之间的通信，本质上都是通过中介者模式来实现的。因为标签页之间没有办法直接通信，因此我们可以找一个中介者，让标签页和中介者进行通信，然后让这个中介者来进行消息的转发。通信方法如下：

- **使用 websocket 协议**，因为 websocket 协议可以实现服务器推送，所以服务器就可以用来当做这个中介者。标签页通过向服务器发送数据，然后由服务器向其他标签页推送转发。
- **使用 ShareWorker 的方式**，shareWorker 会在页面存在的生命周期内创建一个唯一的线程，并且开启多个页面也只会使用同一个线程。这个时候共享线程就可以充当中介者的角色。标签页间通过共享一个线程，然后通过这个共享的线程来实现数据的交换。
- **使用 localStorage 的方式**，我们可以在一个标签页对 localStorage 的变化事件进行监听，然后当另一个标签页修改数据的时候，我们就可以通过这个监听事件来获取到数据。这个时候 localStorage 对象就是充当的中介者的角色。
- **使用 postMessage 方法**，如果我们能够获得对应标签页的引用，就可以使用postMessage 方法，进行通信。



## 53  IndexDB有哪些特点

![image-20211004210551946](C:/Users/WEXIA/AppData/Roaming/Typora/typora-user-images/image-20211004210551946.png)



## 54  数组扁平化有哪些方法

```
let ary = [1, [2, [3, [4, 5]]], 6];
let str = JSON.stringify(ary);
```

```
//第0种处理:直接的调用
arr_flat = arr.flat(Infinity);
```

```
//第一种处理
ary = str.replace(/(\[|\])/g, '').split(',');
```

```
//第二种处理
str = str.replace(/(\[\]))/g, '');
str = '[' + str + ']';
ary = JSON.parse(str);
```

```
//第三种处理：递归处理
let result = [];
let fn = function(ary) {
  for(let i = 0; i < ary.length; i++) }{
    let item = ary[i];
    if (Array.isArray(ary[i])){
      fn(item);
    } else {
      result.push(item);
    }
  }
}
```

```
//第四种处理：用 reduce 实现数组的 flat 方法
function flatten(ary) {
    return ary.reduce((pre, cur) => {
        return pre.concat(Array.isArray(cur) ? flatten(cur) : cur);
    }, []);
}
let ary = [1, 2, [3, 4], [5, [6, 7]]]
console.log(flatten(ary))
```

```
//第五种处理：扩展运算符
while (ary.some(Array.isArray)) {
  ary = [].concat(...ary);
}
```





## 55  了解哪些前沿前端方向和技术

### **1、小程序**

在这个项目中，今年仍然是项目突然进展的一年。所有主要应用程序都已启动，所有前端团队都有专门的程序开发团队来满足更快程序开发的需求。与此同时，APP程序中的许多关键功能已经被小程序所取代，甚至有些APP程序已经变成了Nativex小程序外壳，上层应用完全由小程序来实现。

在微信小程序出现之前，每个人都在谈论Hybird和ReactNative，但这只是技术层面的狂欢，没有注入商业属性。小程序的出现，一方面告诉业界，Webview在当前的设备上并没有变坏，另一方面，告诉业界如何让有能力的企业在超级应用程序上的私有域中运行。

另一方面，从技术角度来看，在上层DSL的严格限制下，超级APP可以定义满足自身需求的网络标准，弥补了当前网络标准的不足。最后，它可以与客户端合作生产出各种类似NSR的酷技术模型，离线、预装、定制的网络视图(Webview)，这样网络最终可以以低成本实现原生版本的体验，不会像Weex那样在终端外有点尴尬。

然而，由于需要依靠超级应用(微信、支付宝、百度、美团、头标等)，由于各种平台采用的具体方案不同，目前小程序的登陆方案也不同，有时需要开发多套代码。
![image-20201229153615862](https://img-blog.csdnimg.cn/img_convert/a949d530d3b5d355f1a1ff33df3c20f2.png)

### **2、跨终端开发**

对于跨终端开发，RN状态通常是成熟的，或者没有太多的开发前景，因为它仍然处于0.61版本，而1.0版本似乎还很遥远。因此，今年许多团队改变了他们的调子，以 Flutter为Release，这重新点燃了希望，并使 Flutter前端渴望尝试。

同时，苹果也发布了新的用户界面系统——SwiftUI。与此同时，面向网络的SwiftUI已经在开源社区中上路了。安卓的SwiftUI会远远落后吗？

跨终端开发，颤振仍将快速发展，并将有更多的开发者。Flutter on JS、SwiftUIfor Web&Android上也将是值得期待的开源软件。毕竟，跨终端仍然没有完美的解决方案。

![image-20201229153000885](https://img-blog.csdnimg.cn/img_convert/8c472ec1cac6e57f4cf9ea6ee8702a35.png)

### **3、前端工程**

在前端编程中，开发人员最重要的基本成就是提高效率，此时前端开发人员将继续迭代和优化。

我们曾经谈论过Yoman、CLI和其他系列的构建工具，但是在团队成长之后，我们仍然几乎没有任何感觉。相比之下，Java学生从未听说过从没听说过 Spring Boot 配置工程师。今年，许多团队正在构建一个完整的前端DevOps流程套件，一些团队也开始协作并一起构建。无论是网络项目还是程序项目，从新项目、开发、调运、部署、测试、发布、运行和维护到监控统计，都有完善的设施来保证和提高效率，前端流程在未来将更加标准化。

展望2020年前端的发展，前端工程系统肯定会更加闭环，不像脚手架那么简单，而是将集成开发环境(IDE)结合起来，从项目初始化、代码编写、配置项、灰度级和发布，打开业务属性，形成一个完整的闭环。

### **4、Serverless**

Serverless的⽕爆⼏乎可以归因于前端。因为无Serverless可以完美地支持Node.js，所以Serverless可以帮助前端开发人员在制作⽤Node.js.的过程中解决许多问题

大多数当前的前端工程师都受过培训。尽管他们无法与真正的服务器端开发学生相比，但他们也可以编写许多服务端业务逻辑。目前，许多公司都在做BFF层来满足这部分需求，但仍然无法摆脱运行维护和机器配送的障碍。随着无服务器(Serverless)的逐步登陆，代码的BFF层将摆脱操作和维护、机器分配等复杂问题。同时，前端学生将高概率地编写这部分代码，而服务器端学生将专注于中型系统的实现。就业务而言，试错的成本也将大大降低。

随着Node.js成为前端开发人员必备的技能，云计算的持续流行将使无服务器成为可能。随着越来越多的开发人员尝到研发的甜头，无服务器必将改变前端的研发模式。

同时，使用无服务器的学生肯定会使用TS。这也意味着如果没有在2020年写测试，它可能真的过时了。

![image-20201229143334499](https://img-blog.csdnimg.cn/img_convert/0f56a07750d0e903a268476d5bf81bfa.png)

### **5、WebAssembly**

WebAssembly是一种新的字节码格式。目前，主流浏览器支持WebAssembly。与JS的解释和执行不同，WebAssembly字节码与底层机器代码非常相似，可以快速加载和运行，因此性能比JS解释和执行有了很大提高。也就是说，WebAssembly不是一种编程语言，而是一种字节码标准，需要用高级编程语言编译并放入WebAssembly虚拟机中运行。浏览器制造商需要做的是根据WebAssembly规范实现虚拟机。使用WebAssembly，您可以在浏览器上运行任何语言。从Javascript到TypeScript到Babel，这些都需要翻译成js来执行，而WebAssembly嵌入在浏览器中，不需要翻译就可以直接执行，所以执行效率自然要高得多。

例如，AutoCAD软件是由AutoCAD生产的自动计算机辅助设计软件，可用于绘制二维图形和基本三维设计。使用时无需编程即可自动绘图，因此广泛应用于民用建筑、装饰、工业制图、工程制图、电子工业、服装加工等诸多领域。

AutoCAD是由大量的C代码编写的软件，经历了从桌面到移动再到网络的许多技术变革。此前，在InfoQ上有一篇题为《AutoCAD WebAssembly: Moving a 30 Year Code Base to the Web》的演讲，即通过网络组装(WebAssembly)，许多旧的C代码可以在网络上运行，执行效率得到保证。

Hrome的核心JavaScript引擎V8现在包括了Liftoff，一个新的WebAssembly baseline编译器。Liftoff简单快速的代码生成器大大提高了WebAssembly应用程序的启动速度。2019年，许多公司将开始投资于网络组装的学习和转型。据信，网络组装将在2020年经历一个爆炸性时期。

### **6、5G**

2020年，5G将是一个不可分割的话题。首先，5G带宽的增加带来了传统网络复杂性的提高，就像2G到4G过程中从WAP纯超链接时代向4G全画面视频时代的转变一样。5G肯定是一个巨大的变化，但它绝对不会在一夜之间发生。因为相应的配套设施也需要逐步完善，如硬件性能和浏览器处理速度。服务器端渲染无疑是捷径之一。轻前端和重后端，5G是一座桥梁。将渲染放在后端并不像同构那么简单。它需要关注和优化渲染性能。在这个机会下，WebAssembly可能会得到快速发展，因为它可以在后台缝合和连接多种语言。背景渲染的优化也将带来前端研发模式和技术架构的变化。

其次，5G带来的一切互联将带来不同于智能机器和普通电脑的各种场景。虚拟现实、可穿戴设备、载体系统、智能投影、智能交互等。将把网络带入各种垂直领域，这也意味着前端会有更多的空间。相信随着5G的大规模业务，一批新的互联网巨头将会诞生。

### typescript

第一个就是TypeScript，TypeScript整个呈现出爆发性的增长

![image-20201229143534841](https://img-blog.csdnimg.cn/img_convert/6168743a7b0efe877c447deb7ca3b01a.png)

















## !!!知识笔记!!!

- JavaScript中除了基本类型之外，都是对象，函数也是一个**特殊的对象**
- `static` 静态方法被设计为只能被创建它们的构造器使用，并且不能传递给实例，否则会抛出`TypeError`错误
- 使用  `new `新建的是一个对象，如果不用`new`新建对象，那么this里面的指向问题需要明确
- 不能像常规对象那样，给构造函数添加属性，如果想一次性给所有实例添加特性，应该使用原型
- 除了**基本对象**（base object），所有对象都有原型。基本对象可以访问一些方法和属性，比如 `.toString`
- 如果使用标记模板字面量，第一个参数的值总是包含字符串的数组。其余的参数获取的是传递的表达式的值

```
function getPersonInfo(one, two, three) {
  console.log(one)
  console.log(two)
  console.log(three)
}

const person = 'Lydia'
const age = 21

getPersonInfo`${person} is ${age} years old`  // ["", " is ", " years old"] "Lydia" 21
```

- 在测试相等性时，**基本类型**通过它们的**值（value）**进行比较，而**对象**通过它们的**引用（reference）**进行比较。JavaScript 检查对象是否具有对内存中**相同位置的引用**。题目中我们正在比较的两个对象不是同一个引用：作为参数传递的对象引用的内存位置，与用于判断相等的对象所引用的内存位置并不同。

- 扩展运算符（`...args`）会返回实参组成的数组。而数组是对象。

- 使用 `"use strict"`，你可以确保不会意外地声明全局变量，这样使用了全局的话会报出`ReferenceError`的错误

- `eval()` 函数会将传入的字符串当做 JavaScript 代码进行执行。`eval()` 的参数是一个字符串。如果字符串表示的是表达式，`eval()` 会对表达式进行求值。如果参数表示一个或多个 JavaScript 语句，那么`eval()` 就会执行这些语句。不需要用 `eval()` 来执行一个算术表达式：因为 JavaScript 可以自动为算术表达式求值。

- 关闭 **tab 标签页** 后，`sessionStorage` 存储的数据才会删除。

  如果使用 `localStorage`，那么数据将永远在那里，除非调用了 `localStorage.clear()`。

- 所有**对象的键**（不包括 Symbol）在**底层都是字符串**，即使你自己没有将其作为字符串输入。对于集合，它不是这样工作的，集合中字符串跟数字是要区分的

- **falsy** 值 (虚值) 是在 [Boolean](https://developer.mozilla.org/zh-CN/docs/Glossary/Boolean) 上下文中认定为 false 的值。

- `typeof 1` 返回 `"number"`。 `typeof "number"` 返回 `"string"`

- 当你为数组设置超过数组长度的值的时候， JavaScript 会创建名为 "empty slots" 的东西。它们的值实际上是 `undefined`

- `null` 是 [falsy ]。 `!null` 的值是 `true`。 `!true` 的值是 `false`。

  `""` 是 [falsy ]。 `!""` 的值是 `true`。 `!true` 的值是 `false`。

  `1` 是 [truthy]。 `!1` 的值是 `false`。 `!false` 的值是 `true`。

- `setInterval` 返回一个唯一的 id。此 id 可被用于 `clearInterval` 函数来取消定时。

- string 类型是可迭代的。扩展运算符将迭代的每个字符映射成一个元素。

  ```javascript
  [...'Lydia']   // ["L", "y", "d", "i", "a"]
  ```

- `for...in`语句以任意顺序迭代对象的**可枚举属性**。简单来说，`for...in`遍历的就是 key。对于数组，key对应着的是数组的**下标索引**。

- 当函数没有返回任何值时，即默认返回`undefined`.

- 普通参数都是 ***值*** 传递的，而对象则不同，是 ***引用*** 传递。

- 通过`throw`语句，我么可以创建自定义错误。 而通过它，我们可以抛出异常。异常可以是一个**字符串**, 一个 **数字**, 一个 **布尔类型** 或者是一个 **对象**。

- 我们可以用`delete`关键字删除对象的属性，对原型也是适用的。删除了原型的属性后，该属性在原型链上就不可用了。当我们尝试调用一个不存在的函数时`TypeError`异常会被抛出。

- 引入的模块是 *只读* 的: 你不能修改引入的模块。只有导出他们的模块才能修改其值。

- `delete`操作符返回一个布尔值： `true`指删除成功，否则返回`false`. 但是通过 `var`, `const` 或 `let` 关键字声明的变量无法用 `delete` 操作符来删除。

- 通过`defineProperty`方法，我们可以给对象添加一个新属性，或者修改已经存在的属性。而我们使用`defineProperty`方法给对象添加了一个属性之后，属性默认为 *不可枚举(not enumerable)*. `Object.keys`方法仅返回对象中 *可枚举(enumerable)* 的属性

- `JSON.stringify`的第二个参数是 *替代者(replacer)*. 替代者(replacer)可以是个函数或数组，用以控制哪些值如何被转换为字符串。如果替代者(replacer)是个 *数组* ，那么就只有包含在数组中的属性将会被转化为字符串。而如果替代者(replacer)是个 *函数*，这个函数将被对象的每个属性都调用一遍。 函数返回的值会成为这个属性的值，最终体现在转化后的JSON字符串中。

- 在ES6中，我们可以使用默认值初始化参数。如果没有给函数传参，或者传的参值为 `"undefined"` ，那么参数的值将是默认值。默认参数在调用时才会进行计算，每次调用函数时，都会创建一个新的对象。

- 在子类中，在调用`super`之前不能访问到`this`关键字。 如果这样做，它将抛出一个`ReferenceError`，使用`super`关键字，需要用给定的参数来调用父类的构造函数。 父类的构造函数接收`name`参数。

- `import`命令是编译阶段执行的，在代码运行之前。因此这意味着被导入的模块会先运行，而导入模块的文件会后执行。这是CommonJS中`require()`和`import`之间的区别。使用`require()`，您可以在运行代码时根据需要加载依赖项。

- 每个`Symbol`都是完全唯一的。传递给`Symbol`的参数只是给`Symbol`的一个描述。 `Symbol`的值不依赖于传递的参数。

- `push() `方法将一个或多个元素添加到数组的末尾，并返回该数组的新长度。

- 常规函数，有一个`prototype`属性，它是一个带有`constructor`属性的对象（原型对象）。 然而，箭头函数，没有这个`prototype`属性,尝试访问会返回undefined。

- `... args`是剩余参数，剩余参数的值是一个包含所有剩余参数的数组，**并且只能作为最后一个参数**。

- ```
  // 这样意味着永远不会到达 a+b，因为函数在return关键字之后停止运行
  return 
  a + b
  
  等同于
  return;
  a + b
  ```

- `Symbol`类型是不可枚举的。`Object.keys`方法返回对象上的所有可枚举的键属性。`Symbol`类型是不可见的，并返回一个空数组。 记录整个对象时，所有属性都是可见的，甚至是不可枚举的属性。

  这是`Symbol`的众多特性之一：除了表示完全唯一的值（防止对象意外名称冲突，例如当使用2个想要向同一对象添加属性的库时），您还可以`隐藏`这种方式对象的属性（尽管不完全。你仍然可以使用`Object.getOwnPropertySymbols()`方法访问 `Symbol`。

- 对于箭头函数，如果只返回一个值，我们不必编写花括号。但是，如果您想从一个箭头函数返回一个对象，您必须在圆括号之间编写它，否则不会返回任何值。

- 空对象`{}`是一个真值，空数组`[]`是一个真值。`""`是一个假值。 

- ```
  class Person {
    constructor() {
      this.name = "Lydia"
    }
  }
  
  Person = class AnotherPerson {
    constructor() {
      this.name = "Sarah"
    }
  }
  
  const member = new Person()
  console.log(member.name)     //'Sarah'
  ```

  我们可以将类设置为等于其他类/函数构造函数。 在这种情况下，我们将`Person`设置为`AnotherPerson`。 这个构造函数的名字是`Sarah`，所以新的`Person`实例`member`上的name属性是`Sarah`。

- `Object.defineProperty()` 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。

```
   Object.defineProperty(obj, prop, descriptor)
```

​			**[参数]**

​				`obj`要定义属性的对象。

​				`		prop` 要定义或修改的属性的名称或 [`Symbol`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol) 。

​				`descriptor`要定义或修改的属性描述符。

​			**[返回值]**：被传递给函数的对象。

- **`instanceof`** **运算符**用于检测构造函数的 `prototype` 属性是否出现在某个实例对象的原型链上。

```
object instanceof constructor  // object 某个实例对象     constructor 某个构造函数
// a instance b  ----b的 prototype 属性是否出现在a实例的原型链上
```

- == 操作符的强制类型转换规则
- ![image-20211004145152181](https://gitee.com/wexia/my_pic_bed/raw/master/pics/20211004145153.png)

- 一个拥有 length 属性和若干索引属性的对象就可以被称为类数组对象，类数组对象和数组类似，但是不能调用数组的方法。常见的类数组对象有 arguments 和 DOM 方法的返回结果，还有一个函数也可以被看作是类数组对象，因为它含有 length 属性值，代表可接收的参数个数。

- `arguments`是一个对象，它的属性是从 0 开始依次递增的数字，还有`callee`和`length`等属性，与数组相似；但是它却没有数组常见的方法属性，如`forEach`, `reduce`等，所以叫它们类数组。遍历类数组的方法有：`call和apply方法、Array.from方法、展开运算符`

- CDN（Content Delivery Network，**内容分发网络**）是指一种通过互联网互相连接的电脑网络系统，利用最靠近每位用户的服务器，更快、更可靠地将音乐、图片、视频、应用程序及其他文件发送给用户，来提供高性能、可扩展性及低成本的网络内容传递给用户。

- ![image-20211004164735807](https://gitee.com/wexia/my_pic_bed/raw/master/pics/20211006113536.png)

  ![image-20211004165531885](https://gitee.com/wexia/my_pic_bed/raw/master/pics/20211006113544.png)

